---
title: "ADR 5: File Storage and Access Control (Convex File Storage + Files Control)"
---

## Context

The knowledge system will include **file attachments** – images, PDFs, data files, etc. We need to allow users to upload files and embed or link them in blocks.

<Callout type="info" title="Key Requirements">
  - Handle potentially large binary files - Efficient delivery (possibly via
  CDN) - **Access control** so private files aren't accessible to unauthorized
  users
</Callout>

Since we're using Convex as our backend, we aim to use its provided capabilities for file storage. Convex offers an integrated file storage solution and a component called _Files Control_ that provides a higher-level API for secure file handling.

## Decision

<Callout type="info" title="Core Approach">
  **Utilize Convex's built-in File Storage with the Convex Files Control
  component to manage uploads, downloads, and file permissions.**
</Callout>

We treat files as a special kind of content stored outside the main database (binary storage), referenced by IDs in our Block model.

### Upload Flow

We use a two-step upload process:

1. **Request upload URL:** Client calls a mutation (wrapping `generateUploadUrl`). Returns a one-time **pre-signed URL** and an `uploadToken`.

2. **Upload file directly:** Client uploads the file directly to Convex storage via HTTP PUT to that URL (bypassing our app server). Convex returns a `storageId` if successful.

3. **Finalize upload:** Client calls a mutation (wrapping `finalizeUpload`) with the `uploadToken` and `storageId`. At this point, we create a Block of type "file" in our blocks table linking to this `storageId`. The uploader's user ID is given access by default.

### Serving Files

We generate secure URLs for file access:

<Tabs items={['HTTP Route', 'On-Demand URLs']}>
  <Tab value="HTTP Route">
    The Files Control includes an optional HTTP router to serve files through a path (e.g. `https://<convex-site>/files/download?token=XYZ`).
    
    We enable the download route and use Convex's built-in auth hook to ensure only authorized requests succeed.
  </Tab>
  <Tab value="On-Demand URLs">
    Use `buildDownloadUrl` to create time-limited URLs on demand. When displaying an image, the app requests a URL which embeds a short-lived token.
    
    Even if someone finds the URL, it expires. If `requireAccessKey` is on, it won't work without being logged in.
  </Tab>
</Tabs>

### Access Control

Each file stored in Convex has an associated set of **access keys** (like blocks will have ACL). By default, we use user IDs as access keys.

- **addAccessKey:** When a file block is shared with a user or made public
- **removeAccessKey:** When permissions are revoked
- **hasAccessKey:** Verification check when user tries to download

This integrates with block permissions ([ADR 6](/docs/adr/adr-006-permissions-embargo-model)).

### File Metadata

We store file metadata in our blocks table:

- `fileName`
- `fileSize`
- `contentType`
- `storageId`

This allows displaying file info in the UI and searching if needed. The storage itself is opaque (just an ID for retrieval).

## Rationale

Using Convex's file storage and Files Control component is a pragmatic choice:

- **Integrated Security:** The component enforces access control on file URLs, preventing unauthorized downloads. It generates one-time tokens and handles expiration.

- **Development Speed:** Much faster than setting up our own S3 and writing lambdas to sign URLs. The component even gives us React hooks for upload.

- **Consistency with Convex:** Keeping file handling within Convex's ecosystem maintains a single source-of-truth for both data and files.

- **Scalability and CDN:** Convex's approach (especially if using R2) likely delivers files via CDN. If using R2, Cloudflare's CDN is automatically in play.

- **File Lifecycle Management:** Built-in cleanup for expired files and ability to set expiry on each file.

## Alternatives Considered

<Tabs
  items={["Direct Embedding", "External Storage", "Next.js Serving", "IPFS"]}
>
  <Tab value="Direct Embedding">
    **Direct File Embedding:** Store small files directly in Convex database as
    binary data (e.g., base64 in a block). **Rejected** because it would bloat
    the database and slow queries. Convex's file storage is meant for binaries.
  </Tab>
  <Tab value="External Storage">
    **External Storage (S3/GCS) without Convex integration:** Write our own
    backend endpoints to sign URLs. **Rejected** – more boilerplate and ensuring
    security. We lose tight integration with Convex's auth.
  </Tab>
  <Tab value="Next.js Serving">
    **Serving via Next.js (hosting files on Vercel):** Use Vercel's built-in
    storage for static assets. Doesn't work for user uploads since those are
    dynamic. Vercel has no built-in binary store for user uploads.
  </Tab>
  <Tab value="IPFS">
    **Peer-to-peer or IPFS:** Store files decentralized. **Rejected** –
    complexity and lack of fine-grained access control (everything on IPFS is
    public).
  </Tab>
</Tabs>

## Implications

- **Auth Integration:** File access keys rely on user's `identity.subject` (unique user ID). Every file operation must be tied to an authenticated user.

- **App Size / Bandwidth:** Handling files means potentially large data transferring. We might impose file size limits and encourage compression.

- **Content Security:** Our system doesn't inherently virus-scan or moderate file content. For internal usage this might be okay; for a public platform, might need to integrate content moderation.

- **Managing File Access with Block Sharing:** Keep file ACL in sync with block ACL. If sharing a document containing an image, the image file must also become accessible.

<Callout type="warn" title="Security Consideration">
  Using tokenized URLs for images means tokens can be copied and used by others
  until expiry. If short (say 5 minutes) and continuously refreshed, it's
  reasonably secure.
</Callout>

## Expansion Path

<Cards>
  <Card
    title="Image Thumbnails & Processing"
    href="/docs/adr/adr-008-platform-boundaries-expansion"
  >
    Generate smaller thumbnails for large images. Could integrate a third-party
    or use Vercel Edge Functions for image processing.
  </Card>
  <Card
    title="Video & Audio Handling"
    href="/docs/adr/adr-008-platform-boundaries-expansion"
  >
    Offload to specialized services for encoding/streaming (like Mux or
    Cloudinary).
  </Card>
  <Card
    title="Large Data Files"
    href="/docs/adr/adr-008-platform-boundaries-expansion"
  >
    Integrate with user's own cloud or institutional storage. Allow
    "external_file" blocks that hold URLs instead of actual files.
  </Card>
  <Card title="File Versioning" href="/docs/adr/adr-002-versioning-strategy">
    Allow version history on files. Updating a file block keeps the same block
    id but points to a new storageId.
  </Card>
</Cards>

<Callout type="idea" title="Workflow Integration">
  If we have background processes or agents (see [ADR
  8](/docs/adr/adr-008-platform-boundaries-expansion)) that produce files (like
  an AI generating a report PDF), they can use the same file storage mechanism.
  Our consistent approach means even automated content goes through the same
  pipelines.
</Callout>
