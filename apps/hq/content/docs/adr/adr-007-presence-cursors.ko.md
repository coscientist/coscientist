---
title: "ADR 7: Presence 및 커서 (실시간 사용자 인식)"
---

# ADR 7: Presence 및 커서 (실시간 사용자 인식)

## 컨텍스트

협업 애플리케이션에서 **사용자 presence 인식**을 제공하는 것이 중요합니다: 누가 온라인인지, 동일한 콘텐츠를 보거나 편집하는지, 커서나 선택이 어디에 있는지 확인합니다. 이는 충돌을 피하는 데 도움이 될 뿐만 아니라(예: 다른 사람이 입력하는 곳을 편집하지 않을 수 있음) 협업과 사회적 연결감을 더합니다[[61]](https://stack.convex.dev/presence-with-convex#:~:text=Presence,%2520as%2520we%E2%80%99ll%2520use%2520the,in%2520a%2520Google%2520Doc,%2520etc). 기능에는 일반적으로 현재 문서를 보거나 편집하는 사용자 목록 또는 아바타, 누군가가 입력하는지 여부를 나타내는 표시기, 텍스트에서 각 사용자의 위치를 보여주는 라이브 커서 또는 하이라이트가 포함됩니다. MVP에서 이를 구현하여 다중 사용자 경험을 향상시키고자 합니다. 백엔드인 Convex는 실시간 기능을 가지고 있지만 presence 데이터는 다른 특성을 가집니다: 임시적(모든 커서 이동을 장기간 유지할 필요 없음)이고 고빈도(커서 이동은 초당 여러 번일 수 있음)입니다. 시스템을 과부하시키지 않으면서도 원활한 경험을 제공하는 효율적인 접근 방식이 필요합니다.

## 결정

**주기적 하트비트와 경량 커서 데이터로 문서당 각 사용자의 활동을 추적하는 Convex 기반 presence 시스템을 구현하고 최소 지연으로 이 정보를 표시합니다.** 주요 구성 요소는:

- **Presence 테이블:** Convex 테이블(예: presence)을 생성하며, (documentId, userId)로 키가 지정된 항목이 있습니다. 각 항목에는 다음과 같은 필드가 포함됩니다:
  - userId(또는 사용자당 여러 세션인 경우 세션 ID),
  - documentId(또는 모든 block 수준에서 presence를 추적하는 경우 blockId일 수 있음. 편집 컨텍스트를 위해 최상위 문서에서 추적할 가능성이 높음),
  - lastActive: number(마지막 하트비트 또는 작업의 타임스탬프),
  - cursorPos: object(문서에서 현재 커서/선택의 표현일 수 있음),
  - status: string(예: "editing"/"online"/"idle" 등, 또는 isTyping: boolean과 같은 플래그).
- **참여/퇴장:** 사용자가 문서 또는 협업 편집기를 열면 해당 문서에 대한 presence 항목을 추가하거나 업데이트합니다. 떠날 때(다른 곳으로 이동하거나 연결 해제) 시간 초과 후 제거하거나 오프라인으로 표시해야 합니다.
- **하트비트 메커니즘:** 각 클라이언트는 몇 초마다(예: 기본값으로 5초마다) 하트비트(Convex 변경을 통해)를 보내 lastActive를 업데이트합니다. 이는 여전히 존재함을 신호하기 위한 것입니다[[62]](https://stack.convex.dev/presence-with-convex#:~:text=A%2520common%2520way%2520to%2520detect,resources%2520your%2520app%2520will%2520consume). 다른 메시지에 편승하여 최적화할 수 있습니다: 예를 들어, 사용자가 활발하게 편집하는 경우(따라서 step을 보냄) 본질적으로 presence를 업데이트하므로 활동 중에 별도의 하트비트를 건너뛸 수 있습니다.
- **반응형 쿼리:** documentId가 주어지면 해당 문서에 대한 모든 presence 레코드를 반환하는 Convex 쿼리 함수를 가질 것입니다(임계값을 넘어 오프라인인 것을 필터링할 수 있음). Convex 쿼리는 반응형이므로 이 쿼리를 구독하는 모든 클라이언트는 presence 레코드가 변경될 때마다 업데이트를 받습니다[[63]](https://stack.convex.dev/presence-with-convex#:~:text=Reactivity). 이는 새로운 사람이 온라인 상태가 되거나 커서를 이동할 때(커서 이동을 위해 테이블을 업데이트하는 경우) 다른 사람이 알게 됨을 의미합니다.
- **커서 처리:**
  - 텍스트 커서의 경우: 다른 사람이 문서 사본에 매핑할 수 있는 방식으로 위치를 나타내야 합니다. 모든 클라이언트가 ProseMirror OT를 통해 동기화되어 있으면 문서 버전을 공유합니다. 커서를 문서의 위치(인덱스)로 저장할 수 있습니다. 그러나 라이브 편집으로 인해 각 원격 step 후 업데이트하지 않으면 인덱스가 빠르게 오래될 수 있습니다. 강력한 솔루션은 ProseMirror의 위치 매핑을 사용하는 것입니다: 커서를 브로드캐스트할 때 특정 버전에 첨부하거나 작업을 통해 변환합니다. 이는 복잡할 수 있습니다. 더 간단한 MVP 접근 방식: 두 사람이 다른 영역에서 입력하는 경우 위치는 대부분 한쪽 끝에서 이동합니다. 약간의 부정확성을 수용하거나 편집 후 커서를 느리게 업데이트할 수 있습니다.
  - 커서를 협업과 통합할 수 있습니다: 예를 들어, 사용자의 편집기 상태가 변경될 때마다(ProseMirror는 각 step 후 이전 위치에서 새 위치로의 매핑을 제공할 수 있음) presence에서 커서 위치를 업데이트합니다. 각 커서에 대한 문서에 고유 마커를 저장하는 전략을 사용할 수도 있습니다(일부 협업 시스템이 이를 수행) 그러나 ProseMirror의 협업 플러그인은 기본적으로 이를 포함하지 않았습니다.
  - 시간을 고려할 때 MVP는 단순화된 접근 방식을 선택할 수 있습니다: 정확한 문자가 아닌 사용자가 집중하는 _block 또는 섹션_을 추적합니다. 또는 완벽한 조정 없이 커서 인덱스만 추적합니다 – 적당한 편집 시나리오에서는 일반적으로 거의 정확할 것입니다. **presence 데이터에서 커서 위치를 인덱싱하는 것은 동시 편집으로 인해 복잡합니다**[[64]](https://stack.convex.dev/presence-with-convex#:~:text=Text%2520cursors%2520are%2520an%2520important,it%2520at%2520that%2520for%2520now). 사용자가 활발하게 편집하지 않을 때 정확한 커서를 제한할 수 있습니다.
  - 또는 MVP의 경우 라이브 텍스트 커서를 생략하고 사용자가 무언가를 선택할 때 사용자 하이라이트(색상 선택과 같은)만 표시할 수 있으며, 사용 가능한 경우 ProseMirror의 협업 편집 인식을 사용합니다.
  - 마우스 커서의 경우(원격 마우스 포인터를 표시하려는 경우): 매우 고빈도이며 텍스트 편집에 필수적이지 않습니다. 실제 마우스 위치를 표시하는 것을 건너뛸 것이며 텍스트 커서/선택에만 집중합니다. 수행하는 경우 고르지 않음[[65]](https://stack.convex.dev/presence-with-convex#:~:text=For%2520mouse%2520cursors,%2520the%2520challenge,where%2520the%2520cursor%2520is%2520moving) 및 임시 특성[[66]](https://stack.convex.dev/presence-with-convex#:~:text=Sharing%2520mouse%2520cursor%2520positions%2520are,the%2520data%2520is%2520especially%2520ephemeral)으로 인해 DB에 모든 이동을 저장하지 않을 것입니다.
- **프론트엔드 표시:** 문서에 사용자 아바타의 "facepile"을 표시하며, 온라인/오프라인별로 그룹화하고 안정적인 순서(예: 참여 시간별로 정렬하여 섞이지 않도록)를 사용하는 로직을 사용할 수 있습니다[[67]](https://stack.convex.dev/presence-with-convex#:~:text=A%2520%E2%80%259Cfacepile%E2%80%259D%2520is%2520a%2520popular,in%2520mind%2520when%2520building%2520them). presence의 각 사용자는 가능한 경우 텍스트 위치에 색상 커서 또는 이름 레이블과 함께 표시될 수 있습니다. 여러 사용자인 경우 각각 할당된 색상을 받습니다. presence 데이터를 재사용할 수 있습니다(항목이 참여할 때 할당된 색상 필드를 가질 수 있거나 userId의 해시로 색상을 선택하기만 하면 됨).
- **지연 고려 사항:** Presence 업데이트(입력 상태 또는 커서와 같은)는 빈번할 수 있습니다. 범람을 피하기 위해 **presence 업데이트를 속도 제한**할 것입니다. 예를 들어, 커서 위치를 최대 초당 5번 또는 유휴 중지 시 업데이트합니다(누군가가 커서를 드래그하는 경우 중간 지점이 필요하지 않음). Convex presence 기사는 부하를 관리하기 위해 **단일 비행**(하나가 이미 진행 중인 경우 중간 업데이트 삭제)을 사용할 것을 제안합니다[[68]](https://stack.convex.dev/presence-with-convex#:~:text=Presence%2520performance). 이를 채택할 수 있습니다: 본질적으로 사용자가 커서를 빠르게 이동하는 경우 업데이트를 일괄 처리하거나 최신 것만 보냅니다.
- **내구성:** 일부 presence 정보는 임시적이기를 원합니다(모든 사람이 떠나면 커서 위치를 저장할 필요 없음). 그러나 일부는 더 오래 저장하고 싶습니다: 예: lastActive는 "5분 전 마지막 온라인"을 표시하는 데 사용될 수 있습니다. 연결 해제 후 일정 시간 동안 presence 항목을 유지합니다(또는 오프라인으로 표시). 별도의 테이블이거나 상태와 함께 동일한 것을 재사용할 수 있습니다. 정리: 테이블을 깨끗하게 유지하기 위해 비활성 24시간 후 오래된 항목을 제거하는 cron이 있을 수 있습니다.
- **입력 표시기:** 사용자가 입력 중인지 아니면 단순히 보고 있는지 플래그를 업데이트할 수 있습니다. 간단한 접근 방식: 사용자가 활발하게 텍스트를 입력할 때 상태를 "typing"으로 업데이트하고 입력하지 않을 때 "online"으로 설정합니다. 키 누름 이벤트로 입력을 감지한 다음 몇 초 동안 입력이 없으면 정상으로 되돌릴 수 있습니다.

## 근거

- **사회적 presence는 사용자 경험을 개선합니다:** 언급했듯이 실시간으로 협력자를 보는 것은 연결감을 주고 서로를 맹목적으로 덮어쓸 수 있다는 느낌을 방지합니다[[69]](https://stack.convex.dev/presence-with-convex#:~:text=someone%2520is%2520composing%2520a%2520message,in%2520a%2520Google%2520Doc,%2520etc). 정적 위키를 활기찬 작업 공간으로 바꿉니다.
- **Convex는 presence에 적합합니다:** Convex의 실시간 푸시 및 자동 무효화는 별도의 WebSocket 채널을 수동으로 설정하지 않고도 presence를 구현할 수 있음을 의미합니다. presence 테이블에 쓰고 쿼리하기만 하면 Convex의 반응형 엔진을 사용하여 해당 방의 모든 사람에게 변경 사항을 브로드캐스트합니다[[63]](https://stack.convex.dev/presence-with-convex#:~:text=Reactivity). 이는 사용자 지정 pub-sub보다 간단합니다. 또한 Convex는 단일 비행 메커니즘 덕분에 메모리에서 빈번한 작은 쓰기를 처리하고 마지막 상태만 푸시할 수 있습니다(빠른 테이블 쓰기를 일괄 처리)[[68]](https://stack.convex.dev/presence-with-convex#:~:text=Presence%2520performance).
- **확립된 패턴 사용:** 선택한 presence 접근 방식은 Convex 자체 예제 유틸리티의 영향을 받았습니다[[70]](https://stack.convex.dev/presence-with-convex#:~:text=To%2520make%2520it%2520easy%2520to,in%2520rooms%2520they%E2%80%99re%2520allowed%2520in). 모방하거나 사용할 수 있는 후크 usePresence를 제공하기도 했습니다. 부분 업데이트를 저장하고 사용자당 상태를 쉽게 병합할 것을 제안합니다[[71]](https://stack.convex.dev/presence-with-convex#:~:text=The%2520main%2520difference%2520is%2520that,will%2520have%2520the%2520latest%2520values). 해당 패턴은 예를 들어 한 부분에서 사용자의 커서를 업데이트하고 다른 부분에서 입력 상태를 업데이트하는 경우 충돌을 피하고 사용자당 하나의 객체로 병합하도록 보장합니다.
- **커서 인덱싱 과제 인식:** 텍스트 커서 위치를 정확하게 공유하는 것은 MVP의 전체 범위를 넘어설 수 있는 복잡한 주제임을 인정합니다[[64]](https://stack.convex.dev/presence-with-convex#:~:text=Text%2520cursors%2520are%2520an%2520important,it%2520at%2520that%2520for%2520now). 실용적인 부분 구현(block 수준 presence 또는 대략적인 인덱스일 수 있음)을 선택하여 여전히 일부 인식을 제공합니다. 이를 완전히 해결하지 않기로 한 결정은 Convex 기사가 그 자체로 전체 게시물이 될 수 있다고 언급한 것으로 뒷받침되므로 먼저 더 간단한 측면에 집중합니다.
- **임시 대 영구 트레이드오프:** Presence 데이터는 반임시적입니다. "지금"과 단기 히스토리(마지막으로 본 것과 같은)에 관심이 있습니다. Convex에 저장함으로써(기본적으로 유지) lastActive에 대한 내구성을 얻으며, 이는 누군가가 마지막으로 온라인 상태였던 시기를 표시하는 데 유용합니다(기간 내인 경우). 그러나 정확한 커서 이동과 같은 임시 부분은 세부적으로 기록하지 않을 수 있습니다. presence 테이블을 자주 덮어쓰는 대부분 현재 상태로 취급할 것이며 모든 이동의 로그가 아닙니다. 약간의 누락이 중요하지 않으므로 허용됩니다.
- **별도의 인프라가 필요하지 않은 대안:** WebRTC 또는 Y.js 인식을 presence에 사용할 수 있었지만 협업을 위해 이미 Convex가 열려 있으므로 이에 편승하는 것이 가장 간단합니다. Y.js에는 인식 API가 있지만 presence만을 위해 Y를 채택하는 것은 무겁습니다. 솔루션은 우리가 가진 것을 사용합니다.
- **확장성:** 문서당 Presence 데이터는 상대적으로 작습니다(사용자당 하나의 항목만). 수십 명의 사용자라도 괜찮습니다. 업데이트는 빈번하지만 작은 JSON 쓰기입니다. Convex의 반응성 및 캐싱 설계는 예를 들어 50명의 사용자가 온라인인 경우 presence 쿼리가 변경당 한 번만 다시 계산되고 팬아웃이 효율적으로 처리되도록 보장합니다[[24]](https://stack.convex.dev/presence-with-convex#:~:text=Caching). 이는 대규모 협업 세션으로 확장하는 데 도움이 됩니다.

## 고려된 대안

- **Presence 표시기 없음:** presence를 나중으로 연기하는 것을 고려했습니다(핵심 편집에 집중하기 위해). 그러나 현대적 기대와 최소한 온라인 사용자를 표시하는 최소한의 노력을 고려하여 MVP에 포함하기로 선택했습니다.
- **실시간 대신 폴링:** 다른 사람의 presence를 위해 클라이언트가 폴링하도록 할 수 있었습니다(예: 몇 초마다 쿼리). 그러나 이는 덜 효율적이고 실시간입니다. Convex의 푸시는 폴링을 불필요하게 만듭니다. 따라서 즉각적인 업데이트와 낮은 지연을 얻기 위해 푸시를 선호합니다.
- **외부 pub-sub 사용 (Pusher 또는 Ably와 같은):** Convex가 기본 사항을 다루므로 필요하지 않습니다. 이러한 서비스는 미세 조정된 경우 고빈도에서 커서를 약간 더 잘 처리할 수 있지만 다른 서비스를 통합하는 것은 과도하며 Convex가 이미 제공하는 것을 복제할 것입니다.
- **커서를 위한 전체 CRDT:** 커서를 공유하는 CRDT 접근 방식이 있습니다(CRDT 목록의 항목으로 각 커서). 이 작은 기능만을 위해 통합하기에는 너무 복잡해 보였습니다. 제쳐두었습니다.
- **브라우저 피어 인식:** 서버 왕복을 피하기 위해 커서 위치에 대해 WebRTC 브로드캐스트와 같은 것을 활용할 수 있습니다. 조율하기 복잡할 것입니다(특히 다양한 참가자 세트와 함께) 규모에서 정당화되지 않습니다. 따라서 서버 중재를 고수합니다.
- **Presence만 추적, 커서 없음:** Presence의 MVP로서 누가 존재하는지만 표시하고 커서 위치 표시를 건너뛰는 것을 생각했습니다. 그러나 커서를 추가하면(대략적으로라도) 협업 느낌을 크게 향상시킵니다(Google Docs 색상 커서와 같은). 시도하기로 결정했으며 완벽하지 않더라도 여전히 유용합니다. 최악의 경우 마지막으로 알려진 위치를 편집하는 곳에 이름 레이블을 표시합니다.

## 영향

- **개인 정보:** 일부 경우 presence는 개인 정보 문제를 제기할 수 있습니다(누군가가 특정 문서를 보고 있다는 것을 다른 사람이 알기를 원하지 않을 수 있음). 내부 협업이므로 괜찮을 가능성이 높지만 필요한 경우 나중에 "스텔스 모드" 또는 유사한 것을 고려할 수 있습니다. 지금은 모든 presence가 문서에 액세스할 수 있는 사람에게 표시됩니다.
- **잠재적으로 시끄러운 업데이트:** presence를 너무 자주 업데이트하는 경우(모든 키 입력과 같은) 과부하될 수 있습니다. 일괄 처리 및 조절로 완화합니다. 하트비트 간격을 미세 조정하고 중요한 이동 후 또는 유휴 후에만 커서 변경을 보낼 수 있습니다. 클라이언트에서 requestAnimationFrame 또는 setInterval을 사용하여 빈도를 제한할 수 있습니다.
- **편집기 상태와의 일관성:** 사용자의 연결이 좋지 않은 경우 presence 하트비트가 떨어질 수 있으며 여전히 편집하는 동안 오프라인으로 나타날 수 있습니다. 마지막 하트비트 후 최대 10초까지 온라인으로 간주하는 유예 기간을 선택할 수 있습니다[[62]](https://stack.convex.dev/presence-with-convex#:~:text=A%2520common%2520way%2520to%2520detect,resources%2520your%2520app%2520will%2520consume) 깜박임을 피하기 위해. 진정으로 연결이 끊어지면 그 후 오프라인으로 표시합니다.
- **UI 과부하:** 많은 사용자가 존재하는 경우 수십 개의 커서를 표시하는 것은 압도적일 수 있습니다. 처음 5개의 커서를 표시하고 "+n 기타" 표시기를 표시하도록 제한할 수 있습니다. 데이터 모델은 모두 가질 수 있지만 UI는 단순화할 수 있습니다. MVP 테스트에서 그것에 도달하지 않을 가능성이 높지만 언급할 가치가 있습니다.
- **선택 및 편집과의 충돌:** 다른 사람의 커서를 표시하는 것이 로컬 편집을 방해하지 않도록 해야 합니다. 일반적으로 이는 장식으로 렌더링됩니다(예: ProseMirror에서 원격 커서를 장식으로 렌더링하는 플러그인을 추가할 수 있음). presence 데이터를 사용하는 이러한 플러그인을 통합할 수 있습니다. 그렇지 않으면 DOM의 대략적인 위치에 색상 캐럿 요소를 오버레이하여 수동 하이라이팅을 수행합니다. 이는 구현 과제이지만 알려진 영역입니다(ProseMirror에는 커서에 대한 협업 모듈의 예제가 있음).
- **색상 및 신원 사용:** 각 사용자가 문서 세션당 일관된 색상을 받도록 해야 합니다. userId를 색상으로 해시하거나 메모리 내 맵을 유지할 수 있습니다. 필요한 경우 presence 테이블에 색상을 저장합니다(온라인 상태인 첫 번째 사람이 색상을 선택하고 쓰고 다른 사람이 읽음). Convex presence 유틸리티 코드는 facepile에 이모지 등을 사용하는 예를 보여주지만 색상 원 또는 아바타를 수행할 것입니다.
- **Convex Auth 세션과의 간섭:** Convex가 세션 쿠키를 사용하는 경우 동일한 사용자의 여러 탭이 userId로 통합하지 않는 한 별도의 presence 항목으로 나타날 수 있습니다. 각 탭을 별도의 presence로 고려하거나 병합할 수 있습니다. 병합하면 깜박임이 발생할 수 있습니다(한 탭이 유휴 상태이지만 다른 탭이 활성 상태인 경우). 문서당 userId당 하나의 presence를 취급할 것입니다. 탭에 관계없이. 따라서 사용자가 두 탭에서 문서를 여는 경우 한 번 나타납니다(어느 탭에서든 lastActive 포함) 또는 세션별로 구별합니다. 더 간단함: 문서당 사용자당 하나 – 어느 탭에서든 활동 시 업데이트. userId를 키로 사용하여 달성됩니다(로그인하지 않은 경우 유틸리티가 클라이언트당 임의 ID를 사용했지만 인증을 사용하면 안정적).
- **데이터 정리:** 사용자가 명시적으로 로그아웃하거나 API를 호출하지 않고 문서를 닫으면 하트비트 메커니즘이 결국 오프라인으로 표시합니다(하트비트가 중지되고 lastActive가 오래되면). 브라우저 페이지 언로드 이벤트를 사용하여 서버에 알릴 수도 있습니다(그러나 신뢰할 수 없으며 실행이 보장되지 않음). 시간 초과에 의존할 것입니다.
- **권한과의 통합:** presence가 제한된 문서에 대한 정보를 유출하지 않도록 해야 합니다. 문서에 액세스할 수 있는 사용자만 presence를 구독합니다. 따라서 문서 액세스 권한이 없으면 presence를 볼 수 없습니다. 분명히. 그러나 문서가 열려 있고 액세스 권한이 없는 사람이 누가 있는지 보려고 하는 경우를 고려하십시오 – 어쨌든 문서에 대한 인증 없이 해당 presence를 쿼리할 수 없습니다. 따라서 괜찮습니다. 또 다른 각도: 문서가 제한되는 경우(사용자 제거) 열려 있는 동안 이상적으로 presence 항목을 제거하거나 숨겨야 합니다. 권한이 변경되면 쿼리가 이제 필터링할 수 있습니다. 또는 액세스 취소의 일부로 presence 항목을 제거할 수 있습니다(쫓아냄). 고급 시나리오일 수 있습니다. MVP는 동적 권한 변경을 우아하게 처리하지 않을 수 있습니다(누군가가 새로 고침하고 거부될 때까지 여전히 콘텐츠를 볼 수 있음).
- **"마지막으로 본" 기능:** lastActive 타임스탬프가 있습니다. 연락처 또는 각 문서의 공유 목록에 "Bob이 3분 전에 마지막으로 온라인 상태였습니다"를 표시할 수 있습니다. 나중에 좋을 수 있습니다. 데이터가 있습니다. 그냥 보관할 수 있습니다.
- **문서 간 presence:** 전역 상태(사용자가 어딘가에 온라인 상태)도 표시하고 싶을 수 있습니다. 모든 presence를 보거나 별도의 사용자 상태 테이블을 가짐으로써 파생할 수 있습니다(사용자의 일반 마지막으로 본 것과 같은). Convex presence 예제는 전역 온라인 상태도 다룰 가능성이 높습니다. 필요한 경우 presence 시스템을 확장하여 사용자를 전역적으로 온라인으로 표시할 수 있습니다(모든 활동에서 사용자 테이블을 업데이트할 수 있음). 우선 순위가 아니지만 가능한 확장입니다(활성 presence 항목이 있는 경우 전역적으로 사용자 이름 옆에 "녹색 점"과 같은).
- **알림 연결:** 누가 존재하는지 알면 변경 사항에 대한 알림(이메일 또는 푸시와 같은)을 보내지 않을 수 있습니다. 이미 보고 있기 때문입니다. presence 정보를 사용하는 향후 최적화일 수 있습니다.
- **Agent/AI Presence:** AI 에이전트가 참여하는 경우(예: AI "공동 과학자"가 제안하기 위해 문서에 참여할 수 있음) presence에도 반영할 수 있습니다("AI Bot이 온라인 상태입니다"). 이는 에이전트가 해당 콘텐츠에서 작업할 때 신호를 보내는 데 흥미로울 수 있습니다. 에이전트의 프로세스가 사용자처럼 presence를 업데이트하도록 하여 구현할 것입니다. 아키텍처는 에이전트에 ID가 있는 한 지원합니다.

## 확장 경로

- **정밀한 협업 커서:** 문서 변경을 통해 텍스트 커서를 추적하기 위한 강력한 솔루션을 구현합니다. 특정 버전에 매핑된 커서 위치를 브로드캐스트하는 ProseMirror 플러그인을 사용할 수 있으며 서버는 버전 참조와 함께 저장합니다. 향후 Y.js를 채택하는 경우 인식 API가 자동 CRDT 매핑으로 커서를 관리할 수 있습니다. 또한 ProseMirror의 협업 플러그인에 권장 접근 방식이 있는 경우 따르십시오(특수 마커 노드를 포함하거나 커서 조정을 위한 위치 맵을 통한 위치 매핑을 사용하는 Marijn의 예제 코드를 사용할 수 있음).
- **선택 및 주석:** 단일 커서(캐럿)에서 전체 텍스트 선택(범위)으로 확장합니다. 누군가가 텍스트 덩어리를 강조 표시한 경우 표시할 수 있습니다(편집 또는 텍스트를 논의할 때 유용). 이를 위해서는 presence 데이터에 시작 및 끝 위치를 저장해야 합니다. 단일 위치가 작동하면 자연스러운 확장입니다.
- **여러 Presence 범위:** 지금 presence는 문서당입니다. 다른 범위로도 일반화할 수 있습니다: 예: 프로젝트 또는 플랫폼 전체의 presence(온라인 사용자 목록과 같은). 인프라는 여러 방 ID를 처리할 수 있습니다(documentId가 방). "전역" 또는 공간당 다른 presence 쿼리를 구현할 수 있습니다. 전역 "지금 온라인" 목록을 표시하려는 경우 유용할 수 있습니다.
- **활동 표시:** presence를 확장하여 더 자세한 활동을 표시할 수 있습니다. 예: "Alice가 Title block을 편집 중" 또는 "Bob이 댓글 작성 중". 이는 presence 항목에 현재 활동에 대한 짧은 설명을 포함하는 확장일 수 있습니다. 클라이언트는 컨텍스트에 따라 업데이트할 수 있습니다.
- **채팅 또는 댓글과의 통합:** 앱 내 채팅 또는 댓글 시스템을 추가하는 경우 presence가 연결될 수 있습니다(누가 댓글을 입력하는지 표시하는 것과 같은). 채팅 채널에 대해 별도의 presence를 실행하거나 확장할 수 있습니다. 그러나 개념적으로 유사합니다.
- **규모 고려 사항:** 일부 시나리오에서 문서가 공개이고 수백 명이 보는 경우 presence 시스템이 긴장될 수 있습니다(많은 항목 및 업데이트). 실시간으로 모든 단일 뷰어를 추적하지 않음으로써 최적화해야 할 수 있습니다(개수만 세거나 샘플링). 또는 presence 업데이트를 분할합니다(편집자만 추적하고 수동 뷰어는 추적하지 않음, 필요한 경우). 또는 큰 N에 대해 빈도를 더 조절합니다. 이는 향후 규모 문제입니다.
- **모바일 또는 낮은 대역폭 모드:** 일부 경우 연결이 좋지 않은 사용자는 대역폭을 절약하기 위해 라이브 커서를 비활성화하고 싶을 수 있습니다. 해당 업데이트 수신을 끄는 옵션을 가질 수 있습니다(presence 쿼리에서 구독 취소하거나 서버가 최소한으로 보내도록 함). 우선 순위는 아니지만 사용자 설정으로 언급할 가치가 있습니다.
- **과거 협업 데이터 저장:** presence는 임시적이지만 협업 이벤트를 기록하고 싶을 수 있습니다(분석용, 예: 동시 편집자 수, 피크 시간). presence 변경을 분석을 위한 로그로 푸시할 수 있습니다. 또는 최소한 사용자당 활성 편집 분을 계산합니다(하트비트에서 파생될 수 있음). 이는 MVP를 넘어서지만 잠재적 메트릭입니다(참여 분석 또는 사용자 행동 연구용).
- **Workflow와의 통합 (Mastra):** 에이전트(Mastra)가 지원하는 경우 presence 정보를 사용하여 개입 시기를 결정할 수 있습니다(예: 사용자가 활발하게 입력하는 경우 제안으로 방해하지 않을 수 있음). 따라서 presence 데이터를 에이전트 로직 또는 시스템의 다른 부분에 필요에 따라 노출할 수 있습니다. 이는 presence가 모든 함수/에이전트에 쿼리를 통해 액세스할 수 있는 알려진 전역 상태임을 의미합니다.
- **UI 애니메이션 및 광택:** presence를 표시하는 방법을 더 개선할 수 있습니다. 예: 업데이트가 드문 경우 커서가 부드럽게 이동하도록 애니메이션합니다(위치 보간). 또한 status=typing일 때 이름 옆에 입력 표시기("... 입력 중"과 같은)를 표시합니다. 또는 누군가가 문서에 들어오거나 나갈 때 작은 팝업("Alice가 참여했습니다"). 이는 MVP 핵심 기능을 넘어 기능 세트를 개선할 때 고려할 UX 터치입니다.
