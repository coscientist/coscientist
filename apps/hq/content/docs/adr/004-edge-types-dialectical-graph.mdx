---
title: "ADR 4: Edge Types and Dialectical Graph (Typed Edges Over Blocks)"
---

# ADR 4: Edge Types and Dialectical Graph (Typed Edges Over Blocks)

## Context

Beyond linear documents, our knowledge system aims to represent a **knowledge graph** – a network of ideas and information. Blocks (from [ADR 1](/docs/adr/adr-001-unified-block-model)) are the nodes of this graph. We need a way to connect these nodes with various relationships.

<Callout type="info" title="Types of Connections">
  - **Structural:** A document block _contains_ a paragraph block -
  **Semantic:** Block A _supports_ Block B, or Block C is a _reference_ cited by
  Block D - **Dialectical:** Hypotheses and evidence, claims and counterclaims
</Callout>

The term "Dialectical Graph" suggests we want to model argumentative or dialogic relationships. We need **typed edges** between blocks to capture rich relationships and enable graph-like traversal rather than just parent-child hierarchies.

## Decision

<Callout type="info" title="Core Model">
  **Implement a general Edge model in the Convex database, with a `type` field
  to characterize the relationship, thereby forming a directed graph of
  blocks.**
</Callout>

Each edge is a record in an `edges` table with schema:

- `id: Id<"edges">` – primary key for the edge
- `from: Id<"blocks">` – the source block (start node)
- `to: Id<"blocks">` – the target block (end node)
- `type: string` – the relationship type (e.g., "contains", "references", "supports", "opposes", "answers")
- Metadata: `createdBy`, `createdAt`, optional annotation or weight

### Edge Directionality

Edges are directed: an edge from A to B means "A [type] B". Using types, we can express **dialectical relationships** explicitly:

| Relationship              | Edge Direction                    | Example                         |
| ------------------------- | --------------------------------- | ------------------------------- |
| Evidence supports claim   | `Y --supports--> X`               | Evidence Y supports Claim X     |
| Block contradicts another | `M --refutes--> N`                | Block M refutes Block N         |
| Document contains block   | `D --contains--> P`               | Document D contains Paragraph P |
| Question answered         | `A --answers--> Q`                | Answer A answers Question Q     |
| Dialectical counter       | `thesis --counters--> antithesis` | For debate mapping              |

### Core Edge Types for MVP

<Tabs items={["Structural", "Reference", "Dialectical", "Association"]}>
  <Tab value="Structural">
    **Structural types:** `contains` (or `parent-of`/`child-of` relationship)
    For linear order, we might also use `next` if not encoded by a list. The
    `contains` edges may include an order/position property.
  </Tab>
  <Tab value="Reference">
    **Reference type:** `references` Block A references Block B (e.g., a
    citation in text linking to a source block).
  </Tab>
  <Tab value="Dialectical">
    **Support/Oppose types:** `supports`, `refutes` Capture dialectical support
    or contradiction between claims, evidence, and arguments.
  </Tab>
  <Tab value="Association">
    **Association types:** `related`, `example-of`, `definition-of` Loose links
    and domain-specific relationships depending on needs.
  </Tab>
</Tabs>

We enumerate these in code (as constants or an enum) to avoid arbitrary strings, while keeping the model flexible to add new types later without schema changes.

### API Design

Edges will be manipulated via Convex mutations:

- `addEdge(from, to, type)` – create a link
- `removeEdge(id)` – delete a link

Queries for traversal:

- `getEdgesFrom(blockId, typeFilter?)` – get outgoing edges
- `getEdgesTo(blockId, typeFilter?)` – get incoming edges

We'll create Convex indexes on the `from` and `to` fields for efficient lookup.

## Rationale

A typed edge model provides **semantic richness** and queryability to the relationships in the knowledge base:

- **Separation of content and relationships:** Storing edges separately from blocks keeps blocks focused on content. One block can participate in many relationships freely.

- **Typed edges allow context-specific logic:** When rendering a document, follow "contains" edges. When visualizing an argument graph, look for "supports" or "refutes" edges. Knowledge graphs benefit from **rich semantic relationships** rather than generic links.

- **Evolvability:** As the system grows, we can add new type values easily – like adding new relationship types in a property graph without breaking existing data.

- **Query and analysis:** With edges in a table, we can perform graph-like queries within Convex. For example, find all evidence supporting a claim: `to = claimId AND type = "supports"`.

- **Alignment with knowledge graph practices:** Storing nodes and edges in tables is a common approach without needing a specialized graph database. Each edge is essentially a triple (subject, predicate, object).

- **Dialectical reasoning:** Typed edges enable implementing logic such as "if evidence block E supports claim C, and claim C supports theory T, then E indirectly supports T" – these inferences rely on understanding edge types.

## Alternatives Considered

<Tabs
  items={[
    "Untyped Links",
    "Edge in Blocks",
    "Graph Database",
    "User-Defined Types",
  ]}
>
  <Tab value="Untyped Links">
    **Untyped (or Implicit) Links:** Blocks store references to other blocks
    without specifying type. **Rejected** because it lacks clarity – we want the
    system to _know_ what a link means. Typed edges make knowledge
    machine-interpretable.
  </Tab>
  <Tab value="Edge in Blocks">
    **Edge Properties embedded in Blocks:** Each block contains fields for
    relationships (e.g., `citations: [blockId]`, `supports: [blockId]`).
    **Rejected** because each new relation type adds a field, and many-to-many
    relations are harder to normalize. A separate edge entity avoids these
    problems.
  </Tab>
  <Tab value="Graph Database">
    **Graph Database or External Store:** Use a dedicated graph engine like
    Neo4j. **Rejected** for MVP – overkill. Convex handles rows fine. Can
    reconsider if queries become complex multi-hop traversals.
  </Tab>
  <Tab value="User-Defined Types">
    **User-defined edge types** (folksonomy-style) vs fixed set. MVP uses a
    fixed enumerated set for consistency. User-defined types could be powerful
    but might lead to chaos. Can revisit for advanced users.
  </Tab>
</Tabs>

## Implications

- **Integrity Constraints:** Edge endpoints (from/to block IDs) must actually exist. When a block is deleted, all edges involving it must also be deleted. Convex doesn't auto-cascade, so we handle it in code.

- **Preventing Duplicates and Cycles:** Enforce uniqueness of `(from, to, type)`. Cycles are possible with semantic links but "contains" hierarchy should be acyclic. We'll be cautious in traversals to avoid unbounded recursion.

- **Graph Query Complexity:** Single query can fetch direct edges easily, but multi-hop traversal might require multiple queries or client-side logic. For MVP, 1-hop or 2-hop queries suffice.

- **Permission Model Interaction:** Edges inherit visibility rules from blocks. If you can't see Block B, you shouldn't see edge "A supports B" either. Creating an edge requires permission to see both blocks.

- **UI Complexity:** For MVP, keep it simple: list supporting evidence under a claim, show backlinks on references. Full graph visualization can come later.

<Callout type="warn" title="Batch Operations">
  Some user actions might create multiple edges at once (e.g., importing
  markdown with footnotes). Wrap in a Convex function that either creates all
  required blocks and edges or aborts on error.
</Callout>

## Expansion Path

<Cards>
  <Card
    title="Additional Edge Types / Ontologies"
    href="/docs/adr/adr-001-unified-block-model"
  >
    Introduce domain-specific types like "extends", "confirms", "disputes" for
    scientific context. The model easily allows new types.
  </Card>
  <Card
    title="Weighted / Annotated Edges"
    href="/docs/adr/adr-001-unified-block-model"
  >
    Add weight/score fields for "strongly supports" vs "weakly supports", or
    justification text explaining _why_ A supports B.
  </Card>
  <Card title="Graph Visualization" href="/docs/adr/adr-007-presence-cursors">
    Implement visual graph view with depth-limited DFS/BFS to gather subgraph
    data. Could integrate with graph algorithms (shortest path, centrality).
  </Card>
  <Card
    title="AI-Driven Edge Creation"
    href="/docs/adr/adr-008-platform-boundaries-expansion"
  >
    AI agents automatically suggest or create edges (e.g., "This block
    contradicts Block Z"). Mark AI-suggested edges for user verification.
  </Card>
</Cards>

<Callout type="idea" title="Federation & Cross-Instance Edges">
In future federated knowledge networks, we might allow edges connecting blocks from different instances. This would require global ID schemes (URIs) and fields like `toExternal: {instance: URL, id: externalId}`.
</Callout>
