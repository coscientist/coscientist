---
title: "ADR 1: 통합 Block 모델 (지식의 원자 단위)"
---

# ADR 1: 통합 Block 모델 (지식의 원자 단위)

Coscientist는 사용자가 만든 지식 콘텐츠(텍스트, 미디어, 참조 자료 등)를 아주 작은 단위로 관리한다. 기존 위키나 문서 시스템은 "페이지" 전체를 최소 단위로 다루지만, 우리는 Notion 같은 block 기반 에디터에서 영감을 받았다. 문단 하나, 이미지 하나도 독립된 단위다. 이 **block 기반 접근법** 덕분에 작은 콘텐츠 조각들 사이에 풍부한 관계를 맺는 지식 그래프를 구축할 수 있다.

## 결정 사항

<Callout type="info" title="핵심 원칙">
  **모든 콘텐츠는 "Block" 엔티티로 표현한다.** 각 Block은 고유 ID와 타입
  메타데이터를 갖춘 일급 지식 원자다.
</Callout>

텍스트 문단, 제목, 이미지, 파일, 복합 문서까지 전부 Block으로 저장한다. Block끼리 서로 참조하거나 계층 구조로 묶을 수 있다(예: Edge나 부모 포인터로 자식 Block을 포함하는 문서 Block). 모든 Block은 Convex의 단일 테이블(`blocks`)에 다음 스키마로 저장한다:

- `id: Id<"blocks">` – 기본 키 (Convex 객체 ID)
- `type: string` – Block 타입 (예: "text", "image", "doc" 등)
- `content: any` – 콘텐츠 페이로드. 텍스트 Block이면 ProseMirror JSON 노드나 일반 텍스트, 이미지/파일 Block이면 파일 저장소 ID 참조
- 메타데이터 필드: `createdBy`, `createdAt`, `updatedAt` 등
- (선택) 구조 필드: 계층 구조 직접 저장 시 `parentId`나 순서 인덱스. 단, 계층적/의미론적 관계는 주로 별도 Edge 모델로 관리 ([ADR 4](/docs/adr/adr-004-edge-types-dialectical-graph) 참조)

**사용자가 만들거나 수정하는 모든 것이 Block**이라는 뜻이다. 덕분에 API와 데이터 처리가 일관된다. "문서"는 그냥 자식 Block(문단, 이미지 등)을 가진 "doc" 타입 Block일 뿐이다. 자식들은 "contains" 타입 Edge([ADR 4](/docs/adr/adr-004-edge-types-dialectical-graph))나 doc Block content 안의 자식 ID 배열로 연결한다. MVP에서는 문서를 순서 있는 Block 리스트로 구현하겠지만, 개념적으로는 여전히 "Block 안에 Block"이다.

## 왜 이렇게 결정했나

통합 모델은 일관성과 유연성을 보장한다. 모든 콘텐츠를 동일하게 취급하니까 버전 관리, 권한, 링크 같은 기능을 Block 단위로 구현해서 어떤 콘텐츠 타입에든 적용할 수 있다. 협업 엔진도 단순해진다 – 문단 하나를 편집하든 페이지 전체를 편집하든, 결국 Block 하나 또는 여러 개를 편집하는 것이다.

게다가 지식 그래프 구축이 쉬워진다: Block이 그래프의 노드고, 타입이 지정된 Edge로 연결해서 의미론적 관계를 표현한다([ADR 4](/docs/adr/adr-004-edge-types-dialectical-graph)). 현대 지식 그래프 원칙 – **노드는 엔티티, Edge는 타입 있는 관계** – 과 일치한다. 모든 콘텐츠 조각을 노드(Block)로 만들면 풍부한 의미론적 연결이 가능하다 (예: "Claim" Block을 "supports" Edge로 "Evidence" Block에 연결).

<Callout type="idea" title="핵심 통찰">
  "페이지 vs 문단" 같은 구분을 하드코딩하지 않는다. 페이지도 그냥 자식이 있는
  Block이다. 백엔드가 단순해진다: 모든 콘텐츠에 Convex 테이블 하나, API 하나.
</Callout>

향후 확장도 쉽다: 코드 셀, 수식 Block 같은 새 콘텐츠 타입을 기본 데이터 모델 수정 없이 새 Block 타입으로 추가하면 된다.

## 검토한 대안들

<Tabs
  items={[
    "Page/Document 모델",
    "타입별 테이블 분리",
    "JSON Blob 내장",
    "Graph DB",
  ]}
>
  <Tab value="Page/Document 모델">
    **Page/Document 모델:** 문서나 기사 전체를 하나의 레코드(큰 텍스트 필드)로
    저장. 기본 편집에는 단순하지만 세분성이 없다 – 개별 아이디어나 섹션을 따로
    링크하거나 버전 관리할 수 없다. 하위 섹션 협업 편집도 복잡해진다.
  </Tab>
  <Tab value="타입별 테이블 분리">
    **타입별 테이블 분리:** `documents`, `paragraphs`, `images` 테이블을 따로
    둔다. 타입마다 로직이 중복되고 복잡도가 올라간다. `type` 필드 하나 있는 단일
    테이블이 더 단순하고 일관된다.
  </Tab>
  <Tab value="JSON Blob 내장">
    **JSON Blob에 계층 구조 내장:** 문서 전체 콘텐츠(내부 Block 포함)를 하나의
    JSON으로 저장 (ProseMirror 내부 방식). 조회는 단순해지지만 콘텐츠 일부를
    재사용하거나 참조하기 어렵다. Block을 개별 주소 지정 가능하게 만들어서 다른
    문서의 특정 Block에 링크할 수 있어야 한다.
  </Tab>
  <Tab value="Graph DB">
    **Graph Database나 RDF Triple Store:** 모든 지식에 전용 Graph DB나 RDF 모델
    사용. 노드/Edge를 우아하게 다룰 수 있지만 MVP에 인프라와 복잡도가 추가된다.
    대신 Convex에서 그래프 모델을 구현한다(Edge를 테이블에 저장, [ADR
    4](/docs/adr/adr-004-edge-types-dialectical-graph)). 별도 DB 없이 SQL의
    노드+Edge 테이블 방식과 개념적으로 동일하다.
  </Tab>
</Tabs>

## 영향

- **원자적 재사용:** 모든 게 Block이니까 여러 맥락에서 Block을 재사용하거나 삽입(transclusion)할 수 있다. 예를 들어 같은 "실험 결과" Block을 콘텐츠 복제 없이 Edge로 두 문서에서 참조 가능. (전체 transclusion UI는 MVP 이후지만 모델은 허용한다.)

- **성능 고려:** 문서 전체 로드에 여러 Block(컨테이너 + 자식들)을 가져와야 한다. Convex는 JOIN을 지원하지 않지만 Edge 인덱싱이나 자식 ID 저장으로 해결한다. Block을 ID로 일괄 조회할 것이다. 문서 편집 시 큰 업데이트 하나 대신 작은 Block 업데이트 여럿이 발생하지만 Convex 실시간 엔진이 잦은 작은 변경을 잘 처리한다.

- **일관성과 트랜잭션:** 여러 Block에 걸친 변경(예: 문단을 두 Block으로 분할)은 Convex 함수에서 신중하게 처리해야 데이터 일관성이 유지된다. Convex는 트랜잭션(단일 함수 호출)에서 순차 작업을 허용하므로 새 Block 삽입과 Edge/부모 참조 업데이트를 원자적으로 수행한다.

- **기능 구현 단순화:** Block별 버전 관리([ADR 2](/docs/adr/adr-002-versioning-strategy))와 Block별 권한([ADR 6](/docs/adr/adr-006-permissions-embargo-model)) 같은 기능이 간단해진다 – "Block"이 변경과 접근 제어의 단위니까. 다만 페이지를 보는 사용자는 구성 Block 전부에 권한이 필요하다 – 쿼리나 resolver에서 권한을 필터링/집계해야 한다.

- **통일 API:** 모든 콘텐츠 타입에 동작하는 범용 API(`getBlock(id)`, `updateBlock(id, content)`)를 구축할 수 있다. 코드 경로가 적으면 버그도 적다. 일부 타입(이미지, 파일)은 파일 저장소([ADR 5](/docs/adr/adr-005-file-storage-access-control))로 다르게 처리하지만 메타데이터와 ID 구조는 텍스트 Block과 공유한다.

## 확장 경로

<Cards>
  <Card
    title="새 Block 타입 / 온톨로지"
    href="/docs/adr/adr-004-edge-types-dialectical-graph"
  >
    시스템 확장 시 새 Block 타입(코드 Block, 차트 등)을 도입한다. 타입 상수
    추가하고 콘텐츠 구조만 정의하면 된다.
  </Card>
  <Card
    title="Block 연합 (Federation)"
    href="/docs/adr/adr-003-collaboration-protocol"
  >
    여러 인스턴스가 지식을 공유하는 연합 아키텍처에 Block 모델이 적합하다. 전역
    식별자로 인스턴스 간 참조 가능.
  </Card>
  <Card
    title="Block 캐싱 & Local-First"
    href="/docs/adr/adr-003-collaboration-protocol"
  >
    Block이 작아서 클라이언트가 오프라인용으로 캐싱 후 온라인 시 Convex에
    동기화할 수 있다.
  </Card>
  <Card
    title="의미론적 강화"
    href="/docs/adr/adr-004-edge-types-dialectical-graph"
  >
    Block에 의미론적 데이터(태그: "hypothesis", "evidence" 등)를 붙여서 AI
    에이전트가 처리할 수 있게 한다.
  </Card>
</Cards>

<Callout type="warn" title="향후 고려 사항">
  Block 수가 늘어나면 인덱싱이나 파티셔닝을 도입할 수 있다. 예를 들어 프로젝트나
  스페이스별로 Block을 파티션해서 쿼리 부하를 관리한다. Convex는 테이블 필드에
  보조 인덱스 생성을 지원하므로 문서 Block을 효율적으로 조회하려면 `parentId`
  등에 인덱스를 추가할 것이다.
</Callout>
