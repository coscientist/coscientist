---
title: "ADR 8: Platform Boundaries and Expansion Plan"
description: "Architecture decisions for Convex, Vercel, Workflow, and Mastra integration with clear platform boundaries and future expansion paths"
---

# ADR 8: Platform Boundaries and Expansion Plan

## Context

The MVP system is built with a **Next.js frontend on Vercel** and a **Convex backend**. Clear delineation of responsibilities is essential to avoid confusion and create a clean, growable architecture.

While MVP excludes federated multi-server setups and advanced AI agent features, the architecture must be conceived with a path to those capabilities.

<Callout type="info" title="Scope of This ADR">
  This ADR covers: - Frontend/backend boundary structure - Convex scheduling and
  workflow integration - AI agent system (Mastra) introduction planning -
  Federated and multi-component architecture roadmap
</Callout>

## Decision

**Maintain clear client-server separation with Next.js (Vercel) as the frontend/UI layer and Convex as the authoritative backend for data and realtime collaboration, leveraging Convex's workflow and scheduling for background tasks.**

The system starts as a single Convex deployment and single Next.js app, with defined extension paths.

### Platform Responsibilities

<Tabs items={['Next.js (Vercel)', 'Convex Backend', 'Workflow & Scheduling']}>
<Tab value="Next.js (Vercel)">
**Frontend/UI Layer:**
- Renders application UI and handles routing
- Uses Convex React client (`ConvexProvider` and auto-generated hooks)
- All data mutations and fetches go through Convex APIs
- No significant client-side state beyond transient UI state
- SSR for initial loads when needed (Convex supports Node context)
- Vercel deployment for fast global delivery of static assets

<Callout type="warn" title="Security Boundary">
No secret logic in Next.js - all sensitive operations live in Convex functions. Vercel's edge provides additional protections (bot protection, etc.) if needed.
</Callout>
</Tab>

<Tab value="Convex Backend">
**Source of Truth:**
- Houses the database (blocks, edges, steps, presence, etc.)
- All business logic in Convex functions (queries, mutations, actions, crons)
- Realtime collaboration via ProseMirror OT functions and presence subscriptions
- Single database centralizes consistency and simplifies sync

**Convex Components:**

- Files Control
- ProseMirror Sync
- Other modular backend pieces that accelerate development
  </Tab>

<Tab value="Workflow & Scheduling">
**Background Tasks:**
- **Cron jobs**: Periodic tasks (cleanup expired files, presence trim)
- **Actions**: One-off tasks that don't re-run on data change
- **Workflow component**: Durable functions that survive restarts and handle retries

<Callout type="idea" title="Workflow Use Cases">
- Email notifications
- Embargo lift scheduling
- AI summarization after block edits
- Multi-step agent reasoning chains
</Callout>
</Tab>
</Tabs>

### Authentication

Using Convex's built-in Auth with Google/GitHub OAuth integration. The Next frontend triggers login flows and obtains ID tokens that Convex uses for authentication - no separate auth server needed.

### Mastra (AI & Agents) - Future Integration

<Callout type="info" title="What is Mastra?">
  Mastra is a TypeScript AI framework with multi-agent workflow capabilities,
  promoted by Vercel for building AI-powered features on modern JS stacks.
</Callout>

**Integration Strategy:**

1. **Modular AI Logic**: Separate service or serverless function for agent reasoning
2. **Communication**: Agents communicate with Convex via API (HTTP endpoints or function calls)
3. **No Human-Only Assumption**: Architecture accommodates both human and agent data access
4. **Deployment Options**:
   - Run Mastra agent within Convex action
   - Use Vercel Edge Functions or AWS Lambda for async agents
   - Orchestrate via Vercel AI SDK

### Federation - Future Expansion

<Callout type="warn" title="Not in MVP">
  MVP is a single Convex deployment. Federation is a future consideration.
</Callout>

**Future Path:**

- Connect multiple backends via API layer or message passing
- Block model can be extended with `origin` or `globalId` fields
- Potential federation server for routing requests by content location
- ActivityPub adoption for public content federation
- Globally unique IDs (UUIDs) enable future data merging

### DevOps and Deployment

| Layer         | Platform                  | Notes                         |
| ------------- | ------------------------- | ----------------------------- |
| Frontend      | Vercel                    | Domain, CDN, static assets    |
| Backend       | Convex Cloud              | Functions, database, realtime |
| Communication | HTTPS + WebSockets        | SSL secured, auth required    |
| Logging       | Convex Dashboard + Vercel | Sentry optional for frontend  |

### Workflow Examples in MVP

| Use Case               | Implementation                         |
| ---------------------- | -------------------------------------- |
| Periodic cleanup       | Cron jobs                              |
| AI summarization       | Convex action with retries             |
| Multi-step agent tasks | Durable functions (workflow component) |
| File cleanup           | Scheduled actions                      |

## Rationale

<Cards>
<Card title="Separation of Concerns">
Next.js handles presentation and user interaction. Convex handles data consistency and business rules. UI changes don't risk backend logic and vice versa.
</Card>

<Card title="Specialized Platforms">
  Vercel optimized for frontend delivery (CDN, asset optimization). Convex
  optimized for backend state with real-time sync. Each does what it does best.
</Card>

<Card title="Scale as You Grow">
  Convex scales horizontally behind the scenes. Vercel auto-scales serverless
  functions and static content. New features integrate via Convex components or
  Vercel integrations.
</Card>

<Card title="Expansion Readiness">
AI/Agent integration via modular interfaces. Federation possible with globally unique IDs. No shortcuts that would hinder future growth.
</Card>
</Cards>

### Why Monolithic Backend for MVP

- **Reduces early complexity** - no microservice coordination overhead
- **Convex ecosystem expansion** - vector search, AI memory components coming
- **Spin out only if necessary** - e.g., external vector DB like Pinecone for semantic search

### Security Boundary

All sensitive operations on Convex side. Next.js holds only:

- Convex deployment URL
- Public auth configuration

All secret keys (third-party APIs, Mastra integration) reside in Convex or Vercel serverless function environment variables.

### Consistency Through Single Backend

Running everything through Convex ensures data consistency - effectively a single database with all constraints and logic in one place.

## Alternatives Considered

<Tabs items={['Single Server', 'Fully Serverless', 'AI at MVP', 'Ignore Expansion']}>
<Tab value="Single Server">
**Node.js server with Postgres/Mongo + ShareDB/Yjs for collab**

Rejected because:

- Requires building real-time sync and OT logic from scratch
- Loses Convex's elegant reactivity
- WebSockets on Vercel are non-trivial (separate server needed)
  </Tab>

<Tab value="Fully Serverless">
**Client + edge functions + Firebase + CRDT library**

Rejected because:

- Patchwork harder to maintain
- Tight integration difficult to achieve
- CRDT state merging with security is challenging
  </Tab>

<Tab value="AI at MVP">
**Include AI agent from day one**

Rejected because:

- Overcomplicates initial architecture
- Requires vector DB and LLM service integration upfront
- Better to design for it, implement later
  </Tab>

<Tab value="Ignore Expansion">
**Build MVP ignoring federation/multi-agent future**

Rejected because:

- Shortcuts would hinder later expansion
- Using globally unique IDs now eases future data merging
- Code structured for easy factoring (AI functions as separate module)
    </Tab>
</Tabs>

**Monorepo Decision**: Frontend and backend in same repository for shared types and dev convenience. Convex functions live alongside Next app with Convex dev server watching file changes.

## Implications

### Trade-offs Accepted

| Concern                     | Mitigation                                                                          |
| --------------------------- | ----------------------------------------------------------------------------------- |
| **Vendor Lock-in**          | Code structured for potential porting. Convex has open-source core.                 |
| **Costs**                   | Monitor usage. Clear boundaries allow swapping components if needed.                |
| **Single Point of Failure** | High availability from both platforms. Read-only cache possible for public content. |

### Development Workflow

- Developers run both Next and Convex dev servers
- Convex provides background dev server with file watching
- Environment variables connect Next to Convex
- Shared TypeScript types via Convex codegen

### Edge Considerations

- Vercel runs global CDN nodes for static assets
- Convex defaults to single region (acceptable latency trade-off)
- WebSockets maintain persistent connections
- Future: multi-region Convex if needed

### Stateful vs Stateless Boundaries

| Layer       | State Model                | Implication                  |
| ----------- | -------------------------- | ---------------------------- |
| Convex      | Stateful (DB)              | All persistent state here    |
| Next/Vercel | Stateless between requests | No server memory assumptions |
| Browser     | Transient UI state         | Ephemeral per-client state   |

<Callout type="error" title="Critical Rule">
  Never store persistent state in Next.js server memory - it's ephemeral and
  multi-instance. All persistent state must go to Convex.
</Callout>

### Continuous Deployment

- Deploy Convex first (ensure functions updated)
- Then deploy frontend that calls them
- Careful coordination for schema migrations

### Documentation for Developers

Key rules to document:

- "All data mutations go in Convex functions"
- "Do not mutate application state in Next.js side"
- "Next.js should only call Convex or render UI"
- "Use Convex cron or action for background jobs, not separate schedulers"

## Expansion Path

<Callout type="info" title="Cross-Reference">
  See integration sections in ADRs 1-7 for feature-specific expansions. This
  section covers architectural expansions.
</Callout>

<Cards>
<Card title="Federation" href="#federation">
Block model as federation unit. Global identifiers (instance + ID). Smart proxy or ActivityPub-compatible server. CRDT/consensus for cross-instance edits.
</Card>

<Card title="AI and Agents (Mastra)" href="#ai-agents">
  Agents read/contribute to knowledge base. Agent memory in Convex. Background
  processes via workflows. Treat agents as special users with API access.
</Card>

<Card title="Vector Search" href="#vector-search">
  Convex vector search or external service (Pinecone). Query → embedding →
  vector DB → block IDs → Convex retrieval.
</Card>

<Card title="Public Publishing" href="#public-publishing">
  Export public blocks to static site. Enable SEO. Serve without hitting Convex.
  Cross-domain linking in federated scenario.
</Card>

<Card title="Offline & Local-First" href="#offline">
  CRDT approach (Yjs) or Convex local-first capabilities. Client-side database
  syncing when online. Significant architecture shift.
</Card>

<Card title="Workflow Automation" href="#automation">
  User-defined rules ("when claim added, find evidence"). Trigger system on
  table changes. Mastra or Convex workflow engine.
</Card>

<Card title="Multi-Tenancy" href="#multi-tenancy">
Partition data with `tenantId`/`workspaceId`. Tenant-scoped permissions. Separate deployments per tenant if needed for isolation.
</Card>
</Cards>

### Mastra Introduction Details

When bringing in Mastra:

1. Allocate separate Convex functions for agent interface
2. Or run Mastra within Convex action (depending on load)
3. Store agent memory (conversation logs, knowledge) in Convex
4. Agent logic runs in Convex actions or Vercel functions with AI SDK

### External Integration APIs

Convex provides HTTP API for external integration:

- Design functions with clean interfaces for external exposure
- Use API keys or service accounts for authentication
- Enable plugin ecosystem and federation scenarios
