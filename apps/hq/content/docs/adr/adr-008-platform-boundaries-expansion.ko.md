---
title: "ADR 8: 플랫폼 경계 및 확장 계획 (Convex, Vercel, Workflow, Mastra)"
---

# ADR 8: 플랫폼 경계 및 확장 계획 (Convex, Vercel, Workflow, Mastra)

## 컨텍스트

MVP 시스템은 **Vercel의 Next.js 프론트엔드**와 **Convex 백엔드**로 구축되었습니다. 혼란을 피하고 성장할 수 있는 깨끗한 아키텍처를 만들기 위해 각 부분이 담당하는 것을 명확히 하는 것이 중요합니다. 또한 MVP에는 연합 다중 서버 설정이나 고급 AI 에이전트 기능이 포함되지 않지만 아키텍처는 이러한 기능에 대한 경로를 염두에 두고 구상되어야 합니다. 이 ADR은 프론트엔드와 백엔드 간의 경계를 구조화하는 방법, 스케줄링/워크플로와 같은 Convex의 특수 기능을 통합하는 방법, AI 에이전트 시스템(Mastra)의 최종 도입 및 가능한 연합 또는 다중 컴포넌트 아키텍처를 계획하는 방법을 다룹니다.

## 결정

**Next.js(Vercel)를 프론트엔드/UI 레이어로, Convex를 데이터 및 실시간 협업을 위한 권위 있는 백엔드로 명확한 클라이언트-서버 분리를 유지하고, 백그라운드 작업을 위해 Convex의 워크플로 및 스케줄링을 활용합니다.** 시스템은 처음에는 단일 Convex 배포와 단일 Next.js 앱이지만 그 이상으로 확장하는 방법을 설명합니다. 주요 사항:

- **Next.js (Vercel) 프론트엔드:**
  - 애플리케이션 UI를 렌더링하고 라우팅을 처리합니다(페이지용 공개 경로, 로그인을 보장하기 위해 Next 미들웨어를 통해 보호될 수 있음).
  - Convex React 클라이언트(ConvexProvider 및 자동 생성된 후크)를 사용하여 백엔드 함수를 호출하고 쿼리를 구독합니다. 모든 데이터 변경 및 가져오기는 Convex API를 통해 이루어집니다 – Convex에도 없는 중요한 클라이언트 측 상태를 유지하지 않습니다. 일시적인 UI 상태는 제외합니다.
  - Next.js는 초기 로드를 위해 서버 측 렌더링(SSR)을 수행할 수도 있지만 대부분의 데이터가 인증 뒤에 있고 동적이므로 로그인 후 클라이언트 측 렌더링에 의존할 수 있습니다. SSR이 필요한 경우(공개 페이지 또는 SEO용) 예를 들어 getServerSideProps에서 Convex를 호출하여 일부 데이터를 가져올 수 있습니다(Convex는 Node 컨텍스트를 지원).
  - 정적 자산 및 엣지 네트워크의 빠른 전역 전달을 위해 Vercel의 배포를 사용합니다. 그러나 동적 데이터는 Convex의 엔드포인트에서 제공됩니다(기본적으로 단일 지역 엔드포인트이지만 Convex에는 쿼리의 엣지 캐싱이 있을 수 있음).
  - 보안: Next에 비밀 로직이 없도록 보장합니다 – 모두 Convex 함수에 있습니다. Vercel의 엣지는 추가 보호에 사용할 수 있습니다(필요한 경우 Vercel의 내장 기능을 통한 봇 보호 등).
- **Convex 백엔드:**
  - 데이터베이스(blocks, edges, steps, presence 등) 및 Convex 함수(쿼리, 변경, 작업, cron)의 모든 비즈니스 로직을 보유합니다.
  - Convex를 애플리케이션 상태의 **진실의 원천**으로 취급합니다. 다른 데이터베이스는 사용되지 않습니다. 이는 일관성을 중앙 집중화하고 동기화를 단순화합니다(Convex는 반응성을 통해 클라이언트를 동기화 상태로 유지).
  - 이전 ADR에서 설명한 대로 실시간 협업은 Convex에서 구현됩니다(예: ProseMirror OT 함수, presence 구독). Convex의 **오픈 소스 백엔드 플랫폼**은 앱을 실시간으로 동기화 상태로 유지합니다[[72]](https://vercel.com/docs/integrations#:~:text=Convex), 이것이 선택한 이유 중 하나입니다.
  - 개발을 가속화하기 위해 Convex **컴포넌트**(Files Control, Prosemirror Sync 등)를 활용합니다. 이는 코드와 통합되는 모듈식 백엔드 조각입니다.
- **Workflow & 스케줄링:** Convex는 백그라운드 작업을 위한 "Workflow" 시스템과 cron 작업을 제공합니다. 주기적 작업(만료된 파일 정리, presence 정리 등, 이전 ADR에서 언급)에 cron을 사용합니다. 더 복잡하거나 다단계 백그라운드 작업의 경우 Convex 작업을 사용합니다(데이터 변경 시 자동으로 다시 실행되지 않고 실행되며 일회성 작업에 적합). 장기 실행되는 것이 필요한 경우(많은 초가 걸릴 수 있는 AI 호출과 같은) Convex 비동기 작업으로 오프로드하거나 외부 서비스로 오프로드할 수 있지만 가능한 경우 Convex의 워크플로 컴포넌트를 통해 조율됩니다. "Workflow 컴포넌트"에 대한 언급은 Convex에 재시작에서 살아남고 재시도를 처리할 수 있는 내구성 있는 함수가 있음을 암시합니다. 이메일 알림 보내기 또는 embargo 해제 예약과 같은 작업의 안정성을 위해 이를 사용할 것입니다.
- **Auth:** Convex의 내장 Auth(Google/GitHub OAuth 등과 통합할 수 있음)를 사용할 가능성이 높습니다. Next 프론트엔드는 로그인 흐름을 트리거하고 ID 토큰을 얻으며 Convex는 이를 사용하여 인증합니다. 별도의 인증 서버가 없습니다. 이는 클라이언트와 Convex가 사용자 신원 컨텍스트를 원활하게 공유함을 의미합니다.
- **Mastra (AI & Agents) – 향후 통합:**
  - Mastra는 Vercel이 홍보하는 TypeScript AI 프레임워크(다중 에이전트 워크플로 포함)입니다[[73]](https://vercel.com/docs/ai-gateway/framework-integrations/mastra#:~:text=Mastra%2520is%2520a%2520framework%2520for,model%2520management%2520and%2520routing%2520capabilities). 향후 Mastra를 사용하여 지식 베이스와 상호 작용할 수 있는 에이전트를 구축하여 AI "공동 과학자" 기능을 통합할 계획입니다.
  - 계획은 AI 로직을 **모듈식**으로 유지하는 것입니다. 예를 들어, 에이전트 추론을 처리하는 별도의 서비스 또는 서버리스 함수(Vercel에서 AI SDK를 사용할 수도 있음)를 만들 수 있습니다. 에이전트는 API를 통해 Convex와 통신합니다(Convex 함수를 호출하거나 Convex HTTP 엔드포인트를 통해).
  - 인간만 데이터에 액세스한다는 가정을 굽지 않음으로써 아키텍처가 이를 수용할 수 있도록 보장합니다. 외부 호출에 의해 트리거될 수 있는 Convex 함수가 있을 수 있습니다(Convex는 HTTP 엔드포인트를 지원하거나 API를 통해 함수 호출). 따라서 에이전트는 convex.actions.queryKnowledgeGraph를 호출하여 정보를 얻은 다음 무언가를 결정한 다음 발견 사항이 있는 block 또는 edge를 추가하기 위해 변경을 호출할 수 있습니다.
  - Mastra가 프로세스 내에 통합되는 경우: Mastra는 TypeScript일 뿐이고 Convex 작업이 외부 API를 호출할 수 있으므로 Convex 작업 내에서 Mastra 에이전트를 실행할 수 있습니다. 그러나 Mastra에는 더 무거운 요구 사항이나 장기 실행 프로세스가 있을 수 있습니다. 또 다른 접근 방식: Vercel Edge Functions 또는 AWS Lambda를 사용하여 에이전트를 비동기적으로 실행하고 Convex로 다시 호출하도록 합니다. 세부 사항은 성능에 따라 달라집니다. 지금은 "Mastra는 현대 JS 스택에서 AI 기반 기능을 구축하기 위한 프레임워크"[[73]](https://vercel.com/docs/ai-gateway/framework-integrations/mastra#:~:text=Mastra%2520is%2520a%2520framework%2520for,model%2520management%2520and%2520routing%2520capabilities)라고 언급하며, 이는 Next/Convex 스택과 잘 맞는다는 것을 시사합니다. Vercel AI SDK를 통해 조율하고 플랫폼 경계가 이를 허용하도록 보장할 것입니다(다른 클라이언트 또는 마이크로서비스로 취급할 수 있음).
- **MVP에서 연합 아키텍처 없음, 그러나 향후 확장:**
  - MVP는 하나의 Convex 배포(하나의 데이터베이스, 하나의 백엔드)입니다. 향후 여러 백엔드가 필요한 경우(다중 테넌시 또는 확장 또는 커뮤니티 간 연합을 위해) API 레이어 또는 메시지 전달을 통해 연결할 계획입니다. 예를 들어, 일부 block이 다른 Convex 배포에서 호스팅되고 원격으로 참조되는 시나리오를 상상할 수 있습니다. MVP에는 없지만 block 모델(ADR 1)은 콘텐츠 위치 또는 전역 ID에 대한 필드로 확장되어 외부 콘텐츠에 대한 참조를 활성화할 수 있습니다.
  - 필요한 경우 콘텐츠 위치 또는 사용자 도메인에 따라 요청을 라우팅하기 위해 여러 Convex 백엔드 위에 있는 **연합 서버**를 개발할 수 있습니다. 또는 다른 인스턴스가 서로의 공개 콘텐츠를 팔로우하도록 하는 ActivityPub과 같은 개방형 표준을 채택합니다. 백엔드가 특정 이벤트를 내보내고 다른 것에서 소비하는 확장이 될 것입니다. 결정은 MVP를 간단하게 유지하는 것입니다(연합 없음). 그러나 데이터 모델을 충분히 유연하게 유지할 것입니다(단일 인스턴스를 가정하지 않는 전역적으로 고유한 ID와 같은, 자동 증가에 연결되지 않은 UUID 또는 무언가를 사용할 수 있음).
- **DevOps 및 배포:**
  - Vercel과 Convex는 모두 호스팅 서비스입니다. 배포는 별도입니다: Next.js를 Vercel에 배포하고(도메인 제공) Convex 함수를 Convex 클라우드에 배포합니다. 인터넷을 통해 통신합니다. SSL을 사용하고 Convex의 인증 요구 사항으로 보호할 것입니다. 또한 Convex 함수는 서버리스와 같으므로 Convex의 확장을 신뢰합니다.
  - 로깅/모니터링: 백엔드 로그를 위해 Convex의 대시보드에 의존하고 프론트엔드 로그를 위해 Vercel에 의존합니다. 필요한 경우 프론트엔드를 위해 Sentry 또는 유사한 것을 통합할 수 있습니다. Convex에도 오류 추적을 위한 솔루션이 있을 것입니다.
- **엣지 고려 사항:** Vercel은 정적 자산을 위해 전역적으로 CDN 노드를 실행합니다. Convex는 기본적으로 한 지역에서 실행될 수 있습니다(대부분의 사용자가 있는 곳, 예: 미국을 선택할 수 있음). 전역 사용자의 경우 데이터 호출에 지연이 발생할 수 있습니다. 그러나 호출당 볼륨이 높지 않으며 웹소켓은 영구 연결을 유지합니다. 향후 필요한 경우 Convex가 다중 지역을 허용하거나 지역당 별도의 Convex 인스턴스를 배포하고 연결할 수 있습니다(사소하지 않음). 단순성을 위해 일부 지연 트레이드오프를 수용합니다. 허용 가능한 지역을 선택하도록 보장할 수 있습니다(좋은 절충안인 미국 동부일 수 있음).
- **MVP에서 Workflow (Convex) 사용 예:**
  - 설명된 대로 Cron 작업(정리 작업).
  - "사용자가 block을 편집한 후 백그라운드에서 AI 요약기를 실행"과 같은 프로세스가 있는 경우 Convex의 내구성 있는 함수를 사용할 수 있습니다. 재시도와 함께 Convex 작업을 통해 예약할 수 있습니다.
  - Convex 문서의 "Workflow 컴포넌트"에 대한 언급은 다단계 작업을 위한 오케스트레이터를 제안합니다[[74]](https://stack.convex.dev/presence-with-convex#:~:text=AI%2520Agents%2520with%2520Built). 예를 들어, 지식 검색, 분석, 결과 작성 시퀀스를 수행해야 하는 에이전트를 통합하는 경우 재시작에서 살아남기 위해 내구성 있는 함수에서 체인할 수 있습니다.
  - 확장에서 필요에 따라 AI 또는 무거운 작업에 대해 해당 접근 방식을 통합할 것입니다. MVP의 경우 예약된 작업과 파일 정리를 제외하고는 많이 사용되지 않을 수 있습니다.

## 근거

- **관심사 분리:** 프론트엔드와 백엔드 책임을 명확히 구분함으로써 시스템을 유지 관리하기 쉽게 만듭니다. Next.js는 프레젠테이션 및 사용자 상호 작용을 처리하고 Convex는 데이터 일관성 및 비즈니스 규칙을 처리합니다. 이렇게 하면 백엔드 로직을 위험에 빠뜨리지 않고 UI를 변경할 수 있으며 그 반대도 마찬가지입니다.
- **전문 플랫폼 활용:** Vercel은 프론트엔드 전달(CDN 캐싱, 자산 최적화, 쉬운 배포)에 최적화되어 있으며 Convex는 실시간 동기화를 사용한 백엔드 상태에 최적화되어 있습니다. 각각을 최선으로 사용하면 바퀴를 재발명하지 않습니다. 예를 들어, Next.js가 실시간 동기화를 수행하거나 데이터베이스를 호스팅하도록 시도하지 않았습니다 – 응집력 있는 솔루션을 제공하는 Convex로 오프로드합니다.
- **확장성 및 "성장에 따라 확장":** 이 아키텍처는 작게 시작할 수 있지만 주요 변경 없이 성장할 수 있습니다. 예를 들어, 사용량이 급증하면 Convex는 장면 뒤에서 수평으로 확장할 수 있으며 Vercel은 프론트엔드를 전역적으로 확장합니다(서버리스 함수 및 정적 콘텐츠를 자동 확장). 더 많은 기능(검색, AI 등)을 추가해야 하는 경우 전체 스택을 점검하지 않고도 Convex 컴포넌트 또는 Vercel 통합을 통해 통합할 수 있는 경우가 많습니다.
- **확장 준비:** 확장을 의식적으로 고려합니다:
  - **Agents/AIs:** AI 워크플로(Mastra)를 통합하려면 새 서비스와 인터페이스해야 할 수 있음을 알고 있습니다. 핵심 로직을 Convex에 유지함으로써 Convex에서 AI API로 호출하거나 AI가 Convex로 호출하도록 할 수 있습니다. 비밀을 노출하거나 일관성이 없을 수 있으므로 클라이언트에 AI 로직을 넣지 않습니다. 대신 서버 측(Convex 또는 연합 서버리스 함수)에서 실행하는 것이 더 안전하고 안정적입니다. Mastra는 Vercel 통합 프레임워크[[75]](https://vercel.com/docs/ai-sdk#:~:text=AI%2520SDK%2520,servers%2520%C2%B7%2520Vercel%2520MCP)이므로 서버 측(또는 엣지 측)에서도 실행되어 데이터와 조정할 가능성이 높습니다.
  - **연합:** 지금은 필요하지 않지만 전역적으로 고유한 block ID를 사용하고 단일 모놀리식 서버를 가정하지 않는 설계는 향후 block에 block:<instance>:<id>와 같은 URN을 할당하여 원격 것을 참조할 수 있음을 의미합니다. 아직 명시적으로 수행하지 않았지만 충돌할 자동 증가 ID와 같은 것을 사용하지 않습니다. Convex는 자체 ID(UUID 또는 유사할 가능성이 높음)를 사용하므로 필요한 경우 인스턴스를 통합할 수 있습니다. 또한 모든 액세스가 함수를 통해 이루어지므로 연합 레이어를 도입하는 것은 함수 수준에서 수행할 수 있습니다(예: getBlock이 나중에 로컬 DB에 없는 block을 감지하고 다른 서버에서 가져올 수 있음).
- **모놀리식 대 마이크로서비스:** MVP를 위한 **모놀리식 백엔드**(Convex 함수가 모든 것을 다룸)를 선택하여 마이크로서비스를 분할하지 않습니다. 이는 초기 복잡성을 줄입니다. 그러나 벡터 검색 또는 무거운 ML과 같은 것을 추가하는 것이 Convex의 현재 기능 세트 외부에 있을 수 있음을 인정합니다. 이러한 경우 해당 조각만을 위한 마이크로서비스를 추가할 수 있습니다:
  - 예를 들어, 의미론적 검색을 원하는 경우 외부 벡터 DB(Pinecone 등)를 사용할 수 있습니다. 그런 다음 해당 서비스를 호출하는 Convex 함수가 있습니다. 또는 사용 가능한 경우 Convex의 향후 벡터 검색을 통합합니다(Convex는 마케팅에서 벡터 검색을 언급[[76]](https://stack.convex.dev/presence-with-convex#:~:text=Build%2520in%2520minutes,%2520scale%2520forever)).
  - 계획은 가능한 한 Convex의 생태계 내에서 확장하는 것입니다(컴포넌트를 추가하고 있으므로 예: AI 메모리 컴포넌트[[77]](https://stack.convex.dev/presence-with-convex#:~:text=Deployment), 벡터 검색 등). 필요한 경우에만 별도의 서비스를 분리합니다.
- **보안 경계:** Convex 측에 모든 민감한 작업을 가짐으로써 비밀을 노출할 위험을 줄입니다. Next.js 환경은 Convex 배포 URL과 공개 인증 구성 이상을 보유하지 않습니다. 모든 비밀 키(있는 경우, 예: 타사 API 또는 Mastra 통합용)는 Convex 또는 Vercel 서버리스 함수 환경 변수에 있으며 클라이언트 코드에는 없습니다.
- **일관성:** 하나의 백엔드(Convex)를 통해 모든 것을 실행하면 데이터의 일관성이 보장됩니다. 모든 제약 조건과 로직이 한 곳에 있는 단일 데이터베이스를 갖는 것과 효과적으로 같습니다. 여러 백엔드(협업용 하나, 파일용 하나, AI용 하나)가 있었다면 동기화해야 하며 이는 복잡합니다. 다양한 요구에 Convex 컴포넌트를 사용하면 가능한 경우 하나의 트랜잭션 시스템 내에 유지됩니다.
- **Vercel/Convex 통합 활용:** Vercel에는 통합 마켓플레이스가 있으며 Convex는 나열된 저장소/백엔드 중 하나입니다[[72]](https://vercel.com/docs/integrations#:~:text=Convex). 이는 Vercel과 Convex가 원활하게 작동함을 나타냅니다(예: 환경 구성, 쉬운 배포). 이러한 통합 솔루션을 고수함으로써 커뮤니티 및 공식 지원의 이점을 얻습니다.

## 고려된 대안

- **단일 서버 (Convex 없음):** Postgres 또는 Mongo와 같은 데이터베이스가 있는 Node.js 서버(또는 Next.js API 경로)를 사용하고 협업을 위해 ShareDB 또는 Yjs와 같은 것을 사용합니다. 처음부터 많은 것을 구축해야 하기 때문에(실시간 동기화, OT 로직 등) 선택하지 않았으며 Convex의 우아한 반응성을 잃게 됩니다. 또한 Vercel에서 확장하는 것이 까다로울 수 있습니다(Vercel의 WebSocket은 간단하지 않으며 별도의 WebSocket 서버가 필요할 수 있음).
- **완전히 서버리스 (전용 백엔드 없음):** 클라이언트와 일부 엣지 함수 또는 서비스 조합(예: 데이터베이스 및 인증을 위해 Firebase를 사용하고 협업을 위해 CRDT 라이브러리를 사용)으로 모든 것을 수행하려는 옵션이 있었습니다. 이 패치워크는 유지 관리하기 어려울 것이며 원하는 긴밀한 통합을 달성하지 못할 수 있습니다(예: CRDT 상태를 병합하고 보안을 보장하는 것이 어려울 것입니다).
- **MVP 기준선에 AI 통합:** 한 가지 생각: 첫날부터 AI 에이전트를 포함합니다. MVP를 집중적으로 유지하고 초기 아키텍처를 과도하게 복잡하게 만들지 않기 위해 이에 반대하기로 결정했습니다. 아키텍처가 추가를 허용하기를 원하지만 반드시 지금 가질 필요는 없습니다. 포함하려고 했다면 더 많은 컴포넌트(벡터 DB 또는 외부 LLM 서비스 통합과 같은)가 미리 필요했을 수 있으며 연기할 수 있습니다.
- **확장 고려 사항 무시:** 연합 또는 다중 에이전트 미래를 무시하고 MVP를 구축할 수 있었으며, 이는 나중에 확장을 방해하는 지름길로 이어질 수 있습니다. 의식적으로 이러한 지름길을 피했습니다. 예를 들어, 향후 데이터 병합을 용이하게 하기 위해 전역적으로 고유한 ID를 사용합니다(단일 DB에 연결된 순차 ID가 아님). 새 Convex 함수 또는 새 서비스를 추가하는 것이 모놀리스를 찢어내는 것을 요구하지 않도록 코드를 구조화합니다(예: AI 관련 함수를 별도의 모듈 또는 필요한 경우 별도의 배포로 분리할 수 있음).
- **모노레포 대 별도 레포:** 프론트엔드와 백엔드를 하나의 저장소에 보관할지 고려했습니다. 아마도 예 – Convex 함수는 편의를 위해 Next 앱과 동일한 코드베이스에 있을 수 있습니다(Convex에는 파일 변경을 감시하는 개발 서버가 있음). 이 시너지는 유익할 수 있습니다(프론트와 백 간의 공유 타입 등). 반면에 논리적으로 API로 분리됩니다. 모노레포가 괜찮다고 생각합니다(내부에 Convex 디렉토리가 있는 하나의 Vercel 프로젝트 또는 공유 코드가 있는 두 프로젝트). 결정은 런타임에 크게 영향을 미치지 않지만 개발 경험에 관한 것입니다. 코드를 공유하기 위해 모노레포로 기울어집니다(데이터 모델용 타입과 같은).
- **초기 대 후기 타사 통합:** 많은 Vercel 통합(로깅, 인증 등)이 있습니다. 필요한 최소한으로 고수합니다: 백엔드용 Convex, 시간이 되면 Vercel의 자체 AI SDK일 수 있습니다. 처음부터 Sentry와 같은 것을 통합하지 않기로 결정했지만 오류 모니터링이 필요한 경우 쉽게 추가됩니다. 마찬가지로 별도의 분석은 아직 없습니다(Vercel/Next 분석 또는 Convex의 간단한 로깅을 사용할 수 있음).

## 영향

- **벤더 종속:** Convex와 Vercel을 선택하면 이러한 플랫폼에 어느 정도 묶입니다. 향후 자체 호스팅하거나 오픈 소스 스택으로 이동해야 하는 경우 일부 마이그레이션 작업이 있을 것입니다(Convex에는 오픈 소스 코어가 있지만 완전히 자체 호스팅 가능한지 확실하지 않음. Vercel은 호스팅일 뿐이며 필요한 경우 자체 Next.js 서버로 이동할 수 있음). 더 빠른 개발을 위해 이 종속 트레이드오프를 수용했습니다. 코드를 구조화된 상태로 유지합니다(Convex 로직은 대부분 절대적으로 필요한 경우 다른 서버 프레임워크로 이식할 수 있는 함수에 있음).
- **비용:** Vercel과 Convex 모두 비용 모델(무료 계층 및 그 이상의 사용 기반 가격)을 가지고 있습니다. 놀라움을 피하기 위해 사용량(예: Convex 함수 호출, 데이터 저장소)을 모니터링해야 합니다. AI가 추가되면 API 비용도 발생할 가능성이 높습니다. 명확한 경계를 갖는 것이 여기에 도움이 됩니다: 예: 비용이 요구하는 경우 Convex를 사내 솔루션으로 교체할 수 있습니다(사소하지 않지만 포함됨).
- **단일 장애 지점:** 하나의 Convex 배포는 하나의 장애 지점입니다. 다운되면 앱의 동적 기능이 모두 실패합니다. Vercel과 Convex 모두 높은 가용성을 가지고 있지만 100% 보장되지는 않습니다. 향후 완화는 Convex가 다운된 경우 공개 보기를 위해 일부 콘텐츠의 읽기 전용 캐시 또는 정적 내보내기를 갖는 것일 수 있습니다. 그러나 MVP는 해당 수준의 중복성을 요구하지 않을 것입니다.
- **개발 워크플로:** 개발자는 Next와 Convex 개발 서버를 모두 실행해야 합니다. 다행히 Convex는 백그라운드에서 실행되는 개발 서버를 제공하며 환경 변수를 사용하여 Next를 연결할 수 있습니다. 통합이 괜찮습니다(타입 동기화에 주의하기만 하면 됨).
- **Vercel의 Edge Functions:** 사용자에게 더 가까운 일부 로직을 실행해야 하는 경우(미들웨어, 사용자 지정 인증 리디렉션 또는 곧 엣지에서 일부 AI 모델과 같은) Vercel Edge Functions를 사용할 수 있는 옵션이 있습니다. 지금은 많이 사용되지 않습니다. 정적 사이트 생성을 최적화하거나 공개 페이지를 캐싱하기 위해 엣지에서 무언가를 수행할 수 있습니다. 그러나 대부분의 콘텐츠가 동적이고 로그인 뒤에 있으므로 엣지 캐싱은 embargo 후 공개 읽기 전용 콘텐츠를 캐싱하는 것을 제외하고는 관련성이 적습니다.
- **상태 저장 대 상태 비저장 경계:** Convex는 상태 저장(DB 상태 보유)입니다. Next/Vercel은 요청 간에 상태 비저장입니다(브라우저 메모리에 있는 것 제외). 해당 분할은 Next 서버 메모리에 상태를 저장하려고 시도하지 않도록 주의해야 함을 의미합니다(임시적이고 다중 인스턴스일 수 있음). 모든 영구 상태는 Convex로 가야 합니다(또는 해당 클라이언트에서 임시인 경우 클라이언트 로컬 상태). 또한 서버 측 렌더링은 이전 지식을 가정하는 대신 Convex에서 새 상태를 가져와야 합니다.
- **기능 개발:** 새 기능을 추가할 때 주로 프론트엔드(UI 변경만)인지 백엔드 변경(새 Convex 함수, 테이블)이 필요한지 결정할 것입니다. 많은 기능이 둘 다 포함될 것으로 예상합니다. 좋은 점은 둘 다에 대한 통합 언어(TypeScript)이며 일부 공유 타입(Convex는 codegen을 통해 클라이언트에 타입을 공유할 수 있음)일 가능성이 높습니다. 이는 기능 개발을 가속화하고 불일치 오류를 줄입니다.
- **Mastra 도입:** 실제로 Mastra를 가져올 때 이와 인터페이스하기 위해 별도의 Convex 함수 세트를 할당할 것입니다. 또는 작업 내에서 Mastra를 실행할 수 있습니다(얼마나 무거운지에 따라). Mastra는 기본적으로 AI 에이전트 프레임워크이므로 에이전트 상태를 유지하거나 루프를 실행해야 하는 경우 Convex의 영구 저장소를 사용하여 에이전트 메모리를 저장할 수 있습니다(Convex 스택에 "Built-in Memory가 있는 AI Agents"의 예가 있음[[74]](https://stack.convex.dev/presence-with-convex#:~:text=AI%2520Agents%2520with%2520Built)). 시너지를 제안합니다: 에이전트의 메모리(대화 로그 또는 지식과 같은)는 Convex에 저장되고 에이전트 로직은 Vercel AI SDK를 사용하는 Convex 작업 또는 Vercel 함수에서 실행되며 메모리를 가져오거나 결과를 업데이트하기 위해 Convex를 호출합니다.
- **Workflow 오케스트레이션 예:** "이 주장에 대한 모든 증거 요약" 기능이 있다고 가정합니다. 구현은 다음과 같을 수 있습니다: Convex 작업이 관련 block을 가져오고(edge를 가로지르는 무거운 쿼리일 수 있음) 텍스트를 LLM API(OpenAI와 같은)로 보내 요약하고 결과를 얻고 요약이 있는 새 block을 삽입합니다. 이 시퀀스는 API 호출에서 실패하거나 시간이 걸릴 수 있습니다. Convex의 워크플로(재시도가 있는 내구성 있는 함수)를 사용하면 일시적인 실패가 있어도 완료되도록 보장합니다. 이것이 워크플로를 사용할 계획이며 이러한 작업에 대한 안정성을 보장합니다. 핵심 MVP를 넘어서지만 AI를 통합하는 즉시 나타날 수 있습니다.
- **외부 통합을 위한 API:** 우리 또는 다른 사람이 외부에서 이 지식 시스템과 통합하려는 경우(외부 스크립트 또는 서비스가 데이터를 쿼리하거나 block을 추가해야 하는 경우) 어떻게 할까요? Convex는 HTTP API를 제공합니다(Convex HTTP 엔드포인트 또는 API 키를 사용하여 함수 호출). 통합을 위한 일부 엔드포인트를 노출할 것입니다. 이 예측은 나중에 외부적으로 노출될 수 있는 깨끗한 인터페이스로 Convex 함수를 설계할 것임을 의미합니다(적절한 인증, API 키 또는 서비스 계정 사용일 수 있음). 예를 들어, 연합 시나리오 또는 플러그인 생태계에서 외부 도구가 createBlock 또는 queryEdges를 호출하도록 할 수 있습니다.
- **프로덕션에서 로깅 및 모니터링:** 확장함에 따라 성능 및 오류 모니터링이 중요해집니다. Convex는 일부 원격 측정을 제공하며 Vercel은 서버리스 함수 사용에 대한 로그를 제공합니다. 계측을 추가할 수 있습니다(예: 협업 병합이 얼마나 걸리는지 측정 등). 무언가가 병목 현상이 되면(데이터가 증가함에 따라 특정 쿼리가 느린 것과 같은) 캐싱 또는 더 많은 인덱싱을 고려할 것입니다. 최소한 설계에서 쿼리 함수에서 무거운 루프를 제외합니다(Convex 쿼리는 이상적으로 인덱스로 가져오기만 하고 미친 계산을 수행하지 않아야 함).
- **지속적 배포:** 자주 배포할 계획입니다. Vercel과 Convex 모두 CI/CD 스타일 배포를 지원합니다. 자동으로 조정되지 않을 수 있습니다(즉, 새 Convex 스키마와 새 프론트엔드를 동시에 배포). 따라서 관리할 것입니다(Convex를 먼저 배포하고 함수가 업데이트되었는지 확인한 다음 호출하는 프론트엔드를 배포할 수 있음). 로컬 개발에서 둘 다에 대한 변경 사항을 테스트합니다. 이는 관리 가능하지만 마이그레이션을 수행할 때 주의해야 할 사항입니다(Convex 스키마를 변경하는 것과 같은 것은 신중한 롤아웃이 필요할 수 있음).
- **개발자를 위한 문서:** 새 개발자를 위해 이러한 경계를 문서화할 것입니다: 예: "모든 데이터 변경은 Convex 함수로 이동합니다. Next.js 측에서 애플리케이션 상태를 변경하려고 시도하지 마십시오. Next.js는 Convex를 호출하거나 UI를 렌더링하기만 해야 합니다." 또한 "새 백그라운드 작업을 추가하는 경우 별도의 스케줄러를 구축하는 대신 Convex cron 또는 작업을 사용하는 것을 고려하십시오."

## 확장 경로

각 이전 ADR의 통합 섹션에서 기능별 확장을 참조하십시오. 여기서는 아키텍처 확장을 언급합니다:

- **연합:** 연합 아키텍처(여러 서버 또는 인스턴스가 지식을 공유)를 허용하는 경우 block 모델은 연합의 단위가 되기에 적합합니다. 각 block은 인스턴스 간에 참조될 수 있도록 전역 식별자(인스턴스 + ID의 복합일 수 있음)를 가질 수 있습니다. 연합 시나리오에서 원격 block을 요청 시 동기화하거나 가져오는 메커니즘과 동일한 block이 다른 인스턴스에서 편집되는 경우 충돌을 해결하는 방법(CRDT 또는 합의가 필요할 수 있음, ADR 2 및 3 확장 참조)이 필요합니다. 연합의 경우 올바른 인스턴스로 라우팅하는 현재 백엔드 위의 레이어를 개발할 수 있습니다(스마트 프록시 또는 공개 콘텐츠를 연합하는 ActivityPub 호환 서버와 같은).
- **AI 및 Agents (Mastra):** 지식 베이스를 읽고 기여할 수 있는 AI 에이전트를 포함하도록 확장합니다. 다중 에이전트 워크플로를 위해 Mastra를 통합할 것입니다. 에이전트는 자체 메모리(Convex에 저장)를 가질 수 있으며 데이터를 쿼리하거나 업데이트하기 위해 함수를 호출할 수 있습니다. 아마도 에이전트는 워크플로로 조율된 백그라운드 프로세스에서 실행됩니다. 예를 들어, 에이전트는 새 콘텐츠에서 트리거되어 링크를 제안하거나 요약할 수 있습니다. 아키텍처는 에이전트를 API 액세스 권한이 있는 특수 사용자 또는 프로세스로 취급하여 이를 지원합니다. 에이전트 권한(ADR 6 확장) 및 에이전트가 협업 기능과 상호 작용하는 방법을 고려해야 합니다.
- **벡터 검색 및 의미론적 검색:** 유사한 콘텐츠를 찾기 위한 벡터 검색 시스템을 통합하는 경우 사용 가능한 경우 Convex의 벡터 검색을 사용하거나 Pinecone과 같은 외부 서비스를 통합할 수 있습니다. 이는 백엔드 함수에서 호출됩니다. 예를 들어, 검색 쿼리 함수는 AI API를 통해 쿼리를 임베딩으로 변환한 다음 벡터 DB를 쿼리하고 일치하는 block ID를 반환할 수 있습니다. 그런 다음 Convex에서 해당 block을 검색합니다. 이는 AI(임베딩용) 및 전문 DB(벡터 DB)를 기존 구조와 결합합니다. 아키텍처는 Convex 함수에서 해당 서비스로 호출하거나 전용 서비스(그런 다음 block 세부 정보를 가져오기 위해 다시 호출)에서 수용할 수 있습니다.
- **공개 게시 및 정적 내보내기:** 공개로 표시된 block(ADR 6)의 경우 정적 사이트(정적 블로그와 같은)로 내보내고 싶을 수 있습니다. 주기적으로 또는 트리거 시 Convex에서 모든 공개 block을 가져와 Next.js 정적 페이지를 생성하거나 별도의 정적 사이트를 생성하는 프로세스를 가질 수 있습니다. 이를 통해 SEO를 활성화하고 읽기를 위해 Convex를 치지 않고 공개 콘텐츠를 제공할 수 있습니다. 아키텍처는 모든 공개 block을 쿼리하고 렌더링할 수 있으므로 이를 허용합니다. 연합을 사용하는 경우 다른 인스턴스가 다른 도메인으로 내보내고 교차 링크할 수 있습니다.
- **오프라인 및 로컬 우선:** 오프라인 편집을 원하는 경우 CRDT 접근 방식(Yjs와 같은, ADR 2 & 3 확장 참조)을 통합할 수 있습니다. 또는 확장되는 경우 Convex의 로컬 우선 기능을 사용합니다. 이는 상당한 아키텍처 전환을 의미할 것입니다(온라인일 때 동기화되는 클라이언트 측 데이터베이스). 그러나 block 모델은 여전히 적용될 수 있습니다(block도 로컬 저장소에 동기화됨).
- **Workflow 및 자동화 향상:** 시스템에서 사용자 정의 워크플로를 구현할 수 있습니다. 예를 들어, 사용자는 "주장 block이 추가되면 지원 증거를 찾기 위해 에이전트를 실행"과 같은 규칙을 만들 수 있습니다. 이는 워크플로 엔진(Mastra 또는 Convex 자체일 수 있음)이 이벤트에서 실행됩니다. 아키텍처는 트리거 시스템이 필요합니다(테이블 변경 시 Convex 트리거가 백그라운드 작업을 시작하는 것과 같은). 이는 추측이지만 설정이 허용합니다.
- **다중 테넌시 또는 작업 공간:** 하나의 Convex 인스턴스에서 여러 조직을 지원하려는 경우 데이터를 분할해야 합니다(block, edge 등에 tenantId 또는 workspaceId 추가) 쿼리가 이를 기준으로 필터링하도록 보장합니다. 권한도 테넌트 범위가 됩니다(ACL에 테넌트 컨텍스트를 포함할 수 있음). MVP에는 없지만 제품이 SaaS 다중 테넌트로 확장되면 아키텍처가 적응할 수 있습니다. Convex의 단일 배포는 올바르게 분할하는 한 여러 테넌트를 제공할 수 있습니다. 격리를 위해 테넌트당 별도의 Convex 배포를 고려할 수도 있습니다(더 큰 규모 또는 보안을 위해).
