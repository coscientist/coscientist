---
title: "ADR 4: Edge Types and Dialectical Graph (Typed Edges Over Blocks)"
---

# ADR 4: Edge Types and Dialectical Graph (Typed Edges Over Blocks)

## Context

Beyond linear documents, our knowledge system aims to represent a **knowledge graph** – a network of ideas and information. Blocks (from ADR 1) are the nodes of this graph. We need a way to connect these nodes with various relationships. Some connections are purely structural (e.g. a document block _contains_ a paragraph block), while others are semantic (e.g. Block A _supports_ Block B, or Block C is a _reference_ cited by Block D). The term "Dialectical Graph" suggests we want to model argumentative or dialogic relationships: for example, hypotheses and evidence, claims and counterclaims. In essence, we need **typed edges** between blocks to capture rich relationships and to enable traversal of knowledge in a graph-like manner rather than just parent-child hierarchies.

## Decision

**Implement a general Edge model in the Convex database, with a type field to characterize the relationship, thereby forming a directed graph of blocks.** Each edge will be a record in an edges table (or multiple tables by category if needed for indexing) with schema roughly:

- id: Id<"edges"> – primary key for the edge.
- from: Id<"blocks"> – the source block (start node).
- to: Id<"blocks"> – the target block (end node).
- type: string – the relationship type (examples: "contains", "references", "supports", "opposes", "answers", etc.).
- Metadata: e.g., createdBy, createdAt, perhaps an optional annotation or weight.

Edges are directed: an edge from A to B means "A [type] B". By using types, we can express **dialectical relationships** explicitly. For example:
- If Block X is a claim and Block Y is evidence supporting it, we create an edge Y --supports--> X.
- If Block M contradicts Block N, an edge M --refutes--> N (or opposes) is used.
- For structural containment, we use contains: e.g. Document D contains Block P (edge D --contains--> P). This could also cover sequences or parent/child relationships. (We might manage order via an index or separate field, since multiple edges of type "contains" from the same parent should have an order – possibly a position property in the edge or content array in the parent block.)
- We can represent a Q&A link: Question block Q is answered by Answer block A via A --answers--> Q.
- Dialectical or debate mapping: e.g., thesis --counters--> antithesis if needed.

This design treats edges as first-class objects with their own types and potential properties. It aligns with a **property graph model**, where relationships have a type and can have attributes[[1]](https://shilpathota.medium.com/understanding-knowledge-graphs-for-agentic-ai-7162d018387b#:~:text=,interrelate). We will define a core set of allowed edge types for MVP:
- **Structural types:** "contains" (or "parent-of"/"child-of" relationship). Possibly also "next" for ordering if linear order isn't encoded by a list.
- **Reference type:** "references" (Block A references Block B, e.g. a citation in text linking to a source block).
- **Support/Oppose types:** "supports", "refutes" to capture dialectical support or contradiction.
- **Association types:** "related" for a loose link, "example-of", "definition-of" etc., depending on our domain needs.

We will likely enumerate these in code (as constants or an enum) to avoid arbitrary strings. However, the model is flexible to add new types later without schema changes.

Edges will be manipulated via Convex mutations: e.g., addEdge(from, to, type) to create a link, and removeEdge(id) to delete. We'll also have queries like getEdgesFrom(blockId, typeFilter?) or getEdgesTo(blockId, typeFilter?) to traverse the graph. We plan to create Convex indexes on the from and to fields for efficient lookup (since a typical query is "find all edges where from = X" or "to = Y").

## Rationale

A typed edge model is chosen to provide **semantic richness** and queryability to the relationships in the knowledge base:

- **Separation of content and relationships:** By storing edges separately from blocks, we keep blocks focused on their content and use edges to handle links. This makes it easy to add or remove relationships without modifying the block data. It also means one block can participate in many relationships (one-to-many) freely.
- **Typed edges allow context-specific logic:** For instance, when rendering a document, we follow "contains" edges to gather its content blocks in order. When visualizing an argument graph, we specifically look for "supports" or "refutes" edges to display pro/con arguments. If all links were untyped, we'd lose this ability to treat different connections appropriately[[27]](https://shilpathota.medium.com/understanding-knowledge-graphs-for-agentic-ai-7162d018387b#:~:text=,specific%2520information). Knowledge graphs benefit from **rich semantic relationships** rather than just generic links.
- **Evolvability:** We anticipate expanding the relationship types as the system grows (especially when integrating AI or external systems). The chosen design is easily extendable by adding new type values, akin to adding new relationship types in a property graph – it doesn't break existing data.
- **Query and analysis:** With edges in a table, we can perform graph-like queries within Convex. For example, to find all evidence supporting a claim, we query edges where to = claimId AND type = "supports". This could be done in a Convex query function, potentially even reactive if needed. If edges were only implied (say by embedding references inside block content), we'd have a much harder time querying or enforcing consistency.
- **Alignment with knowledge graph practices:** Storing nodes and edges in tables is a common approach if not using a specialized graph database[[2]](https://shilpathota.medium.com/understanding-knowledge-graphs-for-agentic-ai-7162d018387b#:~:text=,offs). We keep that simplicity (just two tables: blocks and edges). It also resonates with how one might export the data to RDF or other formats in future – each edge is essentially a triple (subject, predicate, object).
- **Dialectical reasoning:** Specifically for dialectical or argument maps, typed edges allow implementing logic such as "if evidence block E supports claim C, and claim C supports theory T, then E indirectly supports T" – these inferences or UI presentations rely on understanding the edge types. We might later have features that automatically summarize support/contradiction for a given block. Having edges clearly labeled with "supports"/"refutes" will enable algorithms or agents to traverse and aggregate arguments.

## Alternatives Considered

- **Untyped (or Implicit) Links:** We could have had a simpler model where blocks just store references to other blocks (like an array of linked IDs) without specifying type, or where type is implicit by context (e.g., a "reference" could just be a hyperlink in text pointing to another block's ID). This was not chosen because it lacks clarity – we want the system to _know_ what a link means. Typed edges make knowledge machine-interpretable (so, for example, an agent can find all counter-arguments easily).
- **Edge Properties embedded in Blocks:** Another approach is to have each block contain fields for relationships, for example: a block might have citations: [blockId] for references or supports: [blockId] for the claims it supports. This becomes unwieldy because each new relation type adds a field, and many-to-many relations are harder to normalize (should the claim list all supporting blocks or each support list which claim it supports? That duplication invites inconsistency). A separate edge entity avoids these problems by normalization.
- **Graph Database or External Store:** We considered using a dedicated graph engine or external service for relationships. For MVP, it's overkill. Convex is fully capable of handling these as rows, and given our data volume in MVP, performance is fine. Using Neo4j or similar could be considered if queries become very complex (like multi-hop traversals) and if Convex queries prove too slow for that. But we prefer to avoid additional infrastructure.
- **Fixed Ontology vs Flexible Types:** We debated whether to allow _user-defined_ edge types (folksonomy-style) or stick to a fixed set. MVP will use a fixed enumerated set for consistency and to enforce known semantics. User-defined relationship types could be powerful but might lead to chaos or misuse (and complicate UI). We can revisit this if needed by advanced users, but initially, we'll keep types to those we implement logic for.

## Implications

- **Integrity Constraints:** We must ensure that edge endpoints (from/to block IDs) actually exist (no dangling edges). This implies when a block is deleted, all edges involving it should also be deleted or updated. We'll implement this in our block deletion mutation: it will query and remove associated edges to maintain consistency. Convex doesn't automatically cascade deletes, so we handle it in code.
- **Preventing Duplicates and Cycles:** The system should likely prevent identical duplicate edges (two edges with same from, to, type) unless there's a rationale (maybe different users want to mark support, but we can handle that via a single edge and maybe a separate vote count if needed). We will enforce uniqueness of (from, to, type) per edge either in code or by composite key logic. Cycles in the graph are possible (especially with semantic links). While cycles aren't inherently "wrong" (e.g., two documents referencing each other), they can cause infinite loops in naive graph traversal. We will need to be cautious in queries/traversals to avoid unbounded recursion. For example, a "contains" hierarchy should ideally be acyclic (a document can't contain itself); we will enforce that by design (no way to make an edge from a block back to one of its parents due to type constraints or checking).
- **Graph Query Complexity:** Convex queries are JavaScript functions that can query the tables. A single query can fetch direct edges easily, but multi-hop traversal (e.g., find all blocks that support something that refutes X) might require multiple queries or client-side logic. We might implement recursive traversal in code (server or client) when needed. This could be an area to optimize later or use an algorithm. For MVP, likely direct 1-hop or 2-hop queries suffice for features (like listing direct references, or showing one level of supports/opposes).
- **Permission Model Interaction:** Edges themselves likely need permission control as well. If a block is private (see ADR 6), should edges pointing to it be visible? We probably will treat edges as metadata that inherits visibility rules from blocks: i.e., if I cannot see Block B, I shouldn't see an edge "A supports B" in a way that leaks B's content. We'll enforce in queries: when listing edges, filter out any edge whose to or from is a block the user has no access to. Also, creating an edge likely requires permission to see both blocks (and perhaps write permission on the "from" block if we treat adding an outgoing link as editing that block's context). We will clarify these rules and implement checks in the edge-creation mutation.
- **UI Complexity:** Representing a graph to users means we need UI affordances. For MVP, we might keep it simple: e.g., under a claim block, list its supporting evidence blocks (pull via edges); or on a reference, show backlinks (what blocks reference this). This is doable by querying edges. A full graph visualization or traversal interface might come later. We should ensure the data model doesn't limit that – it doesn't, since it's a general graph.
- **Batch Operations:** Some user actions might create multiple edges at once. For example, if a user imports a markdown with footnotes, we might auto-create blocks for references and edges linking them. Our design can handle bulk insertion (just multiple mutations). But we must be mindful of consistency if part fails – likely wrap in a Convex function that either creates all required blocks and edges or aborts on error.
- **Edge Properties for Advanced Use:** We left room for properties on edges. In MVP, we might not use it much except maybe an order for "contains". But if needed, edges could hold attributes like a description or weight (e.g., a score representing how strong a support is). The model supports it without alteration, illustrating its flexibility.

## Expansion Path

- **Additional Edge Types / Ontologies:** As the knowledge base grows, we may introduce more nuanced relationship types or even domain-specific ontologies. For instance, in a scientific context, we might add "extends" (for a study that extends prior work), "confirms", "disputes", etc. The ADR's model easily allows new types. We would also update UI and maybe color-code or iconify different edge types for user clarity.
- **Weighted or Annotated Edges:** In argument mapping, sometimes supports/opposes are weighted (strongly supports, weakly supports, etc.). We could add a weight or score field on edges, or represent that as separate types (e.g., "strongly_supports"). A more structured approach is to allow an edge to carry a small content payload – for example, an edge could have a justification text explaining _why_ Block A supports Block B. Our schema could accommodate an annotation field for that. In the future, edges themselves could even be elevated to full "block" status (like nodes) to allow rich annotations. But that complicates the model (an edge as a node in meta-graph). For now, simple properties would do.
- **Graph Visualization and Query:** We might implement a visual graph view of the knowledge. To do so efficiently, we might need to retrieve subgraphs (all nodes and edges within N hops of a given block). We may create specialized Convex functions that do depth-limited DFS/BFS to gather such subgraph data. If this becomes intensive, we could consider caching some graph structure or using an external search index for relationships. Expansion could also integrate with graph algorithms (shortest path, centrality) if we build analysis features. There is mention in research about computing metrics like centrality once a graph is built[[28]](https://shilpathota.medium.com/understanding-knowledge-graphs-for-agentic-ai-7162d018387b#:~:text=We%2520have%2520directed%2520graphs%2520where,the%2520shortest%2520routes%2520between%2520nodes), which could be interesting for identifying key blocks in the knowledge base.
- **Federation and Cross-Instance Edges:** If in future multiple instances of the system share knowledge, we might allow edges that connect blocks from different instances. This raises questions: how to uniquely identify a block globally (we might need a global ID scheme or URIs)? Possibly using something like Atproto/ActivityPub to reference remote content. We could extend edges with fields to hold an external reference (like toExternal: {instance: URL, id: externalId}). Initially out of scope, but the model could be extended to support "external edges" pointing outside the local Convex database. This would be key in a federated knowledge network where, say, a claim in one server is supported by evidence in another.
- **Automated Edge Creation (AI-driven):** With the introduction of AI agents (Mastra, etc.), we foresee tools that automatically suggest or even create edges. For example, an AI reading a block might suggest "This block contradicts Block Z" and propose a refutes edge. Or auto-citation: an agent finds a relevant source and creates a references edge. Our system can accommodate this since edges are just data – an agent with appropriate permissions could call addEdge. We might need to mark such edges as AI-suggested (maybe via a property or a specific subtype) so users can trust or verify them. This is an expansion that uses our core architecture to deepen the knowledge graph intelligently.
- **Hierarchical or Compound Edge Types:** We might eventually introduce hierarchy in relationships (some types might be sub-types of others). For example, a "supports" edge could be broken into "empirical_support" vs "theoretical_support". Managing such taxonomy might require either convention in type naming or an explicit schema. If needed, we could add an ontology table or use prefixes in type (like support:empirical). This would allow more complex reasoning. This is speculative, and we'd approach it when there's a clear use case.
- **Edge Life-cycle and Versioning:** Currently, edges are relatively static links. In the future, edges themselves might change or be contested (maybe one user asserts a support link and another disagrees). We could version edges like we do blocks – but that adds a layer of complexity (like an edge existence might have a history of being added/removed). For now, we assume edges are either present or not, but expansion could consider tracking when edges were introduced or removed in the knowledge evolution. This would align with an even richer knowledge management practice (like "history of how ideas became connected").
