---
title: "ADR 5: 파일 저장소 및 액세스 제어 (Convex File Storage + Files Control)"
---

# ADR 5: 파일 저장소 및 액세스 제어 (Convex File Storage + Files Control)

## 컨텍스트

지식 시스템에는 **파일 첨부** – 이미지, PDF, 데이터 파일 등이 포함됩니다. 사용자가 파일을 업로드하고 block에 포함하거나 연결할 수 있도록 해야 합니다. 주요 요구 사항은 잠재적으로 큰 바이너리 파일 처리, 효율적인 전달(CDN을 통해 가능), 비공개 파일이 권한이 없는 사용자에게 액세스할 수 없도록 하는 **액세스 제어**입니다. Convex를 백엔드로 사용하고 있으므로 개발을 간소화하기 위해 제공되는 파일 저장소 기능을 사용하는 것을 목표로 합니다. Convex는 통합 파일 저장소 솔루션을 제공하며 안전한 파일 처리를 위한 상위 수준 API를 제공하는 _Files Control_이라는 Convex 컴포넌트가 있습니다. MVP를 위해 이를 통합하는 방법을 결정하여 앱의 컨텍스트에서 파일 업로드 및 검색이 원활하고 안전하도록 해야 합니다.

## 결정

**업로드, 다운로드 및 파일 권한을 관리하기 위해 Convex Files Control 컴포넌트와 함께 Convex의 내장 File Storage를 활용합니다.** 파일을 주 데이터베이스 외부(바이너리 저장소)에 저장된 특수한 종류의 콘텐츠로 취급하고 Block 모델에서 ID로 참조합니다. 구현의 주요 사항:

- Convex 백엔드에 @convex-dev/files(또는 타사 convex-files-control) 컴포넌트를 설치하고 구성합니다. 이는 업로드 URL 생성, 업로드 완료 및 액세스 확인이 있는 다운로드 URL 생성을 위한 서버 함수를 제공합니다[[29]](https://www.convex.dev/components/files-control#:~:text=Convex%2520Files%2520Control)[[30]](https://www.convex.dev/components/files-control#:~:text=*%2520Two,for%2520presigned%2520or%2520HTTP%2520uploads).
- **파일 업로드:** 2단계 업로드 프로세스를 사용합니다:
  - 클라이언트는 변경(컴포넌트의 generateUploadUrl 래핑)을 호출하여 Convex에서 업로드 URL을 요청합니다. 이는 일회용 **사전 서명된 URL**과 uploadToken을 반환합니다[[31]](https://www.convex.dev/components/files-control#:~:text=//%2520Client,).
  - 그런 다음 클라이언트는 해당 URL에 HTTP PUT을 통해 Convex 저장소에 직접 파일을 업로드합니다(무거운 바이너리 전송을 위해 앱 서버를 우회). 성공하면 Convex는 storageId를 반환합니다[[32]](https://www.convex.dev/components/files-control#:~:text=const%2520,json).
  - 클라이언트는 uploadToken 및 storageId로 Convex 변경(finalizeUpload 래핑)을 호출하여 업로드를 확인합니다[[33]](https://www.convex.dev/components/files-control#:~:text=const%2520result%2520=%2520await%2520finalizeUpload\(,1000,). 래퍼에서 이 시점에 이 storageId에 연결된 blocks 테이블에 "file" 타입의 Block을 생성합니다. 또한 파일에 대한 초기 액세스 제어 목록을 전달합니다: 기본적으로 업로더의 사용자 ID에 액세스 권한이 부여됩니다[[34]](https://www.convex.dev/components/files-control#:~:text=const%2520,). Files Control 컴포넌트는 해당 사용자의 ID(주체)를 파일 레코드의 액세스 키로 연결하는 것을 처리합니다[[35]](https://www.convex.dev/components/files-control#:~:text=const%2520result%2520=%2520await%2520ctx,).
- **파일 제공:** Next.js를 통해 파일을 제공하지 않습니다. 대신 파일 액세스를 위한 안전한 URL을 생성합니다:
  - 콘텐츠의 인라인 이미지의 경우 공개 URL이 필요합니다. Files Control에는 경로를 통해 파일을 제공하기 위해 활성화할 수 있는 선택적 HTTP 라우터가 포함되어 있습니다(예: https://<convex-site>/files/download?token=XYZ). 다운로드 경로를 활성화할 것입니다[[36]](https://www.convex.dev/components/files-control#:~:text=A%2520Convex%2520component%2520for%2520secure,plus%2520a%2520React%2520upload%2520hook)[[37]](https://www.convex.dev/components/files-control#:~:text=//%2520convex/http.ts%2520import%2520,generated/api) Convex의 내장 인증 후크를 사용하여 권한이 있는 요청만 성공하도록 합니다[[38]](https://www.convex.dev/components/files-control#:~:text=checkUploadRequest:%2520async%2520\(ctx\)%2520=,Type%2522:%2520%2522application/json%2522%2520%257D,%2520%257D\);)[[39]](https://www.convex.dev/components/files-control#:~:text=//%2520Optional:%2520provide%2520accessKey%2520for,).
  - 또는 buildDownloadUrl 함수를 사용하여 요청 시 시간 제한 URL을 생성할 수 있습니다[[40]](https://www.convex.dev/components/files-control#:~:text=import%2520,control). 예를 들어, 이미지를 표시할 때 앱은 이에 대한 URL을 요청할 수 있으며, 이는 단기 토큰을 포함합니다. 이렇게 하면 누군가가 URL을 찾더라도 만료됩니다(requireAccessKey가 켜져 있으면 로그인하지 않으면 작동하지 않음)[[41]](https://www.convex.dev/components/files-control#:~:text=).
- **액세스 제어:** Convex에 저장된 각 파일에는 연결된 **액세스 키** 세트가 있습니다(block에 ACL이 있는 것처럼). 기본적으로 사용자 ID를 액세스 키로 사용합니다. Files Control 컴포넌트는 파일에 대한 액세스 키를 추가하거나 제거하는 변경을 제공합니다[[42]](https://www.convex.dev/components/files-control#:~:text=Access%2520keys%2520are%2520normalized%2520,empty%2520value). 파일 block이 사용자와 공유되거나 공개되면 해당 파일의 storageId에 대해 적절한 사용자 ID 또는 특수 "public" 키에 대해 addAccessKey를 호출하도록 block 권한(ADR 6)과 통합할 것입니다. 반대로 권한이 취소되면 키를 제거합니다. 이를 통해 사용자가 파일을 다운로드하려고 할 때 컴포넌트의 hasAccessKey 확인이 허용되는지 확인할 수 있습니다[[43]](https://www.convex.dev/components/files-control#:~:text=Access%2520keys%2520are%2520normalized%2520,empty%2520value).
- **포함 및 썸네일:** 사용자 편의를 위해 콘텐츠에 이미지를 직접 포함하는 것을 지원합니다. 위의 안전한 URL을 src로 하는 <img> 태그를 사용할 수 있습니다. PDF 또는 다른 파일의 경우 링크를 표시하거나 다운로드를 허용할 수 있습니다. 실제 렌더링을 위해 브라우저 또는 뷰어에 의존할 것입니다. 필요한 경우 이미지 썸네일을 생성할 수 있지만 MVP를 넘어섭니다(별도의 서비스를 통해 수행할 수 있음).
- **저장소 백엔드:** Convex 저장소는 기본적으로 자체 백업 저장소를 사용합니다(후드 아래에서 S3일 가능성이 높음). Files Control 컴포넌트는 Cloudflare R2도 옵션으로 지원합니다[[36]](https://www.convex.dev/components/files-control#:~:text=A%2520Convex%2520component%2520for%2520secure,plus%2520a%2520React%2520upload%2520hook). MVP의 경우 Convex의 기본값을 사용할 수 있습니다(빠르게 시작). 많은 파일 사용을 예상하거나 비용을 줄이려면 R2를 구성할 수 있습니다. 여기서의 결정은 Convex 관리 저장소를 고수하고, 필요한 경우 자격 증명을 제공하여 프로덕션에서 R2로 전환하는 것입니다(컴포넌트의 API는 둘 다 원활하게 지원).
- **정리 및 보존:** 컴포넌트의 내장 정리 기능을 사용할 것입니다. 만료된 파일과 사용되지 않은 업로드 토큰을 삭제하는 cron 작업을 제공합니다[[44]](https://www.convex.dev/components/files-control#:~:text=Cleanup). 이를 예약할 것입니다(예제는 만료된 업로드 및 권한을 정리하기 위해 시간마다 실행되는 Convex cron을 보여줍니다)[[45]](https://www.convex.dev/components/files-control#:~:text=Use%2520,it%2520in%2520a%2520cron%2520job). 일회성 링크 또는 임시 데이터에 대해 적절한 만료를 설정하도록 보장할 것입니다. 기본적으로 파일에 대한 expiresAt을 지정하지 않으면 무기한 존재할 수 있습니다. 파일 자체에 만료를 사용하지 않을 수 있지만(자동 만료를 원하지 않는 한) 임시 다운로드 링크에는 사용할 것입니다.
- **파일 메타데이터:** 파일 메타데이터(파일 이름, 크기, 콘텐츠 타입 등)를 자체 blocks 테이블 또는 별도의 filesMeta 테이블에 저장할 것입니다. Files Control 예제는 finalizeUpload 후 자체 파일 레코드를 저장할 것을 제안합니다[[46]](https://www.convex.dev/components/files-control#:~:text=). 이를 수행할 것입니다: 예: fileName, fileSize, contentType 및 storageId와 같은 필드가 있는 "file" 타입의 block을 생성합니다. 이를 통해 UI에 파일 정보를 표시하고 필요한 경우 검색할 수 있습니다. 저장소 자체는 불투명합니다(검색을 위한 ID일 뿐).
- **대용량 파일 고려 사항:** 사전 서명된 업로드 접근 방식은 파일이 서버를 거치지 않음을 의미하며, 이는 대용량 파일에 좋습니다. Convex는 파일당 상한선이 있을 것입니다(아마도 ~5GB 정도; 여기에 문서화되지 않음). 앱 수준에서 업로드에 대한 합리적인 크기 제한을 강제할 것입니다(MVP의 경우 몇 백 MB, 구성 가능). 필요한 경우 파일을 분할하거나 클라이언트 측에서 이미지를 압축할 수 있지만 처음에는 아닙니다.

## 근거

Convex의 파일 저장소 및 Files Control 컴포넌트를 사용하는 것은 실용적인 선택입니다:
- **통합 보안:** Files Control 모듈은 파일 URL에 대한 액세스 제어를 강제하여 권한이 없는 다운로드를 방지하도록 설계되었습니다[[36]](https://www.convex.dev/components/files-control#:~:text=A%2520Convex%2520component%2520for%2520secure,plus%2520a%2520React%2520upload%2520hook)[[47]](https://www.convex.dev/components/files-control#:~:text=Access%2520keys%2520are%2520not%2520placed,consumeDownloadGrantForUrl). 일회용 토큰을 생성하고 만료를 처리합니다. 이를 통해 자체 서명 메커니즘을 구현하지 않아도 됩니다. 예를 들어, 제공된 API를 사용하여 필요한 경우 암호로 보호된 파일 링크 또는 N번만 작동하는 링크를 쉽게 만들 수 있습니다[[48]](https://www.convex.dev/components/files-control#:~:text=Set%2520,to%2520return%2520an%2520access%2520key)[[49]](https://www.convex.dev/components/files-control#:~:text=const%2520grant%2520=%2520await%2520ctx,passphrase%2522%2520%257D,).
- **개발 속도:** 자체 S3를 설정하고 URL에 서명하는 람다를 작성하는 것보다 이 기존 컴포넌트를 활용하는 것이 훨씬 빠릅니다. 컴포넌트는 업로드를 단순화하는 React 후크도 제공합니다[[50]](https://www.convex.dev/components/files-control#:~:text=React%2520hook)[[51]](https://www.convex.dev/components/files-control#:~:text=//%2520Presigned%2520await%2520uploadFile\(,).
- **Convex와의 일관성:** Convex의 생태계 내에서 파일 처리를 유지함으로써 데이터와 파일 모두에 대한 단일 진실의 원천을 유지합니다. Convex의 반응성은 파일 메타데이터 변경에 반응할 수도 있습니다(파일 자체는 정적 콘텐츠이지만). 또한 배포 및 환경 구성이 더 간단합니다(별도의 파일 서버 없음).
- **확장성 및 CDN:** Convex의 접근 방식(특히 R2 또는 기본값을 사용하는 경우)은 CDN을 통해 또는 최소한 효율적으로 파일을 전달할 것입니다. *.convex.site URL은 전달에 최적화되어 있습니다. R2를 사용하는 경우 Cloudflare의 CDN이 자동으로 작동합니다. 이는 수동으로 CDN을 구성하지 않고도 파일을 가져오는 사용자에게 좋은 성능을 의미합니다.
- **파일 수명 주기 관리:** 만료된 파일에 대한 정리를 포함하는 컴포넌트와 각 파일에 만료를 설정하는 기능은 가치가 있습니다. 예를 들어, 사용자가 자동 삭제되어야 하는 중간 파일 또는 이미지 미리보기를 업로드하도록 허용하는 경우 간단합니다. 또한 사용자가 파일 block을 삭제하는 경우 공간을 절약하기 위해 저장소에서 파일을 제거하는 것을 고려해야 합니다. 컴포넌트의 deleteFile(cleanUp.cleanupExpired 또는 직접 호출을 통해)을 사용할 수 있습니다.
- **대안과의 비교:** AWS S3를 직접 사용하려면 서명된 URL 생성(AWS SDK 또는 클라우드 함수를 통해)을 설정하고, 버킷 권한을 관리하고, 별도의 자격 증명 세트를 관리해야 합니다. Convex 컴포넌트는 이 모든 것을 래핑하며, 이를 사용하면 스택이 동질적으로 유지됩니다. 또한 Convex는 이미 앱의 일부이므로 교차 서비스 복잡성을 피합니다(파일 업로드 로직만을 위한 별도의 백엔드가 필요하거나 S3와의 CORS 문제와 같은).
- **예제 및 선례:** Files Control 컴포넌트는 상대적으로 새롭지만 Convex에서 권장하는 접근 방식으로 보입니다(Convex 컴포넌트로 나열되어 있으므로). 기능 세트는 요구 사항을 다룹니다: 사전 서명된 업로드, 안전한 다운로드, 액세스 키 관리[[36]](https://www.convex.dev/components/files-control#:~:text=A%2520Convex%2520component%2520for%2520secure,plus%2520a%2520React%2520upload%2520hook)[[52]](https://www.convex.dev/components/files-control#:~:text=Access%2520control%2520&%2520queries). 이를 채택하면 파일을 다루는 Convex 앱에 대한 "규칙"을 따르며 위험을 줄입니다.

## 고려된 대안

- **직접 파일 포함:** 한 가지 아이디어는 작은 파일(이미지와 같은)을 Convex 데이터베이스에 바이너리 데이터로 직접 저장하는 것입니다(예: block에 base64). 데이터베이스를 부풀리고 쿼리를 느리게 만들기 때문에 거부되었습니다. Convex의 파일 저장소는 바이너리를 위한 것입니다. 이를 사용하는 것이 block에 포함하는 것보다 더 효율적입니다.
- **Convex 통합 없는 외부 저장소 (S3/GCS):** AWS S3 또는 Google Cloud Storage를 직접 사용하여 URL에 서명하는 자체 백엔드 엔드포인트를 작성할 수 있었습니다. 실현 가능하지만 더 많은 보일러플레이트를 의미하고 해당 엔드포인트가 안전한지 확인해야 합니다. 또한 Convex의 인증과의 긴밀한 통합을 잃게 됩니다. 시간을 절약할 수 있는 MVP에 대해 Convex의 파일 시스템에 대한 약간의 벤더 종속은 허용 가능하다고 결정했습니다.
- **Next.js를 통한 제공 (Vercel에서 파일 호스팅):** 작은 미디어의 경우 Next.js 공개 폴더로 가져오거나 정적 자산에 Vercel의 내장 저장소를 사용할 수 있습니다. 사용자 업로드에는 작동하지 않습니다. 동적이며 앱을 다시 빌드하거나 제공하는 API가 필요하기 때문입니다. Vercel에는 사용자 업로드를 위한 내장 바이너리 저장소가 없습니다 – 여전히 외부 저장소로 푸시해야 합니다. 따라서 이것은 실제 솔루션이 아니었습니다.
- **피어 투 피어 또는 IPFS:** "지식 시스템" 분위기를 고려하여 비정통적이지만 고려됨 – 파일을 분산 저장하기 위해 IPFS 또는 유사한 것을 사용합니다. 복잡성과 세밀한 액세스 제어 부족으로 인해 MVP에 적합하지 않습니다(IPFS의 모든 것은 공개). 간단하고 비공개 파일 저장소가 필요하며 Convex가 제공합니다.
- **파일 지원 없음:** 이론적으로 파일 첨부 없이 MVP를 시작할 수 있습니다. 그러나 이는 유용성을 심각하게 제한합니다(사용자는 종종 이미지나 PDF를 추가해야 함). 파일 지원을 지식 플랫폼 MVP의 필수 기능으로 판단했습니다.

## 영향

- **인증 통합:** Convex Auth(OAuth 공급자 또는 이메일 로그인을 사용할 가능성이 높음)를 사용하여 사용자를 식별할 것입니다. 파일 액세스 키는 사용자의 identity.subject(고유 사용자 ID)에 의존합니다[[53]](https://www.convex.dev/components/files-control#:~:text=handler:%2520async%2520\(ctx,%2520args\)%2520=,Unauthorized)[[54]](https://www.convex.dev/components/files-control#:~:text=,Unauthorized). 모든 파일 작업이 인증된 사용자와 연결되도록 해야 합니다. 따라서 업로드 및 다운로드(비공개 파일의 경우)에 로그인이 필요합니다. 공개 파일은 인증을 우회하는 공유 가능한 링크를 사용하여 처리할 수 있지만 의도적으로만 생성할 것입니다. 토큰 없이 원시 저장소 URL을 유출하지 않도록 주의해야 합니다.
- **앱 크기 / 대역폭:** 파일을 처리하는 것은 잠재적으로 큰 데이터 전송을 의미합니다. 비용(Convex 또는 R2 대역폭 비용, Vercel edge 함수 사용)을 주시해야 합니다. 사용자가 매우 큰 파일을 자주 업로드하는 경우 문제가 될 수 있습니다. 파일 크기 제한을 부과하고 압축을 권장할 수 있습니다(큰 비디오는 허용되지 않을 수 있음).
- **콘텐츠 보안:** 시스템은 본질적으로 바이러스 스캔이나 파일 콘텐츠를 조정하지 않습니다. 내부 사용의 경우 괜찮을 수 있습니다. 공개 플랫폼의 경우 이미지에 바이러스 스캔 또는 콘텐츠 조정을 통합해야 할 수 있습니다. 지금은 사용자 간의 신뢰를 가정하거나 MVP에서 범위를 벗어납니다.
- **백업 및 데이터 지속성:** Convex에 저장된 파일은 서비스에 의해 중복으로 지속될 것으로 추정되지만 확인해야 합니다. Convex 저장소에서 마이그레이션해야 하는 경우 storageId를 사용하여 파일을 복사해야 합니다(내보내기 스크립트를 통해). 약간의 종속: 파일은 코드의 데이터만큼 쉽게 마이그레이션되지 않습니다(항상 모두 가져와서 다른 곳에 업로드하는 스크립트를 작성할 수 있지만).
- **사용자 경험:** 사전 서명된 URL을 통한 업로드는 직접 양식 게시보다 약간 덜 간단할 수 있지만 React 후크(useUploadFile) 사용은 복잡성을 숨겨야 합니다[[50]](https://www.convex.dev/components/files-control#:~:text=React%2520hook)[[51]](https://www.convex.dev/components/files-control#:~:text=//%2520Presigned%2520await%2520uploadFile\(,). UI에서 진행률 피드백을 제공해야 합니다(후크가 진행률 이벤트를 제공하거나 fetch 진행률을 탭할 수 있음). 또한 업로드가 완료되면 파일 block을 표시하는 것을 처리해야 합니다(아마도 finalizeUpload 변경이 새 block의 ID를 반환).
- **파일 이름 및 URL 위생:** 생성하는 다운로드 URL에는 사용자 편의를 위해 원래 파일 이름을 포함할 수 있습니다(buildDownloadUrl은 content-disposition에 대한 파일 이름 매개변수 지정을 허용[[55]](https://www.convex.dev/components/files-control#:~:text=)). 다운로드에 올바른 이름이 있도록 해야 합니다(예: 임의의 ID 대신 "report.pdf"). 또한 시스템은 파일 이름 충돌 또는 삭제를 처리해야 합니다(파일 컴포넌트가 안전하지 않은 문자를 처리할 가능성이 높음).
- **Block 공유와 파일 액세스 관리:** 파일 ACL을 block ACL과 동기화 상태로 유지해야 합니다. 사용자가 이미지가 포함된 문서를 누군가와 공유하는 경우 이미지 파일도 액세스 가능해야 합니다. 이는 block에 대한 공유 로직(ADR 6)이 다음을 포함함을 의미합니다: block(또는 부모 문서)을 사용자가 사용할 수 있게 만드는 경우 내부의 파일 block을 반복하고 해당 파일에 대해서도 addAccessKey를 호출합니다. 반대로 액세스를 취소하는 경우 키를 제거합니다. 이 결합은 더 많은 코드를 의미하지만 보안에 필요합니다. 또는 편의를 위해 _모든 파일이 부모 block의 권한을 상속_하기로 결정할 수 있습니다. 파일 block을 볼 수 있는 모든 사용자에게 항상 액세스 키를 제공하여 이를 강제할 수 있습니다. 향후 최적화는 프로젝트별로 파일을 그룹화하거나 테넌트 ID를 액세스 키로 사용하는 것일 수 있습니다(컴포넌트는 사용자 ID뿐만 아니라 임의의 문자열을 키로 허용[[56]](https://www.convex.dev/components/files-control#:~:text=Access%2520keys%2520are%2520normalized%2520,empty%2520value)). 지금은 사용자 ID로 충분합니다.
- **만료 링크 대 직접 인증 확인:** Files Control은 URL에 만료 토큰을 사용하거나 요청에 인증 토큰을 포함하도록 요구할 수 있습니다(requireAccessKey가 true인 경우)[[41]](https://www.convex.dev/components/files-control#:~:text=). 내장 HTTP 경로를 사용하는 경우 Convex 도메인에 있으므로 다운로드 요청을 인증하기 위해 사용자의 Convex 인증 세션 쿠키를 활용할 수 있습니다(존재하는 경우). 이는 편리합니다(내부 사용을 위해 토큰을 생성할 필요 없음). 그러나 포함된 이미지(웹 페이지에서)에서 교차 출처 문제로 인해 세션 쿠키를 사용하는 것이 작동하지 않을 수 있습니다(앱 도메인 대 convex 도메인). 따라서 토큰화된 URL을 사용하는 것이 이미지에 더 간단할 수 있습니다. 사용자 쿠키 없이 가져올 수 있도록 이미지에 대한 단기 URL을 생성할 것입니다(URL의 토큰으로 충분). 이는 트레이드오프입니다: URL의 토큰은 만료될 때까지 다른 사람이 복사하여 사용할 수 있습니다. 그러나 짧은 경우(예: 5분) 지속적으로 새로 고쳐지면(액세스 시 다시 가져오기와 같은) 합리적으로 안전합니다.
- **공개 파일의 UX:** 결국 진정으로 공개 block을 허용하는 경우 첨부된 파일에는 공개 액세스가 필요합니다. 컴포넌트는 **공유 가능한 링크** 생성을 지원합니다(본질적으로 파일을 인증 없이 액세스 가능하게 표시)[[57]](https://www.convex.dev/components/files-control#:~:text=Shareable%2520links). 공개적으로 제공하기 위해 다운로드 권한에 shareableLink: true를 사용할 것입니다. 이는 block이 공개적으로 게시되면 파일을 공유 가능으로 표시할 수 있음을 의미합니다. 이를 문서화하고 의도한 경우에만 수행하도록 보장할 것입니다.

## 확장 경로

- **이미지 썸네일 및 처리:** 나중에 이미지 처리 단계를 통합할 수 있습니다. 예를 들어, 미리보기에 표시할 큰 이미지에 대한 더 작은 썸네일을 생성합니다. Convex는 기본적으로 이미지를 처리하지 않지만 타사를 통합하거나(또는 Vercel Edge Functions를 사용할 수 있음) 이를 위해 사용할 수 있습니다. 또는 **AI/ML** 기능을 사용합니다: 예를 들어, AI 파이프라인이 있는 경우 이미지에서 텍스트를 생성하거나 그 반대로 생성합니다. 이는 MVP를 넘어섭니다. 필요한 경우 다른 storageId 아래에 이미지의 여러 버전(원본 및 썸네일)을 저장할 수 있습니다.
- **비디오 및 오디오 처리:** 시스템이 나중에 멀티미디어(비디오, 오디오)를 지원하는 경우 인코딩/스트리밍을 위해 전문 서비스(Mux 또는 Cloudinary와 같은)로 오프로드할 수 있습니다. 그러나 아키텍처 측면에서 유사하게 취급할 것입니다: 파일을 저장하고 스트리밍 URL에 대한 링크를 저장할 수 있습니다. 이와의 통합은 향후 ADR일 수 있습니다.
- **대용량 데이터 파일 및 외부 통합:** 연구자는 데이터 세트 파일을 업로드할 수 있습니다. 이것이 매우 커지면 Convex의 저장소가 비용 효율적이지 않을 수 있습니다. 사용자 자신의 클라우드 또는 기관 저장소와 통합할 수 있습니다(Google Drive 또는 S3 버킷에 연결과 같은). 이는 통합 액세스 제어를 복잡하게 만들지만 실제 파일 대신 참조 링크를 저장할 수 있습니다. 확장에서 실제로 파일을 저장하는 대신 연결하는 "external_file" 타입의 block을 허용할 수 있습니다(필요한 경우 인증 토큰과 함께 URL을 보유). MVP에 대한 결정은 실제로 파일을 저장하는 것이지만 거대한 콘텐츠에 대해 대신 연결하는 것에 열려 있습니다.
- **공개 파일 저장소:** 지식 베이스의 일부를 공개적으로 여는 경우 특정 파일을 더 직접적으로 또는 정적 호스팅을 통해 제공하고 싶을 수 있습니다. 아마도 모든 공개 이미지를 성능을 위해 정적 사이트/CDN으로 오프로드할 수 있습니다. 이는 자동화된 프로세스일 수 있습니다: block이 공개로 표시되면 파일을 공개 버킷에 복사하고 공개 URL을 사용합니다. 이렇게 하면 무거운 공개 트래픽에 대해 Convex를 긴장시키지 않습니다. 아키텍처는 이를 지원할 수 있습니다: 내부 사용을 위한 storageId와 내보낸 경우 publicURL 필드를 유지합니다. 이는 규모에 대한 최적화입니다.
- **파일 버전 관리:** 현재 사용자가 파일을 업데이트하는 경우(예: 이미지 교체) 새 파일이 있는 새 block으로 취급하고 이전 파일을 삭제된 것으로 표시할 것입니다. 파일에 대한 버전 히스토리도 허용하는 것을 고려할 수 있습니다(이전 첨부 파일과 같은). MVP의 경우 필요하지 않습니다. 향후 ADR은 파일 block을 업데이트하면 동일한 block id를 유지하지만 새 storageId를 가리키고 히스토리에 이전 storageId를 유지하도록 지정할 수 있습니다(또는 이전 버전으로).
- **암호화:** 매우 민감한 데이터의 경우 서버 측 확인만으로는 충분하지 않을 수 있습니다. 엔드 투 엔드 암호화가 필요할 수 있습니다(키가 있는 클라이언트만 파일을 해독할 수 있음). 이는 사소하지 않으며 MVP의 범위에 없지만 아키텍처를 확장할 수 있습니다: 업로드 시 파일을 암호화하고 권한이 있는 사용자당 안전한 장소에 키를 저장할 수 있습니다. 이는 다운로드 작동 방식에 영향을 미칩니다(클라이언트 측 해독 필요). 매우 비공개 연구 데이터를 다루지 않는 한 필요하지 않을 가능성이 높지만 보안 요구 사항이 높아지면 향후 향상으로 언급할 가치가 있습니다.
- **Workflow/Agents와의 통합:** 파일을 생성하는 백그라운드 프로세스 또는 에이전트(보고서 PDF를 생성하는 AI 또는 데이터를 수집하고 CSV를 저장하는 워크플로와 같은)가 있는 경우 동일한 파일 저장소 메커니즘을 사용하여 통합할 수 있습니다. Convex 스케줄링은 파일을 생성하고 적절한 액세스 키로 동일한 finalizeUpload를 사용할 수 있습니다. 파일 저장소에 대한 일관된 접근 방식은 자동화된 콘텐츠도 동일한 파이프라인을 거치므로 유지 관리를 단순화합니다.
- **사용자 할당량 및 정리:** 사용량이 증가함에 따라 남용을 방지하기 위해 사용자 수준 저장소 할당량을 구현할 수 있습니다(특히 다중 테넌트 또는 공개가 되는 경우). 아키텍처는 새 업로드를 허용하기 전에 사용자의 총 파일 크기를 확인하여 이를 처리할 수 있습니다. 또한 사용되지 않는 파일에 대한 더 공격적인 정리(파일 block이 삭제되면 만료된 것으로 표시하는 대신 파일 콘텐츠를 즉시 삭제). 참조 block이 없을 때 파일 콘텐츠를 제거하거나 보관하기 위해 Convex 작업을 추가할 것입니다.
- **콘텐츠 전달 최적화:** 자주 액세스하는 파일의 경우 캐싱 전략을 고려하십시오. 아마도 Convex의 저장소에 특정 파일을 캐시하도록 지시하거나 CDN을 사용합니다. R2를 사용하는 경우 Cloudflare 캐싱이 내장되어 있습니다. 사용량이 많은 경우 매우 일반적인 공개 파일을 알려진 CDN으로 이동하거나 작은 경우 직접 포함할 수도 있습니다(예: 아이콘 또는 작은 이미지는 페이지에 Base64일 수 있음 – 그러나 더 큰 것은 아님).
- **다중 파일 업로드 및 폴더 구조:** 현재 각 파일은 별도입니다. 향후 사용자가 파일 배치를 업로드하거나 폴더와 같은 조직을 유지하려는 경우 "Folder" block 개념을 도입할 수 있습니다(edge를 통해 파일 block을 포함). 이는 파일 저장소를 변경하지 않지만 UI 그룹화를 추가합니다. edge의 아키텍처(contains edge)는 이미 이를 나타낼 수 있습니다. 따라서 확장은 UI 및 사소한 메타데이터에 관한 것일 수 있습니다(폴더 block과 같은).
- **파일 내 검색:** 향후 기능은 PDF 또는 텍스트 파일 내에서 검색하는 것일 수 있습니다. 이를 위해서는 텍스트 콘텐츠를 추출하고(OCR 또는 텍스트 추출 파이프라인을 통해) 인덱싱해야 합니다(Convex 또는 외부 검색 인덱스에서). 이는 고급 확장입니다. 수행되는 경우 인덱싱을 위해 파일 block의 숨겨진 필드에 추출된 텍스트를 저장할 수 있습니다. 파일 저장소와 콘텐츠 지식의 교차점으로 언급합니다.
