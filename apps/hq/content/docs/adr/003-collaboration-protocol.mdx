---
title: "ADR 3: Collaboration Protocol (ProseMirror OT, Step Batching, Conflict Handling)"
---

## Context

Multiple users need to **edit the same block or document in real-time**, seeing each other's changes instantly. We require a collaboration protocol that merges concurrent edits reliably. ProseMirror was chosen as the rich-text editing framework, and it comes with a collaboration module based on Operational Transformation (OT) in a centralized fashion.

<Callout type="info" title="Key Challenges">
  - **Ordering of changes** to avoid divergent states - **Network latency
  differences** between users - **Conflict resolution** ensuring changes are
  applied consistently for all users - **High-latency users** suffering from
  repeated OT rebases (changes rejected when someone else's edit got in first)
</Callout>

The protocol design must balance real-time responsiveness with fairness and consistency.

## Decision

<Callout type="info" title="Core Approach">
  **Use ProseMirror's centralized OT-based algorithm for collaborative text
  editing, enhanced with batched step commits on the server to reduce conflict
  thrash.**
</Callout>

### Architecture Overview

- We run a **single source of truth** for each document's state on the Convex backend (the "authority" in OT terms). Clients do not directly sync with each other peer-to-peer; all changes funnel through Convex.

- Clients use the ProseMirror collaboration plugin or our Convex-prosemirror integration. Each client maintains its own local version number of the document.

### The Collaboration Flow

1. **User makes an edit** → generates one or more ProseMirror Step objects
2. **Client optimistically applies** the step locally and sends it to the Convex function (`submitSteps`) along with the base version number
3. **Server checks the version:**
   - If steps' base version matches server's current version → **accept**, increment version, record steps, broadcast to other clients
   - If base version is outdated → **reject** the incoming steps
4. **Rejected client** fetches new steps it missed, uses ProseMirror to **rebase its unconfirmed steps** on top of the latest document state, then resends

### Step Batching

We implement **step batching** on two levels:

<Tabs items={["Client-Side Batching", "Server-Side Commit Batching"]}>
  <Tab value="Client-Side Batching">
    The client bundles multiple local steps into one submission if they occur in
    quick succession. ProseMirror's collab plugin already collects "unconfirmed"
    steps and can send them as one batch periodically. We tune this (e.g., send
    every 50-100ms or on text input pause) to reduce overhead and avoid flooding
    the server with single-character steps.
  </Tab>
  <Tab value="Server-Side Commit Batching">
    In the basic OT model, only one client's changes are accepted for a given
    document version and others get rejected to rebase – which can starve slow
    connections. **Our improvement:** If two sets of steps arrive nearly
    together on the server (both based on version N), we: 1. Choose one as the
    winner for version N+1 2. Immediately take the second and transform it
    against the first (using ProseMirror's step transformation logic) 3. Apply
    that transformed second set as version N+2 without a round-trip to the
    client In effect, the server does the rebase for the client and accepts both
    in sequence.
  </Tab>
</Tabs>

### Conflict Handling Policy

By default, if two users edit the same text region, the first edit that reaches the server will be applied; the second edit will be transformed. ProseMirror's OT ensures no document corruption, but the resulting text might intermix changes.

<Callout type="warn" title="Last-Write-Wins">
  Our policy is **last-write-wins** for overlapping text insertion/deletion
  conflicts. We do not implement semantic conflict resolution beyond what OT
  provides – both words typed at the same spot will appear (one following the
  other), and users can manually clean up if needed. The key is **all users see
  the same result**.
</Callout>

### Position Mapping

We use **ProseMirror's position mapping** to handle concurrent insert/delete adjustments. For instance:

- User A inserts a character at position 5
- Concurrently User B deletes characters 10-12
- When B's delete is applied after A, the delete positions are remapped (+1 offset) to account for A's insert

This ensures consistency across all clients.

### Backend Integration

Our Convex backend uses the **@convex-dev/prosemirror-sync** component as a foundation. This component provides:

- Server functions for submitting steps and snapshots
- Version checks and rebase instructions
- Proven implementation of ProseMirror's OT algorithm in Convex

We extend it to add the server-side commit batching described above.

## Rationale

We chose ProseMirror's OT-based collaboration because it is a well-established solution that fits our centralized backend model:

- **Centralized OT is simpler and consistent:** Unlike fully distributed OT, a centralized approach is "relatively easy to implement and reason about". A central authority allows using a linear history like in version control, with clients rebasing their own changes when needed.

- **Leverages ProseMirror's algorithms:** We avoid reinventing the wheel. ProseMirror provides the transformation logic and the collaborative plugin that manages unconfirmed vs confirmed steps.

- **Real-time performance:** OT with immediate local application of changes means users see their own typing without delay, and others' edits as soon as network allows.

- **Step batching for fairness:** We address the problem observed in high-contention editing sessions where a user with higher latency can become a "starving artist" with their changes constantly rejected.

- **Convex integration:** The existence of the Convex ProseMirror sync component significantly de-risks this approach with an out-of-the-box implementation.

## Alternatives Considered

<Tabs
  items={[
    "CRDT",
    "Pessimistic Locking",
    "Third-Party Services",
    "Last-Write-Wins",
  ]}
>
  <Tab value="CRDT">
    **CRDT (Conflict-free Replicated Data Types):** Using a CRDT-based editor
    (like TipTap with Y.js) was a strong alternative. CRDTs allow true
    peer-to-peer collaboration and offline edits merging without a central
    server ordering. However, integrating CRDT in ProseMirror would introduce
    heavy data overhead and complexity in our storage. We decided to stick with
    OT now and possibly switch to CRDT if offline capabilities are needed later.
  </Tab>
  <Tab value="Pessimistic Locking">
    **Pessimistic Locking:** Lock a block or section while a user is editing it
    to avoid conflicts entirely. **Rejected** because it severely hampers
    collaboration – users would have to wait turns or break documents into tiny
    locked sections. It doesn't match the freeform concurrent editing experience
    we want.
  </Tab>
  <Tab value="Third-Party Services">
    **Third-party collab services:** Firebase OT, ShareDB, or Automerge with a
    central relay. Adopting those would require replacing ProseMirror's editing
    behavior or bridging to it. Since ProseMirror already solved this within its
    ecosystem, adding another layer felt unnecessary.
  </Tab>
  <Tab value="Last-Write-Wins">
    **Do Nothing Special (last write wins):** Let Convex handle concurrent
    writes by last-write-wins without OT. This would be **disastrous** for text
    merging (lost updates, jumbled text) and is not a real solution for
    simultaneous editing.
  </Tab>
</Tabs>

## Implications

- **Server Load:** Every keystroke potentially results in a Convex function call and database writes. We mitigate this with client-side batching (fewer, larger step submissions). Convex's WebSocket reactivity and caching can handle many small writes.

- **Data Consistency:** Convex functions that modify documents must be **atomic** per document. Convex ensures consistency in its transaction model.

- **Client Complexity:** Clients need to maintain two sets of state: the optimistic local state and the confirmed server state. This is handled by the ProseMirror collab plugin.

- **Potential Merge Artifacts:** The OT algorithm doesn't attempt to semantically merge content. Documents might end up with odd artifacts (like both users typing the same word → appears twice). These are generally minor and can be edited out by users.

- **Integration with Non-Text Blocks:** For other block types (images, attachments), "editing" might mean something else. Those operations might use simpler strategies (e.g., last write wins for image metadata since such edits are rare).

## Expansion Path

<Cards>
  <Card
    title="True Offline Collaboration"
    href="/docs/adr/adr-002-versioning-strategy"
  >
    Integrate a CRDT-based approach like Yjs to support offline work. Each
    client could make changes without the server and later merge.
  </Card>
  <Card
    title="Federated Servers & Consensus"
    href="/docs/adr/adr-008-platform-boundaries-expansion"
  >
    Explore using consensus algorithms (like Raft or CRDTs) to maintain
    consistent ordering across distributed servers.
  </Card>
  <Card
    title="Intelligent Merge Assistance"
    href="/docs/adr/adr-008-platform-boundaries-expansion"
  >
    Introduce an AI assistant to help with conflict resolution – detecting when
    two users edit the same sentence differently and suggesting a merged
    version.
  </Card>
  <Card
    title="Comments & Suggestions"
    href="/docs/adr/adr-007-presence-cursors"
  >
    Add track changes or inline comments. Comments would be attached to ranges
    in the text and move accordingly as text changes using ProseMirror's
    mapping.
  </Card>
</Cards>

<Callout type="idea" title="Future Scaling">
  If we ever have hundreds of concurrent users on a single document, we may need
  to implement **region locking on demand** – not mandatory, but if a document
  is very busy, the system might automatically partition it (e.g., lock down a
  paragraph if too many people try to edit it simultaneously).
</Callout>
