---
title: "ADR 7: Presence and Cursors (Realtime User Awareness)"
---

# ADR 7: Presence and Cursors (Realtime User Awareness)

## Context

In a collaborative application, it's important to provide **user presence awareness**: seeing who else is online, viewing or editing the same content, and where their cursor or selection is. This not only helps avoid conflicts (e.g. you might avoid editing where someone else is typing) but also adds a sense of collaboration and social connection[[61]](https://stack.convex.dev/presence-with-convex#:~:text=Presence,%2520as%2520we%E2%80%99ll%2520use%2520the,in%2520a%2520Google%2520Doc,%2520etc). Features typically include: a list or avatars of users currently viewing/editing a document, indicators if someone is typing, and live cursors or highlights showing each user's position in the text. We want to implement this in our MVP to enhance the multi-user experience. Convex, our backend, has real-time capabilities but presence data has different characteristics: it's ephemeral (no need to persist long-term every cursor move) and high-frequency (cursor moves can be many per second). We need an approach that is efficient and doesn't overload the system, while still giving a smooth experience.

## Decision

**Implement a Convex-based presence system tracking each user's activity per document, with periodic heartbeats and lightweight cursor data, and display this info with minimal latency.** The main components are:

- **Presence Table:** We will create a Convex table, say presence, with entries keyed by (documentId, userId). Each entry contains fields like:
  - userId (or session ID if multiple sessions per user),
  - documentId (or could be blockId if presence is tracked at any block level; likely we track at top-level doc for editing context),
  - lastActive: number (timestamp of last heartbeat or action),
  - cursorPos: object (could be a representation of their current cursor/selection in the document),
  - status: string (e.g. "editing"/"online"/"idle", etc., or flags like isTyping: boolean).
- **Join/Leave:** When a user opens a document or collaborative editor, we will add or update their presence entry for that doc. When they leave (navigate away or disconnect), we should remove or mark them offline after a timeout.
- **Heartbeat Mechanism:** Each client will send a heartbeat (via a Convex mutation) every few seconds (e.g. every 5 sec as a default) to update lastActive. This is to signal they are still present[[62]](https://stack.convex.dev/presence-with-convex#:~:text=A%2520common%2520way%2520to%2520detect,resources%2520your%2520app%2520will%2520consume). We can optimize by piggybacking on other messages: for instance, if the user is actively editing (thus sending steps), that inherently updates presence, so separate heartbeat might be skipped during activity.
- **Reactive Query:** We will have a Convex query function that, given a documentId, returns all presence records for that doc (perhaps filtering out ones that are offline beyond a threshold). Because Convex queries are reactive, all clients subscribed to this query will get updates whenever any presence record changes[[63]](https://stack.convex.dev/presence-with-convex#:~:text=Reactivity). This means when someone new comes online or moves their cursor (if we update the table for cursor moves), others will know.
- **Cursors Handling:**
  - For text cursors: We need to represent the position in a way others can map onto their copy of the document. If all clients are in sync via ProseMirror OT, they share a document version. We could store the cursor as a position (index) in the document. However, due to live edits, an index can become stale quickly unless updated after each remote step. A robust solution is to use ProseMirror's position mapping: when broadcasting a cursor, attach it to a specific version or transform it through operations. This can be complex. Simpler MVP approach: if two people type in different areas, positions shift mostly for one end. We might accept slight inaccuracy or update cursors lazily after an edit.
  - We might integrate cursor with collab: for example, update cursor position in presence whenever the user's editor state changes (ProseMirror can provide a mapping from old to new positions after each step). We can also use strategies like storing a unique marker in the document for each cursor (some collab systems do this), but ProseMirror's collab plugin didn't natively include that.
  - Given time, MVP might opt for a simplified approach: track _which block or section_ a user is focused on rather than exact character. Or just track cursor index without perfect adjustment – in moderate editing scenarios, it will usually be near correct. We note that **indexing cursor positions in presence data is complex** because of concurrent edits[[64]](https://stack.convex.dev/presence-with-convex#:~:text=Text%2520cursors%2520are%2520an%2520important,it%2520at%2520that%2520for%2520now). We may limit exact cursors to when users are not actively editing.
  - Alternatively, for MVP, we may omit live text cursors and just show user highlights (like colored selection) when they select something, using ProseMirror's collaborative editing awareness if available.
  - For mouse cursors (if we wanted to show remote mouse pointers): that's quite high frequency and not essential for text editing. We will likely skip showing actual mouse position, focusing on text cursor/selection only. If we did, we'd not store every move in DB due to choppiness[[65]](https://stack.convex.dev/presence-with-convex#:~:text=For%2520mouse%2520cursors,%2520the%2520challenge,where%2520the%2520cursor%2520is%2520moving) and ephemeral nature[[66]](https://stack.convex.dev/presence-with-convex#:~:text=Sharing%2520mouse%2520cursor%2520positions%2520are,the%2520data%2520is%2520especially%2520ephemeral).
- **Frontend Display:** We'll show a "facepile" of user avatars on the document, possibly using the logic of grouping by online/offline and stable ordering (e.g., sort by join time to avoid shuffling)[[67]](https://stack.convex.dev/presence-with-convex#:~:text=A%2520%E2%80%259Cfacepile%E2%80%259D%2520is%2520a%2520popular,in%2520mind%2520when%2520building%2520them). Each user in presence can be displayed with a colored cursor or name label at their text position if possible. If multiple users, each gets an assigned color. We can reuse presence data (like an entry could have a color field assigned when they join, or we just pick color by hash of userId).
- **Latency Considerations:** Presence updates (like typing status or cursor) can be frequent. We will **rate-limit presence updates** to avoid spamming. For example, update cursor position at most, say, 5 times per second or on idle stop (if someone is dragging cursor, we don't need intermediate points). The Convex presence article suggests using **single-flight** (dropping intermediate updates if one is already in flight)[[68]](https://stack.convex.dev/presence-with-convex#:~:text=Presence%2520performance) to manage load. We can adopt that: essentially, if the user is moving the cursor rapidly, we batch updates or only send the latest.
- **Durability:** Some presence info we want ephemeral (cursor position doesn't need to be saved if everyone leaves). But some we might store longer: e.g., lastActive could be used to show "last online 5 minutes ago" if someone left. We will keep presence entries for some time after disconnect (or mark them offline). Possibly a separate table or reuse same but with status. Clean-up: We might have a cron that removes stale entries after, say, 24 hours of inactivity to keep table clean.
- **Typing indicator:** We can update a flag if user is typing vs just viewing. A simple approach: update status to "typing" when the user is actively entering text and set to "online" when not. We could detect typing by keypress events and then revert to normal if no typing for a couple seconds.

## Rationale

- **Social presence improves user experience:** As noted, seeing collaborators in real-time gives a sense of connectedness and prevents feeling like you might overwrite each other blindly[[69]](https://stack.convex.dev/presence-with-convex#:~:text=someone%2520is%2520composing%2520a%2520message,in%2520a%2520Google%2520Doc,%2520etc). It turns a static wiki into a lively workspace.
- **Convex is suited for presence:** Convex's real-time push and automatic invalidation means we can implement presence without setting up separate WebSocket channels manually. Just writing to a presence table and querying it uses Convex's reactive engine to broadcast changes to all in that room[[63]](https://stack.convex.dev/presence-with-convex#:~:text=Reactivity). This is simpler than a custom pub-sub. Also, Convex can handle frequent small writes in memory and only push last state thanks to single-flight mechanism (which batches rapid table writes)[[68]](https://stack.convex.dev/presence-with-convex#:~:text=Presence%2520performance).
- **Use of an established pattern:** The presence approach we choose is influenced by Convex's own example utilities[[70]](https://stack.convex.dev/presence-with-convex#:~:text=To%2520make%2520it%2520easy%2520to,in%2520rooms%2520they%E2%80%99re%2520allowed%2520in). They even provided a hook usePresence which we can mimic or use. It suggests storing partial updates and merging state per user easily[[71]](https://stack.convex.dev/presence-with-convex#:~:text=The%2520main%2520difference%2520is%2520that,will%2520have%2520the%2520latest%2520values). That pattern ensures that, for instance, if we update a user's cursor in one part and their typing status in another, we merge into one object per user, avoiding conflicts.
- **Cursor indexing challenges recognized:** We acknowledge that accurately sharing text cursor positions is a complex topic that might be beyond MVP's full scope[[64]](https://stack.convex.dev/presence-with-convex#:~:text=Text%2520cursors%2520are%2520an%2520important,it%2520at%2520that%2520for%2520now). We opt for a pragmatic partial implementation (maybe block-level presence or approximate indices) to still give some awareness. This decision not to fully solve it is backed by the Convex article noting it could be an entire post on its own, so we focus on simpler aspects first.
- **Ephemeral vs persistent trade-off:** Presence data is semi-ephemeral; we care about "now" and short-term history (like last seen). By storing in Convex (which persists by default), we do get durability for lastActive, which is useful for showing when someone was last online (if within a timeframe). But ephemeral parts like exact cursor moves we might not log in detail. We'll treat presence table as mostly current state that gets overwritten often, not a log of every movement. That's acceptable since slight misses aren't critical.
- **Alternative requiring separate infra unnecessary:** We could have used something like WebRTC or Y.js awareness for presence, but since we already have Convex open for collab, it's simplest to piggyback on it. Y.js has an awareness API, but adopting Y just for presence is heavy. Our solution uses what we have.
- **Scalability:** Presence data per document is relatively small (just one entry per user). Even if dozens of users, that's fine. The updates are frequent but small JSON writes. Convex's design of reactivity and caching ensures that, for example, if 50 users are online, the presence query recomputes only once per change and fan-out is handled efficiently[[24]](https://stack.convex.dev/presence-with-convex#:~:text=Caching). This helps scale to large collab sessions.

## Alternatives Considered

- **No presence indicators:** We considered deferring presence to later (to focus on core editing). But given modern expectations and the minimal effort to at least show online users, we chose to include it in MVP.
- **Polling instead of realtime:** We could have had clients poll for others' presence (e.g., query every few seconds). But that is less efficient and real-time. Convex's push obviates polling. So, we prefer push to get instant updates and lower latency.
- **Using an external pub-sub (like Pusher or Ably):** Not needed since Convex covers the basics. Those services might handle cursors at high freq slightly better if fine-tuned, but integrating another service is overkill and would duplicate what Convex already provides.
- **Full CRDT for cursors:** There are CRDT approaches to share cursors (each cursor as an item in a CRDT list). This seemed too complex to integrate just for this small feature. We left that aside.
- **Browser Peer Awareness:** Perhaps leveraging something like WebRTC broadcast for cursor positions to avoid server roundtrip. That would be complicated to orchestrate (especially with varying participant sets) and not justified at our scale. So we stick with server-mediated.
- **Only track presence, no cursors:** As an MVP of presence, we thought about just showing who's present and skip showing their cursor positions. But adding cursors (even approximately) greatly enhances the collab feeling (like Google Docs colored cursors). We decided to attempt it, and if it's not perfect, it's still useful. Worst case, we show a name label where they are editing last known location.

## Implications

- **Privacy:** In some cases, presence might raise privacy concerns (someone might not want others to know they are viewing a particular document). Since this is internal collaboration, likely fine, but we might later consider a "stealth mode" or similar if needed. For now, all presence is visible to those who have access to the document.
- **Potential Noisy Updates:** If we update presence too often (like every keystroke), it could overload things. We mitigate by batching and throttling. We should fine-tune the heartbeat interval and perhaps only send cursor changes on significant moves or after idle. We might use requestAnimationFrame or setInterval on client to limit frequency.
- **Consistency with Editor State:** If a user's connection is poor, their presence heartbeats might drop, and they could appear offline while still editing. We might choose a grace period (e.g., consider them online up to 10 seconds after last heartbeat)[[62]](https://stack.convex.dev/presence-with-convex#:~:text=A%2520common%2520way%2520to%2520detect,resources%2520your%2520app%2520will%2520consume) to avoid flicker. If they truly disconnect, after that we mark offline.
- **UI Overload:** If many users are present, showing dozens of cursors can be overwhelming. Possibly cap at showing, say, first 5 cursors and an "+n others" indicator. The data model can have all, but UI may simplify. We won't likely hit that in MVP testing, but something to note.
- **Conflict with Selection and Editing:** We need to ensure showing other's cursors does not interfere with local editing. Typically, these are rendered as decorations (e.g., in ProseMirror one can add a plugin to render remote cursors as decorations). We might integrate such a plugin that uses our presence data. If not, we do manual highlighting by overlaying colored caret elements at approximate positions in the DOM. This is an implementation challenge but known territory (ProseMirror has examples in collab module for cursors).
- **Use of Colors and Identity:** We should ensure each user gets a consistent color per document session. Possibly hash userId to a color or keep an in-memory map. If needed, store the color in presence table (the first one online picks a color and writes it, others read it). The Convex presence utility code shows an example of using emojis or so for facepile, but we'll likely do colored circles or avatars.
- **Interference with Convex Auth Session:** If Convex uses session cookies, multiple tabs of the same user might show up as separate presence entries unless we unify by userId. We might consider each tab a separate presence or merge them. Merging could cause flicker (like if one tab idle but another active). We likely treat each userId as one presence per doc, regardless of tabs. So if user opens doc in two tabs, either they appear once (with lastActive from either tab) or we differentiate by session. Simpler: one per user per doc – update on any activity from any tab. Achieved by using userId as key (the utility used a random ID per client if not logged in, but with auth we have stable).
- **Data Cleanup:** If a user closes a doc without explicitly logging out or calling an API, our heartbeat mechanism will eventually mark them offline (when heartbeats stop and lastActive ages out). We could also use the browser page unload event to inform the server (but that's unreliable and not guaranteed to run). We'll rely on timeout.
- **Integration with Permissions:** We should ensure presence doesn't leak info about restricted docs. Only users who have access to a doc will subscribe to its presence. So if you don't have doc access, you won't see presence of it, obviously. But consider if a doc is open and someone without access tries to see who is in it – they can't query that presence without auth to doc anyway. So fine. Another angle: if a doc becomes restricted (user removed) while they have it open, ideally their presence entry should be removed or hidden. If permission changes, our queries might now filter them out; or we could remove their presence entry as part of revoking access (kick them out). That might be an advanced scenario; MVP might not handle dynamic permission changes elegantly (someone could theoretically still see content until they refresh and get denied).
- **"Last seen" feature:** We have lastActive timestamps; we could show "Bob was last online 3 minutes ago" on contacts or on each document's share list. This is a nice-to-have possibly later. The data is there. We might just keep it around.
- **Cross-document presence:** We might also want to show a global status (user is online somewhere). We can derive that by looking at all presence or having a separate user status table (like user's general last seen). Convex presence example likely covers global online status too. If needed, we could extend presence system to mark user online globally (maybe update a user table on any activity). Not prioritized, but possible extension (like a "green dot" next to user name globally if any presence entry of them is active).
- **Notification tie-ins:** If we know who is present, we could avoid sending them notifications (like email or push) for changes because they already see it. That could be a future optimization using presence info.
- **Agent/AI Presence:** If we have AI agents participating (for example, an AI "co-scientist" might join a doc to make suggestions), we could also reflect that in presence ("AI Bot is online"). This could be interesting to signal when an agent is working on that content. We'd implement it by having the agent's processes update presence just like a user. The architecture supports it as long as agent has an ID.

## Expansion Path

- **Precise Collaborative Cursors:** Implement a robust solution for tracking text cursors through document changes. Possibly use ProseMirror plugin that broadcasts cursor positions mapped to a specific version, and server stores it with version reference. If we adopt Y.js in future, its awareness API could manage cursors with automatic CRDT mapping. Also, if ProseMirror's collab plugin had a recommended approach, follow that (maybe by embedding a special marker nodes or using the example code from Marijn which mentions mapping positions via position maps for cursor adjustment).
- **Selections and Annotations:** Expand from single cursor (caret) to full text selections (range). We could show if someone has a chunk of text highlighted (useful in editing or when discussing text). This would require storing start and end positions in presence data. It's a natural extension once single position works.
- **Multiple Presence Scopes:** Right now presence is per document. We might generalize it to other scopes too: e.g., presence in a project or on the platform in general (like an online users list). The infrastructure can handle multiple room IDs (documentId being the room). We could implement another presence query for "global" or per space. This might be useful if we want to show a global "online now" list.
- **Activity Indications:** Possibly extend presence to show more detailed activity, e.g., "Alice is editing Title block" or "Bob is commenting". This could be an extension where presence entries include a short description of current activity. The client could update that contextually.
- **Integration with Chat or Comments:** If we add an in-app chat or commenting system, presence could tie in (like show who's typing a comment, etc.). We might either extend the presence schema or run separate presence for chat channels. But conceptually similar.
- **Scale Considerations:** If in some scenario a document is public and hundreds of people view it, our presence system might be strained (lots of entries and updates). We might need to optimize by not tracking every single viewer in real-time if count is huge (maybe just count them or sample). Or partition presence updates (like only track editors, not passive viewers, if needed). Or throttle frequency more for large N. This is a future scale problem.
- **Mobile or Low-bandwidth Mode:** In some cases, a user on a poor connection might want to disable live cursors to save bandwidth. We could have an option to turn off receiving those updates (just unsubscribe from presence query, or have server send minimal). Not a priority but worth noting as a user setting maybe.
- **Storing Historical Collaboration Data:** Though presence is ephemeral, one might want to record collaboration events (for analytics, e.g., how many simultaneous editors, peak times). We could push presence changes into a log for analysis. Or at least count minutes of active editing by user (which could be derived from heartbeats). This is beyond MVP but a potential metric (for engagement analytics or user behavior study).
- **Integration with Workflow (Mastra):** If an agent (Mastra) is assisting, perhaps it could use presence information to decide when to intervene (e.g., if user is actively typing, maybe don't distract them with suggestions). So we could expose presence data to the agent logic or to other parts of system as needed. This just means presence is a known global state accessible via queries to any function/agent.
- **UI Animations and Polish:** We can further refine how we show presence, e.g., smoothly animate cursors moving if updates are sparse (interpolate positions). Also, showing typing indicator (like "... is typing" next to name) when status=typing. Or small pop-ups when someone enters/leaves the doc ("Alice joined"). These are UX touches to consider as we refine the feature set beyond MVP core functionality.
