---
title: "ADR 5: File Storage and Access Control (Convex File Storage + Files Control)"
---

# ADR 5: File Storage and Access Control (Convex File Storage + Files Control)

## Context

The knowledge system will include **file attachments** – images, PDFs, data files, etc. We need to allow users to upload files and embed or link them in blocks. Key requirements are: handling potentially large binary files, efficient delivery (possibly via CDN), and **access control** so that private files aren't accessible to unauthorized users. Since we're using Convex as our backend, we aim to use its provided capabilities for file storage to streamline development. Convex offers an integrated file storage solution and there is a Convex component called _Files Control_ that provides a higher-level API for secure file handling. We must decide how to integrate this for MVP, ensuring that uploading and retrieving files is seamless and secure in our app's context.

## Decision

**Utilize Convex's built-in File Storage with the Convex Files Control component to manage uploads, downloads, and file permissions.** We will treat files as a special kind of content stored outside the main database (binary storage), referenced by IDs in our Block model. Key points of the implementation:

- We install and configure the @convex-dev/files (or the third-party convex-files-control) component in our Convex backend. This provides server functions for generating upload URLs, finalizing uploads, and creating download URLs with access checks[[29]](https://www.convex.dev/components/files-control#:~:text=Convex%2520Files%2520Control)[[30]](https://www.convex.dev/components/files-control#:~:text=*%2520Two,for%2520presigned%2520or%2520HTTP%2520uploads).
- **Uploading files:** We use a two-step upload process:
  - The client requests an upload URL from Convex by calling a mutation (wrapping the component's generateUploadUrl). This returns a one-time **pre-signed URL** and an uploadToken[[31]](https://www.convex.dev/components/files-control#:~:text=//%2520Client,).
  - The client then uploads the file directly to Convex storage via HTTP PUT to that URL (bypassing our app server for the heavy binary transfer). Convex returns a storageId if successful[[32]](https://www.convex.dev/components/files-control#:~:text=const%2520,json).
  - The client calls a Convex mutation (wrapping finalizeUpload) with the uploadToken and storageId to confirm the upload[[33]](https://www.convex.dev/components/files-control#:~:text=const%2520result%2520=%2520await%2520finalizeUpload\(,1000,). In our wrapper, at this point we create a Block of type "file" in our blocks table linking to this storageId. We also pass an initial access control list for the file: by default, the uploader's user ID is given access[[34]](https://www.convex.dev/components/files-control#:~:text=const%2520,). The Files Control component handles associating that user's ID (subject) as an access key on the file record[[35]](https://www.convex.dev/components/files-control#:~:text=const%2520result%2520=%2520await%2520ctx,).
- **Serving files:** We do not serve files through Next.js; instead, we will generate secure URLs for file access:
  - For inline images in content, we'll need a public URL. The Files Control includes an optional HTTP router we can enable to serve files through a path (e.g. https://<convex-site>/files/download?token=XYZ). We will likely enable the download route[[36]](https://www.convex.dev/components/files-control#:~:text=A%2520Convex%2520component%2520for%2520secure,plus%2520a%2520React%2520upload%2520hook)[[37]](https://www.convex.dev/components/files-control#:~:text=//%2520convex/http.ts%2520import%2520,generated/api) and use Convex's built-in auth hook to ensure only authorized requests succeed[[38]](https://www.convex.dev/components/files-control#:~:text=checkUploadRequest:%2520async%2520\(ctx\)%2520=,Type%2522:%2520%2522application/json%2522%2520%257D,%2520%257D\);)[[39]](https://www.convex.dev/components/files-control#:~:text=//%2520Optional:%2520provide%2520accessKey%2520for,).
  - Alternatively, we can use the buildDownloadUrl function to create time-limited URLs on demand[[40]](https://www.convex.dev/components/files-control#:~:text=import%2520,control). For example, when displaying an image, the app can request a URL for it, which will embed a short-lived token. This way, even if someone finds the URL, it expires (and if requireAccessKey is on, it won't work without being logged in)[[41]](https://www.convex.dev/components/files-control#:~:text=).
- **Access control:** Each file stored in Convex has an associated set of **access keys** (just like blocks will have ACL). By default, we use user IDs as access keys. The Files Control component provides mutations to add or remove access keys for a file[[42]](https://www.convex.dev/components/files-control#:~:text=Access%2520keys%2520are%2520normalized%2520,empty%2520value). We will integrate this with our block permissions (ADR 6) such that if a file block is shared with a user or made public, we call addAccessKey for that file's storageId for the appropriate user IDs or a special "public" key. Conversely, if permissions are revoked, we remove keys. This ensures that when a user tries to download a file, the component's hasAccessKey check can verify they're allowed[[43]](https://www.convex.dev/components/files-control#:~:text=Access%2520keys%2520are%2520normalized%2520,empty%2520value).
- **Embeds and thumbnails:** For user convenience, we'll support directly embedding images in content. We may use an <img> tag whose src is the secure URL from above. For PDFs or other files, we might show a link or allow downloading. We'll rely on the browser or a viewer for actual rendering. If necessary, we could generate image thumbnails, but that's beyond MVP (and could be done via a separate service).
- **Storage backend:** Convex storage by default uses its own backing store (likely S3 under the hood). The Files Control component also supports Cloudflare R2 as an option[[36]](https://www.convex.dev/components/files-control#:~:text=A%2520Convex%2520component%2520for%2520secure,plus%2520a%2520React%2520upload%2520hook). For MVP, we can use Convex's default (quick to start). If we expect heavy file usage or want to reduce costs, we could configure R2. The decision here is to stick with Convex-managed storage, possibly switching to R2 in production if needed by just providing credentials (the component's API supports both seamlessly).
- **Cleanup and retention:** We will use the component's built-in cleanup functionality. It provides a cron job to delete expired files and unused upload tokens[[44]](https://www.convex.dev/components/files-control#:~:text=Cleanup). We will schedule this (the example shows a Convex cron that runs hourly to clean expired uploads and grants)[[45]](https://www.convex.dev/components/files-control#:~:text=Use%2520,it%2520in%2520a%2520cron%2520job). We'll ensure to set appropriate expiration for any one-time links or temporary data. By default, if we don't specify an expiresAt for a file, it might live indefinitely. We might not use expirations on the files themselves (unless we want auto-expiry), but we will on ephemeral download links.
- **File metadata:** We will store file metadata (filename, size, content type, etc.) in our own blocks table or a separate filesMeta table. The Files Control example suggests storing your own file record after finalizeUpload[[46]](https://www.convex.dev/components/files-control#:~:text=). We'll do that: e.g., create a block of type "file" with fields like fileName, fileSize, contentType, and the storageId. This allows us to display file info in the UI and search it if needed. The storage itself is opaque (just an ID for retrieval).
- **Large file considerations:** The presigned upload approach means files don't go through our server, which is good for large files. Convex likely has an upper limit per file (maybe ~5GB or so; not documented here). We will enforce a reasonable size limit on uploads at the app level (maybe a few hundred MB for MVP, configurable). If needed, we could split files or compress images on client side, but not initially.

## Rationale

Using Convex's file storage and Files Control component is a pragmatic choice:
- **Integrated Security:** The Files Control module is designed to enforce access control on file URLs, preventing unauthorized downloads[[36]](https://www.convex.dev/components/files-control#:~:text=A%2520Convex%2520component%2520for%2520secure,plus%2520a%2520React%2520upload%2520hook)[[47]](https://www.convex.dev/components/files-control#:~:text=Access%2520keys%2520are%2520not%2520placed,consumeDownloadGrantForUrl). It generates one-time tokens and handles expiration. This saves us from implementing our own signing mechanism. For example, we can easily create a password-protected file link or a link that only works N times via the provided API if needed[[48]](https://www.convex.dev/components/files-control#:~:text=Set%2520,to%2520return%2520an%2520access%2520key)[[49]](https://www.convex.dev/components/files-control#:~:text=const%2520grant%2520=%2520await%2520ctx,passphrase%2522%2520%257D,).
- **Development Speed:** It's much faster to leverage this existing component than to set up our own S3 and write lambdas to sign URLs, etc. The component even gives us React hooks for upload which simplifies the frontend integration[[50]](https://www.convex.dev/components/files-control#:~:text=React%2520hook)[[51]](https://www.convex.dev/components/files-control#:~:text=//%2520Presigned%2520await%2520uploadFile\(,).
- **Consistency with Convex:** By keeping file handling within Convex's ecosystem, we maintain a single source-of-truth for both data and files. Convex's reactivity might even let us react to file metadata changes (though files themselves are static content). It also means deployment and environment config is simpler (no separate file server).
- **Scalability and CDN:** Convex's approach (especially if using R2 or their default) likely delivers files via a CDN or at least efficiently. The *.convex.site URLs are optimized for delivery. If using R2, Cloudflare's CDN is automatically in play. This means good performance for users fetching files, without us manually configuring a CDN.
- **File Lifecycle Management:** The component's inclusion of cleanup for expired files and the ability to set an expiry on each file is valuable. For example, if we allow users to upload intermediate files or image previews that should auto-delete, it's straightforward. Also, if a user deletes a file block, we should consider removing the file from storage to save space. The component's deleteFile (via cleanUp.cleanupExpired or direct calls) can be used.
- **Comparison to alternatives:** Using something like AWS S3 directly would require setting up signed URL generation (either via AWS SDK or cloud function), managing bucket permissions, and a separate credential set. The Convex component wraps all that, and using it keeps our stack homogeneous. Also, since Convex is already part of our app, we avoid cross-service complexity (like needing a separate backend just for file upload logic or CORS issues with S3).
- **Example and Precedent:** The Files Control component is relatively new but appears to be a recommended approach by Convex (since it's listed as a Convex component). The feature set covers our needs: presigned upload, secure download, access key management[[36]](https://www.convex.dev/components/files-control#:~:text=A%2520Convex%2520component%2520for%2520secure,plus%2520a%2520React%2520upload%2520hook)[[52]](https://www.convex.dev/components/files-control#:~:text=Access%2520control%2520&%2520queries). Adopting it follows the "convention" for Convex apps dealing with files, reducing risk.

## Alternatives Considered

- **Direct File Embedding:** One idea is to store small files (like images) directly in the Convex database as binary data (e.g., base64 in a block). This was rejected because it would bloat the database and slow queries. Convex's file storage is meant for binaries; using it is more efficient than embedding in blocks.
- **External Storage (S3/GCS) without Convex integration:** We could have used AWS S3 or Google Cloud Storage directly, writing our own backend endpoints to sign URLs. While feasible, it means more boilerplate and ensuring those endpoints are secure. We also lose the tight integration with Convex's auth. We decided the slight vendor lock-in to Convex's file system is acceptable for MVP given the time saved.
- **Serving via Next.js (hosting files on Vercel):** For small media, we could import them into Next.js public folder or use Vercel's built-in storage for static assets. That doesn't work for user uploads, since those are dynamic and would require rebuilding the app or an API to serve. Vercel has no built-in binary store for user uploads – one would still need to push to an external store. So this was not a real solution.
- **Peer-to-peer or IPFS:** Unorthodox but considered given "knowledge system" vibe – using IPFS or similar to store files decentralized. Not appropriate for MVP due to complexity and lack of fine-grained access control (everything on IPFS is public). We need straightforward, private file storage, which Convex provides.
- **No File Support:** Theoretically we could launch MVP without file attachments. But that severely limits the utility (users often need to add images or PDFs). We judged file support as a necessary feature of the knowledge platform MVP.

## Implications

- **Auth Integration:** We will use Convex Auth (likely using OAuth providers or email login) to identify users. The file access keys rely on the user's identity.subject (unique user ID)[[53]](https://www.convex.dev/components/files-control#:~:text=handler:%2520async%2520\(ctx,%2520args\)%2520=,Unauthorized)[[54]](https://www.convex.dev/components/files-control#:~:text=,Unauthorized). We must ensure every file operation is tied to an authenticated user. So we'll require login for uploads and downloads (for private files). Public files can be handled by using shareable links that bypass auth but those we'll only generate intentionally. We need to be careful to never leak a raw storage URL without a token.
- **App Size / Bandwidth:** Handling files means potentially large data transferring. We need to keep an eye on cost (Convex or R2 bandwidth costs, Vercel edge function usage if any). If users upload very large files frequently, it could be an issue. We might impose file size limits and encourage compression (like large videos might not be allowed).
- **Content Security:** Our system doesn't inherently virus-scan or moderate file content. For internal usage this might be okay; for a public platform, might need to integrate virus scanning or content moderation on images. For now, we assume trust among users or scope that out of MVP.
- **Backup and Data Persistence:** Files stored in Convex presumably are persisted redundantly by the service, but we should verify. If we ever need to migrate away from Convex storage, we'd have to copy files out using the storageIds (maybe via an export script). Slight lock-in: files are not as easily migrated as data in code (though we can always write a script to fetch all and upload elsewhere).
- **User Experience:** Uploading via presigned URLs can be a bit less straightforward than a direct form post, but our use of the React hook (useUploadFile) should hide complexity[[50]](https://www.convex.dev/components/files-control#:~:text=React%2520hook)[[51]](https://www.convex.dev/components/files-control#:~:text=//%2520Presigned%2520await%2520uploadFile\(,). We must ensure to provide progress feedback in UI (the hook likely gives progress events or we can tap into the fetch progress). Also, when an upload finishes, we should handle showing the file block (perhaps the finalizeUpload mutation returns the new block's ID).
- **Filename and URL hygiene:** The download URLs we generate can include the original filename for user convenience (the buildDownloadUrl allows specifying a filename param for content-disposition[[55]](https://www.convex.dev/components/files-control#:~:text=)). We should do that so downloads have correct names (e.g., "report.pdf" instead of a random ID). Also, our system should handle filename collisions or sanitization (the file component likely handles unsafe characters).
- **Managing File Access with Block Sharing:** We need to keep file ACL in sync with block ACL. If a user shares a document containing an image with someone, the image file must also become accessible. This implies that our share logic (ADR 6) on blocks will include: if making a block (or its parent doc) available to a user, iterate through any file blocks inside and call addAccessKey for those files as well. Conversely, if revoking access, remove keys. This coupling means more code but is necessary for security. Alternatively, for convenience, we might decide that _all files inherit the permissions of their parent block (document)_. We can enforce that by always giving any user who can see a file block the access key. A future optimization might be grouping files by project or using tenant IDs as access keys (the component allows arbitrary strings as keys, not just user IDs[[56]](https://www.convex.dev/components/files-control#:~:text=Access%2520keys%2520are%2520normalized%2520,empty%2520value)). For now, user IDs suffice.
- **Expiring Links vs Direct Auth Check:** The Files Control can either use expiring tokens in URL or require that the request include an auth token (if requireAccessKey is true)[[41]](https://www.convex.dev/components/files-control#:~:text=). If we use the built-in HTTP route, since it's on the Convex domain, we might leverage the user's Convex auth session cookie (if exists) to authenticate download requests. This is convenient (no need to generate tokens for internal use). However, in embedded images (on a webpage), using a session cookie might not work due to cross-origin issues (our app domain vs convex domain). So using tokenized URLs might be simpler for images. We will likely generate short-lived URLs for images so they can be fetched without user cookie (the token in URL suffices). This is a trade-off: token in URL can be copied and used by others until expiry. But if short (say 5 minutes) and continuously refreshed (like re-fetch on access), it's reasonably secure.
- **UX of Public Files:** If we eventually allow truly public blocks, their attached files need public access. The component supports generating a **shareable link** (which essentially marks the file as accessible without auth)[[57]](https://www.convex.dev/components/files-control#:~:text=Shareable%2520links). We would use shareableLink: true on a download grant to serve publicly. This means if a block is published publicly, we can mark its files as shareable. We'll document this and ensure to only do so when intended.

## Expansion Path

- **Image Thumbnails and Processing:** Down the line, we might integrate an image processing step. For instance, generating a smaller thumbnail for large images to display in previews. Convex doesn't natively process images, but we could integrate a third-party (or possibly use Vercel Edge Functions) for that. Alternatively, use the **AI/ML** capabilities: e.g., if we had an AI pipeline, generate text from images or vice versa. This is beyond MVP. If needed, we could store multiple versions of an image (original and thumbnail) under different storageIds.
- **Video and Audio Handling:** If the system later supports multimedia (videos, audio), we might offload to specialized services for encoding/streaming (like Mux or Cloudinary). But in architecture terms, we'd treat it similarly: store file and maybe store a link to a streaming URL. Integration with those could be a future ADR.
- **Large Data Files and External Integration:** Researchers might upload dataset files. If these get very large, Convex's storage might not be cost-effective. We might integrate with user's own cloud or institutional storage (like link to Google Drive or S3 bucket). That complicates unified access control, but we could store reference links instead of the actual file. In expansion, we might allow blocks of type "external_file" that just hold a URL (and maybe an authentication token if needed). The decision for MVP is to actually store files, but we remain open to linking instead for huge content.
- **Public File Repository:** If we open parts of the knowledge base publicly, we might want to serve certain files more directly or via static hosting. Perhaps we could offload all public images to a static site/CDN for performance. This could be an automated process: if a block is marked public, copy its file to a public bucket and use a public URL. That way, we don't strain Convex for heavy public traffic. The architecture can support this: we'd maintain the storageId for internal use and a publicURL field if exported. This is optimization for scale.
- **File Versioning:** Currently, if a user updates a file (e.g., replaces an image), we'd likely treat it as a new file with a new block, and maybe mark the old one deleted. We might consider allowing version history on files too (like older attachments). For MVP, not needed. In the future, an ADR could specify that updating a file block keeps the same block id but points to a new storageId, and we keep the old storageId in history (or as an older version).
- **Encryption:** For highly sensitive data, server-side checks might not be enough; end-to-end encryption could be desired (only clients with keys can decrypt files). This is non-trivial and not in scope for MVP, but our architecture could be extended: we could encrypt files on upload and store the key in a secure place per authorized user. This would impact how downloads work (need client-side decrypt). Not likely needed unless dealing with very private research data, but worth mentioning as a possible future enhancement if security requirements heighten.
- **Integration with Workflow/Agents:** If we have background processes or agents (see ADR 8) that produce files (like an AI that generates a report PDF, or a workflow that collects data and stores a CSV), we can integrate them by having those processes use the same file storage mechanism. Convex scheduling could generate a file and use the same finalizeUpload with an appropriate access key. Our consistent approach to file storage means even automated content goes through the same pipelines, simplifying maintenance.
- **User Quotas and Cleanup:** As usage grows, we might implement user-level storage quotas to prevent abuse (especially if this becomes multi-tenant or public). The architecture can handle it by checking a user's total file sizes before allowing new upload. Also, a more aggressive cleanup for unused files (if a file block is deleted, delete the file content immediately rather than just marking expired). We'd likely add a Convex job to remove or archive file content when no referencing block exists.
- **Content Delivery Optimization:** For frequently accessed files, consider a caching strategy. Perhaps instruct Convex's storage to cache certain files or use a CDN. If using R2, Cloudflare caching is built-in. If heavy usage, we might move extremely common public files to a known CDN or even embed them directly if small (for example, icons or small images could be Base64 in the page – but larger ones no).
- **Multi-file Uploads and Folder Structures:** Currently, each file is separate. In future, if users want to upload a batch of files or maintain a folder-like organization, we might introduce a concept of a "Folder" block (which contains file blocks via edges). This doesn't change file storage but adds UI grouping. The architecture of edges (contains edges) already can represent that. So expansion might be more about UI and minor metadata (like a folder block).
- **Search in Files:** A future feature could be searching within PDFs or text files. That would require extracting text content (via an OCR or text extraction pipeline) and indexing it (maybe in Convex or an external search index). This is an advanced expansion. If done, we might store the extracted text in a hidden field of the file block for indexing. We note this as it intersects file storage with content knowledge.
