---
title: "ADR 6: Permissions and Embargo Model (Block-level ACL with Time Locks)"
---

# ADR 6: Permissions and Embargo Model (Block-level ACL with Time Locks)

## Context

We need a **permissions model** to control who can view or edit content, as the system may contain private or sensitive knowledge. Additionally, the notion of an "embargo" is introduced – content that should remain hidden or read-restricted until a certain time (common in research or media to prevent premature disclosure). Our MVP is not federated, so we can assume a single tenant or organization context for now, but we still need to differentiate access between users (and possibly roles) within that context. For example, certain blocks might be private to their author, others shared with a team, and others fully public. We want to enforce these rules at the block level, since our content model is block-granular (ADR 1). Embargo suggests a **time-based access control** aspect, where a block might automatically become visible after a timestamp[[58]](https://jumpcloud.com/it-index/what-is-time-based-access-control#:~:text=Time,based%2520on%2520predefined%2520time%2520constraints).

## Decision

**Implement block-level Access Control Lists (ACLs) combined with optional time-based embargo restrictions.** Concretely:

- Every Block in the blocks table gets a permissions field, likely called acl or access. For MVP, this can be a simple structure: for example, access: { readers: string[], writers: string[], public: boolean, embargoUntil?: Date }. We can simplify further to just a set of allowed user IDs and a flag for public visibility. We'll also include an owner for each block (usually the creator's user ID) which always has full access.
- **Read Access**: To retrieve or subscribe to a block (and its content/edges), the requesting user must be either listed in the block's allowed list or the block is marked public. Otherwise, the Convex query will not return that block (or the function will throw an authorization error). This check will be built into all our query functions that fetch blocks. Convex doesn't automatically enforce row-level security, so our code will do it.
- **Write Access**: Similarly, modifications (edit text, add child, etc.) require the user to be either the owner or explicitly in a writers list (if we maintain a separate one) or in a role that permits editing. For MVP, we might treat write access as having the same list as read (i.e., shared users can both read and edit by default). We can refine that with separate lists if needed.
- **Public Blocks**: A block marked as public: true is viewable by anyone, including unauthenticated users (if the app supports anonymous access). For now, we might restrict to authenticated users anyway, but public could bypass user-specific check. In the future, public means we might expose it without login (e.g., via a public URL).
- **Inheritance**: We decide that permission is primarily per block. However, to ease management, blocks that are part of a larger document or project should inherit or be automatically assigned the parent's permissions by default. For example, if you share a document block with Alice, all its child blocks should become visible to Alice as well. We will implement this by a propagation mechanism: when setting ACL on a parent, cascade it to descendants (or at least ensure our queries treat possession of parent access as implying child access). A simpler approach: always check up the containment chain – if a user has access to an ancestor block, allow access to the block. This requires queries to possibly join up the tree. Instead, we might explicitly propagate for performance. MVP can assume that content is primarily shared at a document (top-block) granularity to simplify (we can enforce that sharing toggles on top-level blocks and auto-applies downward).
- **Embargo**: We add an embargoUntil timestamp on blocks that need it (only certain types, e.g., a research result block that shouldn't be public until a publish date). The semantics:
  - If embargoUntil is a future time, then until that time passes, treat the block as if it were not shared publicly (and possibly even restrict it from certain collaborators if needed). We likely implement embargo as an override: e.g., a block could be marked public but with a future embargo – meaning it will _become_ public at that time, but until then only visible to its owners or a small group.
  - We could also use embargo for internal staging: maybe share with collaborators but embargo from wider group.
  - We will enforce embargo in the read check: if now < embargoUntil and the requesting user is not in a special allow list (perhaps the owner or explicitly allowed even during embargo), we deny access even if it would otherwise be allowed by ACL. Essentially embargo is a time lock that trumps other settings.
  - Once the embargo time passes, the block's status flips to normal (for example, if it was intended to be public, it becomes accessible to all logged-out or all users).
- **Administration**: Possibly, designate some users as admins who can override permissions. For MVP, we can keep it simple: maybe all users in the system can create and share their blocks, no strict admin role. If needed, we treat the first user or certain emails as admin who can see all (but that's optional).
- **Implementation details**:
  - On block creation, we set default ACL: usually owner has it in allowed list, and maybe no one else (private by default). If the block is created inside a shared document, we'll immediately assign the parent's ACL to it.
  - We'll provide mutations to share a block: e.g., shareBlock(blockId, userId) which adds that user to the block's readers (and maybe writers). For bulk sharing (like share a whole doc), it will traverse children and add them too (unless we rely on parent inheritance logic).
  - Another mutation might be setPublic(blockId, true/false) to publish or unpublish a block.
  - For embargo, a mutation setEmbargo(blockId, timestamp) to schedule releasing. Possibly also liftEmbargoNow if needed.
  - We will utilize Convex's cron jobs for embargo: e.g., a cron can run every hour or minute to find blocks whose embargoUntil has just passed and flip their public flag or notify owners. Alternatively, we can simply check at read time; but for convenience, we might proactively change a block's state at embargo expiry. For example, if a block was embargoed but intended public, we might set public:true at the moment embargo passes. This can be done with a scheduled job if precision is needed (Convex scheduling can do hourly or daily checks[[59]](https://www.convex.dev/components/files-control#:~:text=import%2520,generated/api), but not sure about to-the-minute scheduling without custom logic; possibly we schedule an individual job via workflow, if supported).
  - The Files Access (ADR 5) will tie in: when a block's ACL changes, we call file permission updates accordingly. Also, if a block is embargoed, its files should effectively be embargoed (not accessible via shareable link until time passes). We can handle that by not generating public links for them until embargo lifts.
  - We consider **Time-limited access** (embargo is one type, but maybe we also consider expiry of access). For MVP, embargo covers the main time factor (start time of access). We won't implement auto-expiry of access (like "user can see this until date X") unless needed. But the infrastructure could handle it similarly by a cron removing user from ACL after a time.

## Rationale

- **Fine-grained control:** Block-level ACL means any piece of information can be separately secured. This matches our block model: if you embed a confidential note inside a public document, you could technically restrict that block. (Though for UX, we might simply not allow that because it complicates reading a doc – better to keep blocks in a doc uniform. But the capability is there if needed.)
- **Simplicity for MVP:** We favor a straightforward allow-list approach over complex role-based permissions. Each block carries an explicit list of who can access. This is easy to check and reason about. It's analogous to Google Docs style sharing – each doc (block) has a list of permitted users or a public flag. We don't have to implement separate group objects or roles at MVP (everyone is basically an individual or "all").
- **Support for Team Collaboration:** Even in MVP single-tenant, not everyone sees everything. Researchers might have personal notes (private blocks) and team projects (shared blocks). The ACL model supports that easily. It's also flexible enough that if we later introduce groups, we could treat a group as an "identity" in the allowed list (just an entry that we resolve to multiple users).
- **Embargo as Time-Based Access Control:** Time-based access control (TBAC) is recognized as useful for enforcing release times[[58]](https://jumpcloud.com/it-index/what-is-time-based-access-control#:~:text=Time,based%2520on%2520predefined%2520time%2520constraints). By including embargoUntil, we automate what might otherwise be manual. For example, if a paper is under embargo until publication date, the user could mark it so. The system will then not show it to others (or not make it public) until that date passes, at which point it can automatically appear. This prevents human error (accidentally sharing too soon) and saves the user from waking up at midnight to flip a switch – the system does it.
- **Convex fit:** Convex's security model is mostly in userland – we write the checks. It gives us full flexibility to implement ACL our way. We prefer that over something like attaching policies in an external service. Within our Convex functions, ctx.auth.getUserIdentity() gives us the user performing the request[[53]](https://www.convex.dev/components/files-control#:~:text=handler:%2520async%2520\(ctx,%2520args\)%2520=,Unauthorized). We then simply filter or throw if not in allowed list. This straightforward approach means minimal performance overhead and complexity (just checking a list).
- **Alternatives complexity vs benefit:** More elaborate systems (like full Role-Based Access Control with roles and permissions on operations) seemed overkill. Our approach covers the basics: who can read, who can write, and time gating. It's similar to how Notion or Coda handle sharing (block or page level sharing to people).
- **Ensuring minimal friction:** We want users to be able to share content easily without needing an admin to configure roles. So users can directly add someone's email (user ID) to a block's ACL if they have rights. This decentralized sharing improves collaboration. Meanwhile, having an embargo option built in will appeal to use cases like pre-publishing research or time-sensitive announcements.

## Alternatives Considered

- **Document-Level Permissions Only:** We thought about simplifying to only top-level documents have ACL, and all their child blocks inherit that fully (no per-block differences). This is actually likely how users will commonly use it (share entire doc or not). Enforcing that rule would simplify enforcement (just check top-level). However, it removes flexibility to have, say, a private section in an otherwise shared doc. We decided to keep the possibility of per-block ACL for now, but UI may discourage mixing private/public in one doc to avoid confusion.
- **Role-Based Access:** Using roles (like "admin", "member", "viewer", etc.) and assigning roles to blocks. This could be a layer above ACL (like instead of listing user IDs, list roles and have a global user-role mapping). For MVP, we skip this complexity because all users are basically equal collaborators, and if needed, an "admin" can simply be a user who has access to all by being added everywhere (or by virtue of being an owner of all top docs).
- **Capability Links (Shareable links with secret tokens):** We considered implementing sharing via secret URLs instead of explicit user lists (like how you share a Google Doc with "anyone with the link"). This means generating a token and not requiring login for that token. It's a useful feature (especially for public sharing). We'll partially get this via the "public" flag (which essentially is like a global link) or by generating invite links manually out-of-band. But MVP will likely focus on user identity-based sharing. The "public" flag could be seen as a special case of a token known to everyone. We could also implement invite links by creating a token and storing it in block ACL as an accepted key (like a pseudo-user key). Due to time, likely skip in MVP beyond just marking public or not.
- **Encryption-based security:** Another approach is to encrypt content for certain users so even the server cannot read it without keys. This is zero-trust approach. We did not choose this because it complicates collaboration (keys distribution) and we trust our server environment for an internal MVP. If security demands increased, we could consider end-to-end encryption for certain blocks, but not now.
- **No Embargo, just manual control:** The simplest approach to embargo is "don't show the block until the user manually flips it". But that relies on humans and might fail. Automating it is a small effort and high reward for correctness. So we included it. Another alternative is to implement embargo as a separate "Embargo" object tracking a set of blocks under embargo and releasing them – that's unnecessary overhead; a timestamp on block is enough.

## Implications

- **User Interface & Usability:** We need to expose sharing controls in the UI. This might be as simple as a "Share" dialog on a document where you enter emails to share with, similar to Google Docs. We'll have to implement that on frontend, calling our Convex functions. If multiple blocks (like all children) need updating, it could be slow if many – but presumably manageable (or we enforce at top-level).
- **State Management:** Each block's ACL is now part of its state. We might want to keep ACL info out of the main collaboration editing stream to avoid frequent updates (for example, we wouldn't want an ACL change to conflict with text edits). We'll likely handle ACL updates via separate mutations outside the ProseMirror steps. It's a rarely changed metadata, so no issue.
- **Performance of Checks:** Checking membership in a list of user IDs is trivial unless the list is huge. Typically, a block might be shared with a handful or maybe dozens of users, not thousands (except public which we treat as a flag). So performance is fine. For public, we can either interpret public:true as "no need to check list" or we could insert a special marker like userId "*" in readers list to denote public. We just need to handle it consistently. Probably a boolean is simpler.
- **Data Redundancy:** If we propagate ACL to child blocks, we store duplicate lists on many blocks. This is redundant, but ensures fast permission checks (just check the block itself). The risk is inconsistency (child's ACL not updated when parent's is). We must manage that carefully in share functions (e.g., always use a transaction or multiple mutation calls to update all children). Alternatively, not store on child at all and always refer to parent – but that breaks if a block is moved to another doc. We lean towards storing on each block for self-contained info, accepting the complexity of keeping it in sync (maybe easier if share is mostly at doc level).
- **Convex Auth and Identity**: We rely on Convex's user identities (likely an OAuth subject string or Convex user Id) to identify users in ACLs. We should use a stable unique ID (like Auth0's sub or GitHub ID string) rather than email (emails can change). Convex Auth gives us identity.subject which is stable[[53]](https://www.convex.dev/components/files-control#:~:text=handler:%2520async%2520\(ctx,%2520args\)%2520=,Unauthorized). We will use that as the key in ACL lists.
- **Future Federation impact:** In a single instance, user IDs are unique. In a federated future, identity would be more complex (like user@instance). If we federate, ACL might need to reference external users. That's a future problem – but maybe worth noting in expansion path.
- **Security**: We must ensure no ACL bypass. That means auditing all queries and mutations to enforce checks. E.g., a mutation that edits a block should verify ctx.auth user is authorized. A query that finds blocks via edges should filter out ones you can't see. We have to be vigilant to not accidentally leak data (like an edge query returning an ID of a hidden block is already a leak). Possibly in our edges queries, we should join with block access: e.g., when listing references to a block, filter out any referencing block the user can't read, and also if the target is the hidden block, probably the user wouldn't have asked in first place. It's tricky but doable – essentially any path that could reveal a block's existence or content requires permission. We will write tests to ensure that.
- **Embargo handling complexity:** If a block is under embargo and public flag is true, our code will need to hide it until time. We also should consider UI – maybe show it to owner with a label "embargoed until X". After time, automatically flip some state (which might require a refresh or a push). If we implement a cron job to lift embargo, we could even notify users or automatically refresh the content for viewers. Without that, a viewer might still see nothing until they refresh after time passes. Possibly acceptable. Maybe simpler: for a public embargoed block, we treat it as not existing to others until time, then it appears. That could surprise users, but that's expected by definition of embargo.
- **Temporal edge cases:** Timezones and exact timing – we store embargoUntil in UTC in DB, compare with Date.now() in server which is also UTC epoch. Minor issue: if we only run a cron hourly, an embargo might lift up to 59 minutes late if we rely on cron. Better to check on access in addition. Perhaps combine: use a cron (or ideally Convex "scheduling" if supports scheduling a job at an exact time, not sure if available) to flip a isEmbargoLifted or so, but always also double-check time in read logic. That way, worst-case scenario if cron hasn't run yet, a read function seeing now past embargo will allow access anyway even if public:true wasn't set yet.
- **Testing scenario:** We should test that a user who isn't allowed cannot retrieve block via all possible methods (direct get, through edges, through search if we have one, etc.), and that embargo works (e.g., a user tries to access an embargoed public block before time and is denied).
- **Interactions with Collaboration:** If a block is collaborative (shared editing), all editors likely have write permission. We need to handle concurrent edits with permissions – ideally ProseMirror collab only starts if you have write. We should enforce at the mutation level that only writers can submit steps. If a user is read-only and somehow tries to submit an edit, the function will reject it. Also, in UI we might make the editor read-only for them. So incorporate that state in the front-end (e.g., if not in writers, don't allow typing).
- **Propagation on Copy/Move:** If a block is moved (say cut-paste into another document), what happens to its ACL? Possibly it should inherit new parent's ACL after move (especially if moved from private to a shared doc or vice versa). We should address that: our move mutation should recompute or prompt user to decide. Simplest: if you move a block under a new parent, we could automatically set its ACL to match the new parent (assuming user moving has rights to do so). If that results in losing some old permissions, maybe warn. MVP likely won't have complex move operations exposed to user, but our system should handle it if done.

## Expansion Path

- **Group Sharing:** Add concept of groups or teams to simplify sharing to many people. For example, instead of listing 30 users on a block, have a group "Research Team" that contains those 30, and just share to that group. Implementation: group could be a Convex object with id and list of user ids. ACL could allow entries that are group ids (distinguishable from user ids). The check function would then resolve group membership. This reduces duplicate lists and makes adding a new team member easier (just add to group). It's a logical next step if user base grows.
- **Roles and Permissions matrix:** Possibly define roles like "viewer" vs "editor". Currently, our ACL implicitly handles that (if we separated readers and writers). We could formalize roles: e.g., a "commenter" role could be introduced (if we have comment feature) or "owner" vs "co-editor". Right now owner is just the creator, not explicitly in lists (or could be included for clarity). Expanding roles would be about adding metadata to ACL entries or separate ACL lists per permission type. This can be done while preserving compatibility (just extend the structure).
- **Hierarchical Permissions:** If we want a structure where sharing a parent automatically and dynamically shares all children (and future children), we might implement an inheritance model. For instance, a flag on a block "inherits ACL from parent unless overridden". This would allow having sections in a doc that override (like mark one sub-block as extra restricted or open). This complexity could be toggled if needed. We'd then change our permission check to walk up until it finds a block with explicit ACL or hits top. For now, not doing this to avoid overhead on each check.
- **Public Publishing & Federation:** When we allow public access (no login), we need to deliver content possibly via a public endpoint (maybe a Next.js rendered page or a Convex HTTP endpoint). We'll have to ensure those follow the public flags. For federation (if we integrate with something like ActivityPub to broadcast public content), the permission model should align that "public" means world-readable. Embargo in that case might translate to scheduling the federation broadcast at a later time rather than immediate. That would be an interesting expansion – connecting our ACL flags to federation controls.
- **Audit Logs:** In enterprise contexts, one might want a log of who accessed what sensitive block and when. We might later add logging in our queries (though that can be heavy) or better, a dedicated system log of accesses. At least, logging changes to permissions is important (who shared what with whom). We could record ACL changes in an audit collection. This is an expansion for security-conscious deployments.
- **Temporary Access Links:** Provide a feature to generate a time-limited link to share with someone not in the system (like "share with external collaborator for 7 days"). This would involve creating a one-time token that maps to the block and storing an entry in ACL as a token with expiry. Our architecture could incorporate that by treating token as a pseudo-user in ACL and handling in request (like if a request provides a token, match it). Convex HTTP endpoints could be used to consume such tokens. This is a non-trivial feature but useful. It extends the permission model beyond user identity to include bearer tokens.
- **Future Integration with Mastra (AI agents):** If we add AI agents that can read or write blocks (co-scientist assistants), we might need to give them special permissions. One approach: treat an agent as a special user identity (with its own ID and appropriate ACL entries). Or allow the agent to act with a user's permission (like it runs under a user's context). For fine security, possibly each agent could be whitelisted on certain data. We'll consider adding an "agent" flag in ACL or simply include them as users. Our current model could already include an agent's userId in the allowed list.
- **Multi-Tenancy Prep:** If in the future we support multiple distinct organizations on one Convex instance, we'd add a "workspace" or "tenant" field on blocks and edges, and ensure ACL primarily doesn't allow cross-tenant shares (or if does, very explicit). That might be beyond MVP, but it's considered: the permission checks would then also isolate by tenant. We'd likely include tenant context in every query. For now, assume one tenant or all users potentially know each other.
- **Granular Time Controls:** We could expand embargo to more general time-based rules (like only accessible during certain hours or after a certain event). For example, a block might be visible for 24 hours after first view (like expiring info). Those are specialized scenarios (like timed exam content). If needed, we could implement with similar approach: store a release and/or expiry timestamp. In general, our architecture supports an expiresAt similar to embargoUntil (just reversed: after that time, revoke access). Actually, we could implement expiry by scheduling a removal of that user from ACL at time X. Or by storing an expiry on the ACL entry itself. Not doing now, but expansion could borrow ideas from how Files Control handles expiry for download grants[[60]](https://www.convex.dev/components/files-control#:~:text=storageId,%2520maxUses:%25201,%2520expiresAt:%2520Date,).
- **UI/UX improvements:** Eventually, we might implement a permission management UI that shows all users who have access, allows setting view vs edit rights, transferring ownership, etc. That's product work but based on the data we store.
- **Policy Templates:** In some environments, we might have a policy like "all blocks created under Project X should default share with group Y". We could implement templates or rules at a higher level. This would be an extension to auto-set ACL on new content based on location or metadata. The architecture can accommodate by hooking into creation flows or having a config that our functions read. For example, if block is under a "ProjectX" parent, auto-add groupX to its ACL on creation.
