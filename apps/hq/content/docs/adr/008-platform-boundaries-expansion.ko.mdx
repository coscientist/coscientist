---
title: "ADR 8: 플랫폼 경계 및 확장 계획"
description: "Convex, Vercel, Workflow, Mastra 통합을 위한 아키텍처 결정과 명확한 플랫폼 경계 및 향후 확장 경로"
---

# ADR 8: 플랫폼 경계 및 확장 계획

## 배경

MVP 시스템은 **Vercel 기반 Next.js 프론트엔드**와 **Convex 백엔드**로 구성된다. 각 플랫폼의 책임을 명확히 구분해야 혼란을 피하고 확장 가능한 깔끔한 아키텍처를 만들 수 있다.

MVP에서는 연합(Federation) 다중 서버 구성이나 고급 AI 에이전트 기능을 제외하지만, 아키텍처 설계 단계에서 이러한 기능으로의 확장 경로를 고려해야 한다.

<Callout type="info" title="이 ADR의 범위">
  다루는 내용: - 프론트엔드/백엔드 경계 구조 - Convex 스케줄링 및 워크플로 통합
  - AI 에이전트 시스템(Mastra) 도입 계획 - 연합 및 다중 컴포넌트 아키텍처 로드맵
</Callout>

## 결정

**Next.js(Vercel)를 프론트엔드/UI 레이어로, Convex를 데이터와 실시간 협업의 권위 있는 백엔드로 삼아 명확한 클라이언트-서버 분리를 유지한다. 백그라운드 작업에는 Convex의 워크플로와 스케줄링을 활용한다.**

시스템은 단일 Convex 배포와 단일 Next.js 앱으로 시작하며, 확장 경로를 명확히 정의해둔다.

### 플랫폼별 책임

<Tabs items={['Next.js (Vercel)', 'Convex 백엔드', 'Workflow & 스케줄링']}>
<Tab value="Next.js (Vercel)">
**프론트엔드/UI 레이어:**
- 애플리케이션 UI 렌더링 및 라우팅 처리
- Convex React 클라이언트(`ConvexProvider` 및 자동 생성 훅) 사용
- 모든 데이터 변경과 조회는 Convex API를 통해 수행
- 일시적인 UI 상태 외에는 클라이언트 측 상태를 유지하지 않음
- 필요시 초기 로드에 SSR 적용 (Convex는 Node 컨텍스트 지원)
- Vercel 배포로 정적 자산의 빠른 글로벌 전달

<Callout type="warn" title="보안 경계">
Next.js에는 비밀 로직을 두지 않는다. 모든 민감한 연산은 Convex 함수에서 처리한다. 필요시 Vercel의 엣지에서 봇 방지 등 추가 보호를 적용할 수 있다.
</Callout>
</Tab>

<Tab value="Convex 백엔드">
**진실의 원천(Source of Truth):**
- 데이터베이스 보유 (blocks, edges, steps, presence 등)
- 모든 비즈니스 로직은 Convex 함수(queries, mutations, actions, crons)에 구현
- ProseMirror OT 함수와 presence 구독을 통한 실시간 협업
- 단일 데이터베이스로 일관성을 중앙 집중화하고 동기화를 단순화

**Convex Components:**

- Files Control
- ProseMirror Sync
- 개발을 가속화하는 기타 모듈식 백엔드 조각

</Tab>

<Tab value="Workflow & 스케줄링">
**백그라운드 작업:**
- **Cron 작업**: 주기적 작업 (만료 파일 정리, presence 정리)
- **Actions**: 데이터 변경 시 재실행되지 않는 일회성 작업
- **Workflow 컴포넌트**: 재시작에도 살아남고 재시도를 처리하는 내구성 있는 함수

<Callout type="idea" title="Workflow 활용 사례">
- 이메일 알림 발송
- Embargo 해제 예약
- Block 편집 후 AI 요약
- 다단계 에이전트 추론 체인
</Callout>
</Tab>
</Tabs>

### 인증

Convex 내장 Auth를 Google/GitHub OAuth와 통합해 사용한다. Next 프론트엔드가 로그인 플로우를 트리거하고 ID 토큰을 받으면, Convex가 이를 인증에 사용한다. 별도의 인증 서버가 필요 없다.

### Mastra (AI & Agents) - 향후 통합

<Callout type="info" title="Mastra란?">
  Mastra는 Vercel이 밀고 있는 TypeScript AI 프레임워크로, 모던 JS 스택에서 AI
  기반 기능을 구축하기 위한 다중 에이전트 워크플로 기능을 제공한다.
</Callout>

**통합 전략:**

1. **모듈식 AI 로직**: 에이전트 추론을 위한 별도 서비스 또는 서버리스 함수
2. **통신**: 에이전트는 API(HTTP 엔드포인트 또는 함수 호출)를 통해 Convex와 통신
3. **인간 전용 가정 없음**: 인간과 에이전트 모두의 데이터 접근을 수용하는 아키텍처
4. **배포 옵션**:
   - Convex Action 내에서 Mastra 에이전트 실행
   - Vercel Edge Functions 또는 AWS Lambda로 비동기 에이전트 실행
   - Vercel AI SDK를 통한 오케스트레이션

### Federation - 향후 확장

<Callout type="warn" title="MVP에 미포함">
  MVP는 단일 Convex 배포다. 연합은 향후 고려 사항이다.
</Callout>

**향후 경로:**

- API 레이어 또는 메시지 전달로 다중 백엔드 연결
- Block 모델에 `origin` 또는 `globalId` 필드 확장 가능
- 콘텐츠 위치별 요청 라우팅을 위한 연합 서버 개발 가능성
- 공개 콘텐츠 연합을 위한 ActivityPub 채택 가능성
- 전역 고유 ID(UUID)로 향후 데이터 병합 용이

### DevOps 및 배포

| 레이어     | 플랫폼                    | 비고                       |
| ---------- | ------------------------- | -------------------------- |
| 프론트엔드 | Vercel                    | 도메인, CDN, 정적 자산     |
| 백엔드     | Convex Cloud              | 함수, 데이터베이스, 실시간 |
| 통신       | HTTPS + WebSockets        | SSL 보안, 인증 필수        |
| 로깅       | Convex Dashboard + Vercel | 프론트엔드용 Sentry는 선택 |

### MVP의 Workflow 활용 예시

| 사용 사례            | 구현                            |
| -------------------- | ------------------------------- |
| 주기적 정리          | Cron 작업                       |
| AI 요약              | 재시도 기능 포함 Convex Action  |
| 다단계 에이전트 작업 | 내구성 함수 (Workflow 컴포넌트) |
| 파일 정리            | 예약된 Actions                  |

## 근거

<Cards>
<Card title="관심사 분리">
Next.js는 프레젠테이션과 사용자 상호작용을 담당하고, Convex는 데이터 일관성과 비즈니스 규칙을 담당한다. UI 변경이 백엔드 로직을 위험에 빠뜨리지 않고, 그 반대도 마찬가지다.
</Card>

<Card title="전문 플랫폼 활용">
  Vercel은 프론트엔드 전달(CDN, 자산 최적화)에 최적화되어 있고, Convex는 실시간
  동기화를 갖춘 백엔드 상태에 최적화되어 있다. 각자가 가장 잘하는 일을 맡긴다.
</Card>

<Card title="성장에 따른 확장">
  Convex는 내부적으로 수평 확장하고, Vercel은 서버리스 함수와 정적 콘텐츠를 자동
  확장한다. 새 기능은 Convex 컴포넌트나 Vercel 통합을 통해 추가할 수 있다.
</Card>

<Card title="확장 준비">
모듈식 인터페이스를 통한 AI/에이전트 통합. 전역 고유 ID로 연합 가능. 향후 성장을 방해할 지름길을 피한다.
</Card>
</Cards>

### MVP에서 모놀리식 백엔드를 선택한 이유

- **초기 복잡성 감소** - 마이크로서비스 조율 오버헤드 없음
- **Convex 생태계 확장** - 벡터 검색, AI 메모리 컴포넌트 출시 예정
- **필요할 때만 분리** - 예: 시맨틱 검색용 외부 벡터 DB(Pinecone)

### 보안 경계

모든 민감한 연산은 Convex 측에서 처리한다. Next.js가 보유하는 것:

- Convex 배포 URL
- 공개 인증 설정

모든 비밀 키(서드파티 API, Mastra 통합)는 Convex 또는 Vercel 서버리스 함수 환경 변수에 저장하며, 클라이언트 코드에는 절대 포함하지 않는다.

### 단일 백엔드를 통한 일관성

모든 것을 Convex를 통해 실행하면 데이터 일관성이 보장된다. 모든 제약과 로직이 한 곳에 있는 단일 데이터베이스를 갖는 것과 같다.

## 고려한 대안

<Tabs items={['단일 서버', '완전 서버리스', 'MVP에 AI 포함', '확장 무시']}>
<Tab value="단일 서버">
**Postgres/Mongo + ShareDB/Yjs를 사용한 Node.js 서버**

기각 이유:

- 실시간 동기화와 OT 로직을 처음부터 구축해야 함
- Convex의 우아한 반응성을 잃음
- Vercel의 WebSocket은 간단하지 않음 (별도 서버 필요)

</Tab>

<Tab value="완전 서버리스">
**클라이언트 + 엣지 함수 + Firebase + CRDT 라이브러리**

기각 이유:

- 조각보기식 구성은 유지보수가 어려움
- 긴밀한 통합 달성이 어려움
- 보안과 함께 CRDT 상태 병합이 까다로움

</Tab>

<Tab value="MVP에 AI 포함">
**첫날부터 AI 에이전트 포함**

기각 이유:

- 초기 아키텍처가 과도하게 복잡해짐
- 벡터 DB와 LLM 서비스 통합을 미리 해야 함
- 설계만 해두고, 구현은 나중에 하는 것이 나음

</Tab>

<Tab value="확장 무시">
**연합/다중 에이전트 미래를 무시하고 MVP 구축**

기각 이유:

- 지름길이 나중의 확장을 방해함
- 지금 전역 고유 ID를 사용하면 향후 데이터 병합이 용이
- 코드를 쉽게 분리할 수 있게 구조화 (AI 함수를 별도 모듈로)

</Tab>
</Tabs>

**모노레포 결정**: 프론트엔드와 백엔드를 같은 저장소에 두어 타입 공유와 개발 편의성을 확보한다. Convex 함수는 Next 앱과 함께 있고, Convex 개발 서버가 파일 변경을 감시한다.

## 영향

### 수용한 트레이드오프

| 우려 사항          | 완화 방안                                                   |
| ------------------ | ----------------------------------------------------------- |
| **벤더 종속**      | 이식 가능하도록 코드 구조화. Convex는 오픈소스 코어 보유.   |
| **비용**           | 사용량 모니터링. 명확한 경계로 필요시 컴포넌트 교체 가능.   |
| **단일 장애 지점** | 두 플랫폼 모두 고가용성. 공개 콘텐츠용 읽기 전용 캐시 가능. |

### 개발 워크플로

- 개발자는 Next와 Convex 개발 서버를 모두 실행
- Convex는 파일 감시 기능이 있는 백그라운드 개발 서버 제공
- 환경 변수로 Next를 Convex에 연결
- Convex codegen을 통한 공유 TypeScript 타입

### 엣지 고려 사항

- Vercel은 정적 자산용 글로벌 CDN 노드 운영
- Convex는 기본적으로 단일 리전 (허용 가능한 지연 트레이드오프)
- WebSocket이 영구 연결 유지
- 향후: 필요시 다중 리전 Convex

### 상태 저장 vs 상태 비저장 경계

| 레이어      | 상태 모델           | 의미                     |
| ----------- | ------------------- | ------------------------ |
| Convex      | 상태 저장 (DB)      | 모든 영구 상태는 여기에  |
| Next/Vercel | 요청 간 상태 비저장 | 서버 메모리 가정 없음    |
| 브라우저    | 일시적 UI 상태      | 클라이언트별 휘발성 상태 |

<Callout type="error" title="핵심 규칙">
  Next.js 서버 메모리에 영구 상태를 저장하지 말 것 - 휘발성이며 다중 인스턴스다.
  모든 영구 상태는 Convex로 가야 한다.
</Callout>

### 지속적 배포

- Convex를 먼저 배포 (함수 업데이트 확인)
- 그 다음 이를 호출하는 프론트엔드 배포
- 스키마 마이그레이션 시 신중한 조율 필요

### 개발자를 위한 문서화

문서화할 핵심 규칙:

- "모든 데이터 변경은 Convex 함수에서"
- "Next.js 측에서 애플리케이션 상태를 변경하지 말 것"
- "Next.js는 Convex를 호출하거나 UI를 렌더링하기만 해야 함"
- "백그라운드 작업에는 별도 스케줄러 대신 Convex cron 또는 action 사용"

## 확장 경로

<Callout type="info" title="상호 참조">
  기능별 확장은 ADR 1-7의 통합 섹션을 참조. 이 섹션은 아키텍처 확장을 다룬다.
</Callout>

<Cards>
<Card title="Federation" href="#federation">
Block 모델을 연합 단위로. 전역 식별자(인스턴스 + ID). 스마트 프록시 또는 ActivityPub 호환 서버. 교차 인스턴스 편집을 위한 CRDT/합의.
</Card>

<Card title="AI 및 Agents (Mastra)" href="#ai-agents">
  에이전트가 지식 베이스를 읽고 기여. 에이전트 메모리는 Convex에. 워크플로를
  통한 백그라운드 프로세스. 에이전트를 API 접근 권한을 가진 특수 사용자로 취급.
</Card>

<Card title="벡터 검색" href="#vector-search">
  Convex 벡터 검색 또는 외부 서비스(Pinecone). 쿼리 → 임베딩 → 벡터 DB → Block
  ID → Convex 조회.
</Card>

<Card title="공개 게시" href="#public-publishing">
  공개 Block을 정적 사이트로 내보내기. SEO 활성화. Convex 호출 없이 제공. 연합
  시나리오에서 교차 도메인 링크.
</Card>

<Card title="오프라인 & 로컬 우선" href="#offline">
  CRDT 접근(Yjs) 또는 Convex 로컬 우선 기능. 온라인 시 동기화되는 클라이언트 측
  데이터베이스. 상당한 아키텍처 전환 필요.
</Card>

<Card title="Workflow 자동화" href="#automation">
  사용자 정의 규칙("주장 추가 시 증거 찾기"). 테이블 변경에 대한 트리거 시스템.
  Mastra 또는 Convex 워크플로 엔진.
</Card>

<Card title="다중 테넌시" href="#multi-tenancy">
`tenantId`/`workspaceId`로 데이터 분할. 테넌트 범위 권한. 격리가 필요하면 테넌트별 별도 배포.
</Card>
</Cards>

### Mastra 도입 상세

Mastra를 도입할 때:

1. 에이전트 인터페이스용 별도 Convex 함수 할당
2. 또는 Convex Action 내에서 Mastra 실행 (부하에 따라)
3. 에이전트 메모리(대화 로그, 지식)를 Convex에 저장
4. 에이전트 로직은 Convex Action 또는 AI SDK를 사용하는 Vercel 함수에서 실행

### 외부 통합 API

Convex는 외부 통합용 HTTP API를 제공한다:

- 외부 노출을 위한 깔끔한 인터페이스로 함수 설계
- 인증에 API 키 또는 서비스 계정 사용
- 플러그인 생태계와 연합 시나리오 활성화
