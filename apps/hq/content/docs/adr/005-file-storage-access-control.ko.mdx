---
title: "ADR 5: 파일 저장소와 접근 제어 (Convex File Storage + Files Control)"
---

# ADR 5: 파일 저장소와 접근 제어 (Convex File Storage + Files Control)

## 배경

지식 시스템에는 **파일 첨부** – 이미지, PDF, 데이터 파일 등이 포함된다. 사용자가 파일을 업로드하고 Block에 포함하거나 링크할 수 있어야 한다.

<Callout type="info" title="핵심 요구사항">
  - 잠재적으로 큰 바이너리 파일 처리 - 효율적인 전달 (CDN 가능) - 비공개 파일이
  권한 없는 사용자에게 접근 불가하도록 **접근 제어**
</Callout>

Convex를 백엔드로 쓰니까 파일 저장소에 제공되는 기능을 활용한다. Convex는 통합 파일 저장소 솔루션과 안전한 파일 처리를 위한 상위 레벨 API를 제공하는 _Files Control_ 컴포넌트가 있다.

## 결정 사항

<Callout type="info" title="핵심 접근법">
  **업로드, 다운로드, 파일 권한 관리에 Convex Files Control 컴포넌트와 함께
  Convex 내장 File Storage를 활용한다.**
</Callout>

파일을 메인 DB 외부(바이너리 저장소)에 저장되는 특수 콘텐츠로 취급하고 Block 모델에서 ID로 참조한다.

### 업로드 흐름

2단계 업로드 프로세스를 사용한다:

1. **업로드 URL 요청:** 클라이언트가 mutation 호출 (`generateUploadUrl` 래핑). 일회용 **사전 서명된 URL**과 `uploadToken` 반환.

2. **파일 직접 업로드:** 클라이언트가 해당 URL에 HTTP PUT으로 Convex 저장소에 파일을 직접 업로드 (앱 서버 우회). 성공하면 Convex가 `storageId` 반환.

3. **업로드 완료:** 클라이언트가 `uploadToken`과 `storageId`로 mutation 호출 (`finalizeUpload` 래핑). 이 시점에 이 `storageId`를 연결하는 "file" 타입 Block을 blocks 테이블에 생성. 업로더의 사용자 ID에 기본적으로 접근 권한 부여.

### 파일 제공

파일 접근용 안전한 URL을 생성한다:

<Tabs items={['HTTP 라우트', '온디맨드 URL']}>
  <Tab value="HTTP 라우트">
    Files Control에 경로를 통해 파일을 제공하는 선택적 HTTP 라우터가 포함 (예: `https://<convex-site>/files/download?token=XYZ`).
    
    다운로드 라우트를 활성화하고 Convex 내장 auth 훅을 써서 권한 있는 요청만 성공하게 한다.
  </Tab>
  <Tab value="온디맨드 URL">
    `buildDownloadUrl`로 시간 제한 URL을 온디맨드 생성. 이미지 표시 시 앱이 단기 토큰을 포함하는 URL을 요청.
    
    누군가 URL을 찾아도 만료된다. `requireAccessKey`가 켜져 있으면 로그인 없이 작동 안 함.
  </Tab>
</Tabs>

### 접근 제어

Convex에 저장된 각 파일에 **접근 키** 세트가 연결되어 있다 (Block에 ACL이 있는 것처럼). 기본적으로 사용자 ID를 접근 키로 사용.

- **addAccessKey:** 파일 Block이 사용자와 공유되거나 공개될 때
- **removeAccessKey:** 권한이 취소될 때
- **hasAccessKey:** 사용자가 다운로드 시도할 때 검증 체크

Block 권한([ADR 6](/docs/adr/adr-006-permissions-embargo-model))과 통합된다.

### 파일 메타데이터

blocks 테이블에 파일 메타데이터를 저장:

- `fileName`
- `fileSize`
- `contentType`
- `storageId`

UI에서 파일 정보를 표시하고 필요하면 검색할 수 있다. 저장소 자체는 불투명하다 (검색용 ID일 뿐).

## 왜 이렇게 결정했나

Convex 파일 저장소와 Files Control 컴포넌트 사용이 실용적인 선택이다:

- **통합 보안:** 컴포넌트가 파일 URL에 접근 제어를 강제해서 무단 다운로드를 방지. 일회용 토큰 생성하고 만료를 처리한다.

- **개발 속도:** 자체 S3 설정하고 URL 서명 람다 작성하는 것보다 훨씬 빠르다. 컴포넌트가 업로드용 React 훅도 제공.

- **Convex와의 일관성:** Convex 생태계 내에서 파일 처리를 유지해서 데이터와 파일 모두에 단일 진실의 원천을 유지.

- **확장성과 CDN:** Convex 접근법(특히 R2 사용 시)이 CDN으로 파일 전달. R2 사용하면 Cloudflare CDN이 자동으로 작동.

- **파일 수명 주기 관리:** 만료된 파일 정리 내장과 각 파일에 만료 설정 가능.

## 검토한 대안들

<Tabs items={["직접 내장", "외부 저장소", "Next.js 제공", "IPFS"]}>
  <Tab value="직접 내장">
    **파일 직접 내장:** 작은 파일을 Convex DB에 바이너리 데이터로 직접 저장 (예:
    Block에 base64). **기각** – DB를 부풀리고 쿼리를 느리게 만든다. Convex 파일
    저장소가 바이너리용이다.
  </Tab>
  <Tab value="외부 저장소">
    **Convex 통합 없는 외부 저장소 (S3/GCS):** URL 서명용 자체 백엔드 엔드포인트
    작성. **기각** – 보일러플레이트가 많고 보안 확인 필요. Convex auth와의
    긴밀한 통합을 잃는다.
  </Tab>
  <Tab value="Next.js 제공">
    **Next.js로 제공 (Vercel에서 파일 호스팅):** 정적 자산에 Vercel 내장 저장소
    사용. 사용자 업로드는 동적이라 작동 안 함. Vercel에 사용자 업로드용 내장
    바이너리 저장소가 없다.
  </Tab>
  <Tab value="IPFS">
    **P2P나 IPFS:** 파일을 분산 저장. **기각** – 복잡도와 세밀한 접근 제어 부족
    (IPFS의 모든 것이 공개).
  </Tab>
</Tabs>

## 영향

- **인증 통합:** 파일 접근 키가 사용자의 `identity.subject` (고유 사용자 ID)에 의존. 모든 파일 작업이 인증된 사용자와 연결되어야 한다.

- **앱 크기 / 대역폭:** 파일 처리는 잠재적으로 큰 데이터 전송을 의미. 파일 크기 제한을 두고 압축을 권장할 수 있다.

- **콘텐츠 보안:** 시스템이 본질적으로 바이러스 스캔이나 파일 콘텐츠를 조정하지 않는다. 내부 사용은 괜찮지만 공개 플랫폼이면 콘텐츠 조정 통합이 필요할 수 있다.

- **Block 공유와 파일 접근 관리:** 파일 ACL을 Block ACL과 동기화 유지. 이미지가 포함된 문서를 공유하면 이미지 파일도 접근 가능해야 한다.

<Callout type="warn" title="보안 고려사항">
  이미지에 토큰화된 URL을 사용하면 만료 전까지 토큰을 복사해서 다른 사람이 쓸 수
  있다. 짧으면(예: 5분) 지속적으로 새로고침되면 합리적으로 안전하다.
</Callout>

## 확장 경로

<Cards>
  <Card
    title="이미지 썸네일 & 처리"
    href="/docs/adr/adr-008-platform-boundaries-expansion"
  >
    큰 이미지에 작은 썸네일 생성. 서드파티 통합이나 Vercel Edge Functions로
    이미지 처리 가능.
  </Card>
  <Card
    title="비디오 & 오디오 처리"
    href="/docs/adr/adr-008-platform-boundaries-expansion"
  >
    인코딩/스트리밍은 전문 서비스(Mux, Cloudinary 등)로 오프로드.
  </Card>
  <Card
    title="대용량 데이터 파일"
    href="/docs/adr/adr-008-platform-boundaries-expansion"
  >
    사용자 자체 클라우드나 기관 저장소와 통합. 실제 파일 대신 URL을 담는
    "external_file" Block 허용.
  </Card>
  <Card title="파일 버전 관리" href="/docs/adr/adr-002-versioning-strategy">
    파일에 버전 히스토리 허용. 파일 Block 업데이트 시 같은 Block ID 유지하고 새
    storageId를 가리킴.
  </Card>
</Cards>

<Callout type="idea" title="워크플로우 통합">
  파일을 생성하는 백그라운드 프로세스나 에이전트([ADR
  8](/docs/adr/adr-008-platform-boundaries-expansion) 참조)가 있으면 (AI가
  보고서 PDF 생성 등) 같은 파일 저장소 메커니즘을 쓸 수 있다. 일관된 접근법
  덕분에 자동화된 콘텐츠도 같은 파이프라인을 거친다.
</Callout>
