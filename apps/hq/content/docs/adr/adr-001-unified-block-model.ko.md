---
title: "ADR 1: 통합 Block 모델 (보편적 지식 원자로서의 Block)"
---

# ADR 1: 통합 Block 모델 (보편적 지식 원자로서의 Block)

플랫폼은 사용자가 기여한 지식 콘텐츠(텍스트, 미디어, 참조 등)를 매우 세분화된 방식으로 관리합니다. 각 지식 조각을 쉽게 재사용하고 연결할 수 있는 원자 단위로 취급하는 콘텐츠 모델이 필요합니다. 전통적인 위키나 문서 시스템은 전체 페이지나 문서를 가장 작은 단위로 취급하는 경우가 많지만, 이 시스템은 단락이나 이미지조차 개별 단위인 block 기반 편집기(예: Notion, block 위키)에서 영감을 받았습니다. 이러한 **block 기반 접근 방식**을 통해 작은 콘텐츠 조각 간의 풍부한 관계를 가진 지식 그래프를 구축할 수 있습니다.

## 결정

**모든 콘텐츠는 통합 모델에서 "Block" 엔티티로 표현됩니다.** 각 Block은 고유 식별자와 타입 메타데이터를 가진 일급 지식 원자입니다. 텍스트 단락, 제목, 이미지, 파일, 심지어 복합 문서까지 모두 Block으로 저장됩니다. Block은 다른 Block을 참조하거나 계층적으로 구성될 수 있습니다(예: edge나 부모 포인터를 통해 자식 Block을 포함하는 문서 Block). Block은 다음과 같은 스키마를 가진 단일 Convex 테이블(예: blocks)에 저장됩니다:

- id: Id<"blocks"> – 기본 키 (Convex의 객체 ID).
- type: string – block 타입 (예: "text", "image", "doc" 등).
- content: any – 콘텐츠 페이로드. 텍스트 block의 경우 ProseMirror JSON 노드나 일반 텍스트일 수 있으며, 이미지나 파일 block의 경우 파일 저장소 ID에 대한 참조일 수 있습니다.
- 메타데이터 필드: 예: createdBy, createdAt, updatedAt 등.
- (선택적) 구조 필드: 예: 계층 구조를 직접 저장하는 경우 parentId 또는 순서 인덱스. 그러나 계층적 또는 의미론적 관계는 주로 별도의 Edge 모델로 관리됩니다(ADR 4 참조).

이 결정은 **사용자가 생성하거나 조작하는 모든 것이 Block**임을 의미하며, 균일한 API와 데이터 처리를 가능하게 합니다. "문서"나 기사는 단순히 자식 Block(단락, 이미지 등)을 가진 "doc" 타입의 Block이며, 이들은 "contains" 타입의 edge(ADR 4 참조)를 통해 연결되거나 doc block의 content에 있는 자식 ID 배열을 통해 연결됩니다. MVP에서는 문서를 순서가 있는 목록에 저장된 block의 선형 컬렉션으로 구현할 수 있지만, 개념적으로는 여전히 block을 포함하는 block입니다.

## 근거

이 통합 모델은 일관성과 유연성을 보장합니다. 모든 콘텐츠를 균일하게 취급함으로써 Block 수준에서 기능(버전 관리, 권한, 연결)을 구현하고 모든 콘텐츠 타입에 적용할 수 있습니다. 또한 협업 엔진을 단순화합니다 – 사용자가 단락을 편집하든 전체 페이지를 편집하든 하나 또는 여러 Block을 편집하는 것입니다. 더 나아가 지식 그래프를 촉진합니다: block은 그래프의 노드이며, 의미론적 관계를 나타내기 위해 타입이 지정된 edge로 연결할 수 있습니다(ADR 4). 이는 **노드가 엔티티를 나타내고 edge가 타입이 지정된 관계를 나타내는** 현대 지식 그래프 원칙과 일치합니다[[1]](https://shilpathota.medium.com/understanding-knowledge-graphs-for-agentic-ai-7162d018387b). 모든 콘텐츠 조각을 노드(Block)로 만들면 풍부한 의미론적 연결이 가능합니다(예: "Evidence" block을 통해 "supports" edge로 지원되는 "Claim" block).

통합 block 접근 방식은 block 기반 편집기와 _"원자적" 지식 단위_ 개념에서 영감을 받았습니다. "페이지 대 단락"과 같은 구분을 하드코딩하지 않습니다 – 대신 페이지는 자식을 가진 block입니다. 이는 백엔드를 단순화합니다: 모든 콘텐츠에 대해 하나의 Convex 테이블과 API. 또한 향후 확장을 용이하게 합니다: 새로운 콘텐츠 타입(코드 셀, 수학 block 등)을 기본 데이터 모델을 변경하지 않고 새로운 block 타입으로 추가할 수 있습니다.

## 고려된 대안

- **Page/Document 모델:** 전체 문서나 기사를 단일 레코드(큰 텍스트 필드 포함)로 취급합니다. 이는 기본 편집에는 더 간단했지만 세분성이 부족합니다 – 개별 아이디어나 섹션을 독립적으로 연결하거나 버전 관리할 수 없습니다. 또한 하위 섹션에 대한 협업 편집을 복잡하게 만듭니다.
- **콘텐츠 타입별 별도 테이블:** 예: documents 테이블, paragraphs 테이블, images 테이블. 이는 각 타입에 대한 복잡성과 로직 중복을 추가합니다. 단순성과 일관성을 위해 타입 필드가 있는 단일 테이블을 선호했습니다.
- **하나의 Document Blob에 계층 구조 포함:** 전체 문서의 콘텐츠(내부 block 포함)를 하나의 JSON 구조로 저장합니다(ProseMirror가 내부적으로 하는 것처럼). 이는 검색을 단순화하지만 콘텐츠의 일부를 재사용하거나 참조하기 어렵게 만듭니다. Block을 개별적으로 주소 지정 가능하게 하고 싶습니다(예: 다른 문서의 특정 block에 연결).
- **Graph Database 또는 RDF Triple Store:** 모든 지식에 대해 전용 graph DB 또는 RDF 모델을 사용합니다. 이는 노드/edge를 우아하게 처리할 수 있지만 MVP에 추가 인프라와 복잡성을 도입합니다. 대신 Convex에서 graph 모델을 구현합니다(테이블에 edge 저장, ADR 4 참조). 이는 별도의 DB가 필요 없이 노드와 edge 테이블의 일반적인 SQL 접근 방식과 개념적으로 유사합니다[[2]](https://shilpathota.medium.com/understanding-knowledge-graphs-for-agentic-ai-7162d018387b#:~:text=,offs).

## 영향

- **원자적 재사용:** 모든 것이 Block이므로 여러 컨텍스트에서 block을 재사용하거나 포함할 수 있습니다. 예를 들어, 동일한 "Experiment Result" block을 콘텐츠를 복제하는 대신 edge를 통해 두 개의 다른 문서에서 참조할 수 있습니다. (전체 transclusion UI는 MVP 이후이지만 모델은 이를 허용합니다.)
- **성능 고려 사항:** 전체 문서를 로드하려면 이제 여러 block(컨테이너와 그 자식)을 가져와야 합니다. Convex는 JOIN을 지원하지 않지만 edge를 인덱싱하거나 자식 ID를 저장하여 자식을 검색할 수 있습니다. block을 ID로 일괄 가져올 것입니다. 문서가 편집되면 하나의 큰 문서 업데이트 대신 많은 작은 block 업데이트가 발생하지만 Convex의 실시간 엔진은 빈번한 작은 변경을 처리할 수 있습니다.
- **일관성과 트랜잭션:** 여러 block에 걸친 변경(예: 단락을 두 개의 block으로 분할)은 데이터 일관성을 유지하기 위해 Convex 함수에서 신중하게 처리해야 합니다. Convex는 트랜잭션(단일 함수 호출)에서 순차적 작업을 허용하므로 새 block을 삽입하고 edge 또는 부모 참조를 원자적으로 업데이트하는 데 사용할 것입니다.
- **단순화된 기능 구현:** block별 버전 관리(ADR 2) 및 block별 권한(ADR 6)과 같은 기능은 "block"이 변경 및 액세스 제어의 단위이기 때문에 간단합니다. 그러나 페이지를 보는 사용자는 모든 구성 block에 대한 권한이 필요하다는 점을 고려해야 합니다 – 쿼리나 resolver는 권한을 필터링하거나 집계해야 합니다.
- **균일한 API:** 모든 타입의 콘텐츠에 작동하는 일반 API(예: getBlock(id), updateBlock(id, content))를 구축할 수 있습니다. 코드 경로가 적으면 버그가 적습니다. 반면에 일부 타입(이미지, 파일)은 매우 다른 처리(ADR 5의 파일 저장소를 통해)를 가지지만 여전히 텍스트 block과 메타데이터 및 ID 구조를 공유합니다.

## 확장 경로

- **새로운 Block 타입 / 온톨로지:** 시스템을 확장하면서 새로운 block 타입(예: 실행 가능한 코드가 있는 "code block" 또는 "chart" block)을 도입할 수 있습니다. ADR 결정은 확장됩니다: 새로운 타입 상수를 추가하고 콘텐츠 구조를 정의하기만 하면 됩니다. 나머지 시스템(edge, 버전 관리, 권한)은 이미 작동합니다.
- **Block의 연합:** 향후 연합 아키텍처(여러 서버 또는 인스턴스가 지식을 공유)를 허용하는 경우 block 모델은 연합의 단위가 되기에 적합합니다. 각 block은 인스턴스 간에 참조될 수 있도록 전역 식별자(인스턴스 + ID의 복합일 수 있음)를 가질 수 있습니다. 연합 시나리오에서 원격 block을 요청 시 동기화하거나 가져오는 메커니즘과 동일한 block이 다른 인스턴스에서 편집되는 경우 충돌을 해결하는 방법(CRDT가 필요할 수 있음, ADR 3 확장 참조)이 필요합니다.
- **Block 캐싱 및 로컬 우선:** Block이 작기 때문에 클라이언트는 자주 사용하는 block(또는 크지 않은 경우 전체 지식 베이스)을 오프라인 사용을 위해 캐시한 다음 변경 사항을 Convex에 동기화할 수 있습니다. 이는 로컬 우선 미래로 기울어집니다. Convex의 **불변 영구 데이터 구조**(백서에 따르면)는 이러한 워크플로를 지원할 수 있지만 MVP에서는 오프라인을 구현하지 않습니다.
- **의미론적 강화:** 모든 콘텐츠 조각이 block이므로 의미론적 데이터를 쉽게 첨부할 수 있습니다. 예를 들어, 속성을 통해 block을 "hypothesis" 또는 "evidence"로 태그하여 AI 에이전트가 block을 다르게 처리할 수 있습니다. 이는 block 모델에 맞으며 나중에 에이전트 프레임워크나 AI에서 활용할 수 있습니다(예: 에이전트가 "research question"으로 태그된 모든 block을 검색할 수 있음).
- **최적화된 쿼리:** block 수가 증가함에 따라 인덱싱이나 파티셔닝을 도입할 수 있습니다. 예를 들어, 쿼리 로드를 관리 가능하게 유지하기 위해 프로젝트나 공간별로 block을 파티션할 수 있습니다. Convex는 테이블 필드에 보조 인덱스를 생성할 수 있습니다. 문서의 block을 효율적으로 쿼리하기 위해 parentId 또는 유사한 것에 인덱스를 추가할 것입니다. 향후 일부 작업에 그래프 순회가 필요한 경우 그래프 쿼리 라이브러리를 통합하거나 자주 순회하는 관계를 그래프 최적화 저장소로 마이그레이션하는 것을 고려할 수 있습니다 – 하지만 현재 Convex + edge 테이블로 충분합니다.
