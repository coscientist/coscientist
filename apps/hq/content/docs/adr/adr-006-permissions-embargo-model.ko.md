---
title: "ADR 6: 권한 및 Embargo 모델 (시간 잠금이 있는 Block 수준 ACL)"
---

# ADR 6: 권한 및 Embargo 모델 (시간 잠금이 있는 Block 수준 ACL)

## 컨텍스트

시스템에 비공개 또는 민감한 지식이 포함될 수 있으므로 누가 콘텐츠를 보거나 편집할 수 있는지 제어하는 **권한 모델**이 필요합니다. 또한 "embargo" 개념이 도입됩니다 – 특정 시간까지 숨겨지거나 읽기 제한되어야 하는 콘텐츠(조기 공개를 방지하기 위해 연구 또는 미디어에서 일반적). MVP는 연합되지 않았으므로 지금은 단일 테넌트 또는 조직 컨텍스트를 가정할 수 있지만 해당 컨텍스트 내에서 사용자(및 가능한 역할) 간의 액세스를 구별해야 합니다. 예를 들어, 특정 block은 작성자에게 비공개일 수 있고, 다른 block은 팀과 공유되고, 다른 block은 완전히 공개일 수 있습니다. Block 수준에서 이러한 규칙을 강제하고 싶습니다. 콘텐츠 모델이 block 세분화되어 있기 때문입니다(ADR 1). Embargo는 **시간 기반 액세스 제어** 측면을 제안하며, block이 타임스탬프 후 자동으로 표시될 수 있습니다[[58]](https://jumpcloud.com/it-index/what-is-time-based-access-control#:~:text=Time,based%2520on%2520predefined%2520time%2520constraints).

## 결정

**선택적 시간 기반 embargo 제한과 결합된 block 수준 액세스 제어 목록(ACL)을 구현합니다.** 구체적으로:

- blocks 테이블의 모든 Block은 permissions 필드를 가지며, acl 또는 access라고 할 수 있습니다. MVP의 경우 간단한 구조일 수 있습니다: 예: access: { readers: string[], writers: string[], public: boolean, embargoUntil?: Date }. 허용된 사용자 ID 세트와 공개 가시성 플래그로 더 단순화할 수 있습니다. 또한 각 block에 대한 owner를 포함할 것입니다(일반적으로 생성자의 사용자 ID). 항상 전체 액세스 권한을 가집니다.
- **읽기 액세스**: block(및 그 콘텐츠/edge)을 검색하거나 구독하려면 요청 사용자가 block의 허용 목록에 나열되거나 block이 공개로 표시되어야 합니다. 그렇지 않으면 Convex 쿼리가 해당 block을 반환하지 않습니다(또는 함수가 권한 오류를 발생시킴). 이 확인은 block을 가져오는 모든 쿼리 함수에 내장될 것입니다. Convex는 행 수준 보안을 자동으로 강제하지 않으므로 코드에서 수행합니다.
- **쓰기 액세스**: 마찬가지로 수정(텍스트 편집, 자식 추가 등)은 사용자가 소유자이거나 명시적으로 writers 목록에 있거나(별도로 유지하는 경우) 편집을 허용하는 역할에 있어야 합니다. MVP의 경우 쓰기 액세스를 읽기와 동일한 목록으로 취급할 수 있습니다(즉, 공유된 사용자는 기본적으로 읽고 편집할 수 있음). 필요한 경우 별도의 목록으로 개선할 수 있습니다.
- **공개 Block**: public: true로 표시된 block은 익명 사용자를 포함하여 누구나 볼 수 있습니다(앱이 익명 액세스를 지원하는 경우). 지금은 인증된 사용자로 제한할 수 있지만 공개는 사용자별 확인을 우회할 수 있습니다. 향후 공개는 로그인 없이 노출할 수 있음을 의미합니다(예: 공개 URL을 통해).
- **상속**: 권한은 주로 block당입니다. 그러나 관리를 용이하게 하기 위해 더 큰 문서 또는 프로젝트의 일부인 block은 기본적으로 부모의 권한을 상속하거나 자동으로 할당되어야 합니다. 예를 들어, Alice와 문서 block을 공유하면 모든 자식 block도 Alice에게 표시되어야 합니다. 전파 메커니즘으로 이를 구현할 것입니다: 부모에 ACL을 설정할 때 자손에 캐스케이드합니다(또는 최소한 쿼리가 부모 액세스 소유를 자식 액세스를 암시하는 것으로 취급하도록 보장). 더 간단한 접근 방식: 항상 포함 체인을 확인합니다 – 사용자가 조상 block에 액세스할 수 있으면 block에 대한 액세스를 허용합니다. 이를 위해서는 쿼리가 트리를 조인해야 할 수 있습니다. 대신 성능을 위해 명시적으로 전파할 수 있습니다. MVP는 콘텐츠가 주로 문서(최상위 block) 세분성에서 공유된다고 가정하여 단순화할 수 있습니다(최상위 block에서 공유 토글을 강제하고 아래로 자동 적용).
- **Embargo**: 필요한 block(예: 게시 날짜까지 공개되어서는 안 되는 연구 결과 block)에 embargoUntil 타임스탬프를 추가합니다. 의미론:
  - embargoUntil이 미래 시간인 경우 해당 시간이 지날 때까지 block을 공개적으로 공유되지 않은 것처럼 취급합니다(필요한 경우 특정 협력자로부터도 제한할 수 있음). embargo를 재정의로 구현할 것입니다: 예: block이 공개로 표시될 수 있지만 미래 embargo가 있음 – 해당 시간에 _공개_되지만 그때까지는 소유자 또는 소규모 그룹에게만 표시됩니다.
  - 내부 스테이징에도 embargo를 사용할 수 있습니다: 협력자와 공유하지만 더 넓은 그룹에서 embargo할 수 있습니다.
  - 읽기 확인에서 embargo를 강제할 것입니다: now < embargoUntil이고 요청 사용자가 특수 허용 목록에 없는 경우(아마도 소유자 또는 embargo 중에도 명시적으로 허용됨) ACL에 의해 달리 허용되더라도 액세스를 거부합니다. 본질적으로 embargo는 다른 설정을 능가하는 시간 잠금입니다.
  - embargo 시간이 지나면 block의 상태가 정상으로 전환됩니다(예: 공개를 의도한 경우 모든 로그아웃 또는 모든 사용자가 액세스할 수 있게 됨).
- **관리**: 권한을 재정의할 수 있는 관리자로 일부 사용자를 지정할 수 있습니다. MVP의 경우 간단하게 유지할 수 있습니다: 시스템의 모든 사용자가 block을 생성하고 공유할 수 있으며 엄격한 관리자 역할이 없습니다. 필요한 경우 첫 번째 사용자 또는 특정 이메일을 모든 것을 볼 수 있는 관리자로 취급합니다(그러나 선택 사항).
- **구현 세부 사항**:
  - block 생성 시 기본 ACL을 설정합니다: 일반적으로 소유자가 허용 목록에 있고 다른 사람은 없습니다(기본적으로 비공개). block이 공유 문서 내에 생성되면 즉시 부모의 ACL을 할당합니다.
  - block을 공유하기 위한 변경을 제공할 것입니다: 예: 해당 사용자를 block의 readers(및 아마도 writers)에 추가하는 shareBlock(blockId, userId). 대량 공유(전체 문서 공유와 같은)의 경우 자식을 탐색하고 추가합니다(부모 상속 로직에 의존하지 않는 한).
  - 또 다른 변경은 block을 게시하거나 게시 취소하기 위한 setPublic(blockId, true/false)일 수 있습니다.
  - embargo의 경우 릴리스를 예약하기 위한 setEmbargo(blockId, timestamp) 변경. 필요한 경우 liftEmbargoNow도 가능합니다.
  - embargo에 Convex의 cron 작업을 활용할 것입니다: 예: cron은 매시간 또는 매분 실행되어 embargoUntil이 방금 지난 block을 찾고 공개 플래그를 전환하거나 소유자에게 알릴 수 있습니다. 또는 읽기 시간에 간단히 확인할 수 있습니다. 그러나 편의를 위해 embargo 만료 시 block의 상태를 사전에 변경할 수 있습니다. 예를 들어, block이 embargo되었지만 공개를 의도한 경우 embargo가 지나는 순간 public:true를 설정할 수 있습니다. 정밀도가 필요한 경우 예약된 작업으로 수행할 수 있습니다(Convex 스케줄링은 시간별 또는 일별 확인을 수행할 수 있음[[59]](https://www.convex.dev/components/files-control#:~:text=import%2520,generated/api), 사용자 지정 로직 없이 분 단위 스케줄링에 대해서는 확실하지 않음. 지원되는 경우 워크플로를 통해 개별 작업을 예약할 수 있음).
  - Files Access(ADR 5)가 연결됩니다: block의 ACL이 변경되면 그에 따라 파일 권한 업데이트를 호출합니다. 또한 block이 embargo된 경우 파일은 효과적으로 embargo되어야 합니다(시간이 지날 때까지 공유 가능한 링크를 통해 액세스할 수 없음). 시간이 지날 때까지 공개 링크를 생성하지 않음으로써 이를 처리할 수 있습니다.
  - **시간 제한 액세스**를 고려합니다(embargo는 한 가지 유형이지만 액세스 만료도 고려할 수 있음). MVP의 경우 embargo는 주요 시간 요소를 다룹니다(액세스 시작 시간). 필요하지 않는 한 액세스의 자동 만료를 구현하지 않습니다("사용자가 날짜 X까지 볼 수 있음"과 같은). 그러나 인프라는 시간 후 ACL에서 사용자를 제거하는 cron으로 유사하게 처리할 수 있습니다.

## 근거

- **세밀한 제어:** Block 수준 ACL은 모든 정보 조각을 별도로 보호할 수 있음을 의미합니다. 이는 block 모델과 일치합니다: 공개 문서 내에 기밀 메모를 포함하는 경우 기술적으로 해당 block을 제한할 수 있습니다. (UX의 경우 문서를 읽는 것을 복잡하게 만들기 때문에 단순히 허용하지 않을 수 있습니다 – 문서의 block을 균일하게 유지하는 것이 좋습니다. 그러나 필요한 경우 기능이 있습니다.)
- **MVP의 단순성:** 복잡한 역할 기반 권한보다 간단한 허용 목록 접근 방식을 선호합니다. 각 block은 액세스할 수 있는 사람의 명시적 목록을 전달합니다. 이는 확인하고 추론하기 쉽습니다. Google Docs 스타일 공유와 유사합니다 – 각 문서(block)에는 허용된 사용자 목록 또는 공개 플래그가 있습니다. MVP에서 별도의 그룹 객체나 역할을 구현할 필요가 없습니다(모두 기본적으로 개인 또는 "모두").
- **팀 협업 지원:** MVP 단일 테넌트에서도 모든 사람이 모든 것을 보는 것은 아닙니다. 연구자는 개인 메모(비공개 block)와 팀 프로젝트(공유 block)를 가질 수 있습니다. ACL 모델은 이를 쉽게 지원합니다. 나중에 그룹을 도입하는 경우 그룹을 허용 목록의 "신원"으로 취급할 수 있을 만큼 유연합니다(여러 사용자로 해결하는 항목일 뿐).
- **시간 기반 액세스 제어로서의 Embargo:** 시간 기반 액세스 제어(TBAC)는 릴리스 시간을 강제하는 데 유용한 것으로 인식됩니다[[58]](https://jumpcloud.com/it-index/what-is-time-based-access-control#:~:text=Time,based%2520on%2520predefined%2520time%2520constraints). embargoUntil을 포함함으로써 수동일 수 있는 것을 자동화합니다. 예를 들어, 논문이 게시 날짜까지 embargo 중인 경우 사용자가 그렇게 표시할 수 있습니다. 그러면 시스템은 해당 날짜가 지날 때까지 다른 사람에게 표시하지 않으며(또는 공개하지 않음), 그 시점에서 자동으로 나타날 수 있습니다. 이는 인간 오류(실수로 너무 일찍 공유)를 방지하고 사용자가 자정에 일어나 스위치를 전환하지 않아도 됩니다 – 시스템이 수행합니다.
- **Convex 적합성:** Convex의 보안 모델은 대부분 사용자 영역에 있습니다 – 확인을 작성합니다. 이는 ACL을 우리 방식으로 구현할 수 있는 완전한 유연성을 제공합니다. 외부 서비스에 정책을 첨부하는 것보다 선호합니다. Convex 함수 내에서 ctx.auth.getUserIdentity()는 요청을 수행하는 사용자를 제공합니다[[53]](https://www.convex.dev/components/files-control#:~:text=handler:%2520async%2520\(ctx,%2520args\)%2520=,Unauthorized). 그런 다음 허용 목록에 없으면 간단히 필터링하거나 발생시킵니다. 이 간단한 접근 방식은 최소한의 성능 오버헤드와 복잡성을 의미합니다(목록 확인만).
- **대안 복잡성 대 이점:** 작업에 대한 역할 및 권한이 있는 전체 역할 기반 액세스 제어와 같은 더 정교한 시스템은 과도해 보였습니다. 접근 방식은 기본 사항을 다룹니다: 누가 읽을 수 있는지, 누가 쓸 수 있는지, 시간 게이팅. Notion 또는 Coda가 공유를 처리하는 방법과 유사합니다(사람에게 block 또는 페이지 수준 공유).
- **최소한의 마찰 보장:** 사용자가 관리자가 역할을 구성할 필요 없이 콘텐츠를 쉽게 공유할 수 있기를 원합니다. 따라서 사용자는 권한이 있는 경우 block의 ACL에 누군가의 이메일(사용자 ID)을 직접 추가할 수 있습니다. 이 분산 공유는 협업을 개선합니다. 한편 내장된 embargo 옵션은 사전 게시 연구 또는 시간에 민감한 발표와 같은 사용 사례에 어필할 것입니다.

## 고려된 대안

- **문서 수준 권한만:** 최상위 문서만 ACL을 가지고 모든 자식 block이 완전히 상속하도록 단순화하는 것을 생각했습니다(block별 차이 없음). 이는 실제로 사용자가 일반적으로 사용하는 방법일 것입니다(전체 문서를 공유하거나 공유하지 않음). 해당 규칙을 강제하면 강제를 단순화합니다(최상위만 확인). 그러나 공유된 문서에 비공개 섹션을 가질 수 있는 유연성을 제거합니다. 지금은 block별 ACL의 가능성을 유지하기로 결정했지만 UI는 혼란을 피하기 위해 하나의 문서에서 비공개/공개를 혼합하는 것을 권장하지 않을 수 있습니다.
- **역할 기반 액세스:** 역할(예: "admin", "member", "viewer" 등)을 사용하고 block에 역할을 할당합니다. 이는 ACL 위의 계층일 수 있습니다(사용자 ID를 나열하는 대신 역할을 나열하고 전역 사용자-역할 매핑을 가짐). MVP의 경우 모든 사용자가 기본적으로 동등한 협력자이고 필요한 경우 "admin"은 단순히 모든 곳에 추가되어 액세스할 수 있는 사용자일 수 있기 때문에(또는 모든 최상위 문서의 소유자라는 이유로) 이 복잡성을 건너뜁니다.
- **기능 링크 (비밀 토큰이 있는 공유 가능한 링크):** 명시적 사용자 목록 대신 비밀 URL을 통한 공유를 구현하는 것을 고려했습니다(Google Docs를 "링크가 있는 모든 사람"과 공유하는 방법처럼). 이는 토큰을 생성하고 해당 토큰에 대한 로그인이 필요하지 않음을 의미합니다. 유용한 기능입니다(특히 공개 공유의 경우). "public" 플래그를 통해 부분적으로 얻을 것입니다(본질적으로 모든 사람에게 알려진 전역 링크와 같음) 또는 대역 외로 수동으로 초대 링크를 생성하여. 그러나 MVP는 사용자 신원 기반 공유에 초점을 맞출 것입니다. "public" 플래그는 모든 사람에게 알려진 토큰의 특수한 경우로 볼 수 있습니다. 토큰을 생성하고 block ACL에 수락된 키로 저장하여 초대 링크를 구현할 수도 있습니다(의사 사용자 키처럼). 시간으로 인해 공개로 표시하거나 표시하지 않는 것 이상으로 MVP에서 건너뛸 것입니다.
- **암호화 기반 보안:** 또 다른 접근 방식은 특정 사용자를 위해 콘텐츠를 암호화하여 서버도 키 없이 읽을 수 없도록 하는 것입니다. 이는 제로 트러스트 접근 방식입니다. 협업을 복잡하게 만들고(키 배포) 내부 MVP를 위해 서버 환경을 신뢰하기 때문에 선택하지 않았습니다. 보안 요구가 증가하면 특정 block에 대한 엔드 투 엔드 암호화를 고려할 수 있지만 지금은 아닙니다.
- **Embargo 없음, 수동 제어만:** embargo에 대한 가장 간단한 접근 방식은 "사용자가 수동으로 전환할 때까지 block을 표시하지 않음"입니다. 그러나 이는 인간에 의존하며 실패할 수 있습니다. 자동화하는 것은 작은 노력이며 정확성에 대한 높은 보상입니다. 따라서 포함했습니다. 또 다른 대안은 embargo를 block 세트를 추적하고 릴리스하는 별도의 "Embargo" 객체로 구현하는 것입니다 – 불필요한 오버헤드입니다. block의 타임스탬프로 충분합니다.

## 영향

- **사용자 인터페이스 및 사용성:** UI에서 공유 제어를 노출해야 합니다. 이는 Google Docs와 유사하게 공유할 이메일을 입력하는 문서의 "공유" 대화 상자만큼 간단할 수 있습니다. 프론트엔드에서 Convex 함수를 호출하여 구현해야 합니다. 여러 block(모든 자식과 같은)을 업데이트해야 하는 경우 많으면 느릴 수 있습니다 – 그러나 관리 가능할 것입니다(또는 최상위 수준에서 강제).
- **상태 관리:** 각 block의 ACL은 이제 상태의 일부입니다. ACL 정보를 주 협업 편집 스트림에서 제외하여 빈번한 업데이트를 피하고 싶을 수 있습니다(예: ACL 변경이 텍스트 편집과 충돌하는 것을 원하지 않음). ProseMirror step 외부의 별도 변경을 통해 ACL 업데이트를 처리할 것입니다. 드물게 변경되는 메타데이터이므로 문제가 없습니다.
- **확인 성능:** 사용자 ID 목록의 멤버십 확인은 목록이 거대하지 않는 한 사소합니다. 일반적으로 block은 수십 명이 아닌 소수 또는 수십 명의 사용자와 공유될 수 있습니다(공개 제외, 플래그로 취급). 따라서 성능이 괜찮습니다. 공개의 경우 public:true를 "목록을 확인할 필요 없음"으로 해석하거나 공개를 나타내기 위해 readers 목록에 userId "*"와 같은 특수 마커를 삽입할 수 있습니다. 일관되게 처리하기만 하면 됩니다. 아마도 부울이 더 간단합니다.
- **데이터 중복:** ACL을 자식 block에 전파하는 경우 많은 block에 중복 목록을 저장합니다. 이는 중복이지만 빠른 권한 확인을 보장합니다(block 자체만 확인). 위험은 불일치입니다(부모의 ACL이 업데이트될 때 자식의 ACL이 업데이트되지 않음). 공유 함수에서 신중하게 관리해야 합니다(예: 항상 트랜잭션을 사용하거나 모든 자식을 업데이트하기 위한 여러 변경 호출). 또는 자식에 전혀 저장하지 않고 항상 부모를 참조합니다 – 그러나 block이 다른 문서로 이동하면 손상됩니다. 자체 포함 정보를 위해 각 block에 저장하는 쪽으로 기울어지며, 동기화 상태를 유지하는 복잡성을 수용합니다(공유가 대부분 문서 수준인 경우 더 쉬울 수 있음).
- **Convex Auth 및 신원**: Convex의 사용자 신원(OAuth 주체 문자열 또는 Convex 사용자 Id일 가능성이 높음)에 의존하여 ACL의 사용자를 식별합니다. 이메일이 변경될 수 있으므로 이메일이 아닌 안정적인 고유 ID(Auth0의 sub 또는 GitHub ID 문자열과 같은)를 사용해야 합니다. Convex Auth는 안정적인 identity.subject를 제공합니다[[53]](https://www.convex.dev/components/files-control#:~:text=handler:%2520async%2520\(ctx,%2520args\)%2520=,Unauthorized). ACL 목록의 키로 사용할 것입니다.
- **향후 연합 영향:** 단일 인스턴스에서 사용자 ID는 고유합니다. 연합 미래에서 신원은 더 복잡할 것입니다(user@instance와 같은). 연합하는 경우 ACL은 외부 사용자를 참조해야 할 수 있습니다. 향후 문제입니다 – 그러나 확장 경로에서 언급할 가치가 있습니다.
- **보안**: ACL 우회가 없도록 해야 합니다. 이는 모든 쿼리와 변경을 감사하여 확인을 강제함을 의미합니다. 예: block을 편집하는 변경은 ctx.auth 사용자가 권한이 있는지 확인해야 합니다. edge를 통해 block을 찾는 쿼리는 볼 수 없는 것을 필터링해야 합니다. 실수로 데이터를 유출하지 않도록 주의해야 합니다(숨겨진 block의 ID를 반환하는 edge 쿼리는 이미 유출). edge 쿼리에서 block 액세스와 조인할 수 있습니다: 예: block에 대한 참조를 나열할 때 사용자가 읽을 수 없는 참조 block을 필터링하고, 대상이 숨겨진 block인 경우 사용자가 처음에 요청하지 않았을 것입니다. 까다롭지만 가능합니다 – 본질적으로 block의 존재나 콘텐츠를 드러낼 수 있는 모든 경로에는 권한이 필요합니다. 이를 보장하기 위한 테스트를 작성할 것입니다.
- **Embargo 처리 복잡성:** block이 embargo 중이고 공개 플래그가 true인 경우 코드는 시간까지 숨겨야 합니다. UI도 고려해야 합니다 – 소유자에게 "X까지 embargo됨" 레이블과 함께 표시할 수 있습니다. 시간 후 자동으로 일부 상태를 전환합니다(새로 고침 또는 푸시가 필요할 수 있음). embargo를 해제하기 위해 cron 작업을 구현하는 경우 사용자에게 알리거나 뷰어를 위해 콘텐츠를 자동으로 새로 고칠 수도 있습니다. 그것 없이 뷰어는 시간이 지난 후 새로 고칠 때까지 아무것도 보지 못할 수 있습니다. 아마도 허용 가능합니다. 더 간단할 수 있습니다: 공개 embargo된 block의 경우 시간까지 다른 사람에게 존재하지 않는 것처럼 취급한 다음 나타납니다. 사용자를 놀라게 할 수 있지만 embargo의 정의상 예상됩니다.
- **시간적 엣지 케이스:** 시간대 및 정확한 타이밍 – DB에 UTC로 embargoUntil을 저장하고 서버의 Date.now()와 비교합니다(UTC epoch이기도 함). 사소한 문제: cron을 시간마다만 실행하는 경우 cron에 의존하면 embargo가 최대 59분 늦게 해제될 수 있습니다. 액세스 시에도 확인하는 것이 좋습니다. 아마도 결합: cron(또는 이상적으로 정확한 시간에 작업을 예약할 수 있는 경우 Convex "스케줄링", 사용 가능한지 확실하지 않음)을 사용하여 isEmbargoLifted 등을 전환하되, 읽기 로직에서도 항상 시간을 다시 확인합니다. 이렇게 하면 최악의 경우 cron이 아직 실행되지 않았더라도 embargo를 지난 것을 보는 읽기 함수가 public:true가 아직 설정되지 않았더라도 액세스를 허용합니다.
- **테스트 시나리오:** 허용되지 않은 사용자가 가능한 모든 방법(직접 가져오기, edge를 통해, 검색이 있는 경우 검색을 통해 등)을 통해 block을 검색할 수 없고 embargo가 작동하는지(예: 사용자가 시간 전에 embargo된 공개 block에 액세스하려고 하면 거부됨) 테스트해야 합니다.
- **협업과의 상호 작용:** block이 협업(공유 편집)인 경우 모든 편집자는 쓰기 권한이 있을 것입니다. 권한과 함께 동시 편집을 처리해야 합니다 – 이상적으로 ProseMirror 협업은 쓰기 권한이 있는 경우에만 시작됩니다. 변경 수준에서 작성자만 step을 제출할 수 있도록 강제해야 합니다. 사용자가 읽기 전용이고 어떻게든 편집을 제출하려고 하면 함수가 거부합니다. 또한 UI에서 편집기를 읽기 전용으로 만들 수 있습니다. 따라서 프론트엔드에 해당 상태를 통합합니다(예: writers에 없으면 입력을 허용하지 않음).
- **복사/이동 시 전파:** block이 이동되는 경우(다른 문서로 잘라내기-붙여넣기) ACL은 어떻게 되는가? 이동 후 새 부모의 ACL을 상속해야 할 수 있습니다(특히 비공개에서 공유 문서로 또는 그 반대로 이동하는 경우). 이를 해결해야 합니다: 이동 변경은 ACL을 다시 계산하거나 사용자에게 결정하도록 요청해야 합니다. 가장 간단한: block을 새 부모 아래로 이동하는 경우 ACL을 새 부모와 일치하도록 자동으로 설정할 수 있습니다(이동하는 사용자가 그렇게 할 권한이 있다고 가정). 일부 이전 권한을 잃게 되면 경고할 수 있습니다. MVP는 사용자에게 노출된 복잡한 이동 작업이 없을 가능성이 높지만 시스템은 수행되는 경우 처리해야 합니다.

## 확장 경로

- **그룹 공유:** 많은 사람에게 공유를 단순화하기 위해 그룹 또는 팀 개념을 추가합니다. 예를 들어, block에 30명의 사용자를 나열하는 대신 해당 30명을 포함하는 "Research Team" 그룹을 가지고 해당 그룹에만 공유합니다. 구현: 그룹은 id와 사용자 id 목록이 있는 Convex 객체일 수 있습니다. ACL은 그룹 id인 항목을 허용할 수 있습니다(사용자 id와 구별 가능). 확인 함수는 그룹 멤버십을 해결합니다. 이는 중복 목록을 줄이고 새 팀 구성원을 추가하는 것을 더 쉽게 만듭니다(그룹에만 추가). 사용자 기반이 증가하면 논리적 다음 단계입니다.
- **역할 및 권한 매트릭스:** "viewer" 대 "editor"와 같은 역할을 정의할 수 있습니다. 현재 ACL은 암시적으로 이를 처리합니다(readers와 writers를 분리한 경우). 역할을 공식화할 수 있습니다: 예: "commenter" 역할을 도입할 수 있습니다(댓글 기능이 있는 경우) 또는 "owner" 대 "co-editor". 지금 소유자는 생성자일 뿐이며 명시적으로 목록에 없습니다(또는 명확성을 위해 포함될 수 있음). 역할을 확장하는 것은 ACL 항목에 메타데이터를 추가하거나 권한 타입당 별도의 ACL 목록에 관한 것입니다. 호환성을 유지하면서 수행할 수 있습니다(구조를 확장하기만 하면 됨).
- **계층적 권한:** 부모를 공유하면 자동으로 동적으로 모든 자식을 공유하는(및 향후 자식) 구조를 원하는 경우 상속 모델을 구현할 수 있습니다. 예를 들어, block의 플래그 "재정의되지 않는 한 부모로부터 ACL 상속". 이를 통해 문서에 재정의하는 섹션을 가질 수 있습니다(하나의 하위 block을 추가 제한 또는 개방으로 표시하는 것과 같은). 이 복잡성은 필요한 경우 토글할 수 있습니다. 그런 다음 권한 확인을 변경하여 명시적 ACL이 있는 block을 찾거나 최상위에 도달할 때까지 위로 걸어갑니다. 지금은 각 확인에서 오버헤드를 피하기 위해 이를 수행하지 않습니다.
- **공개 게시 및 연합:** 공개 액세스를 허용하는 경우(로그인 없음) 공개 엔드포인트를 통해 콘텐츠를 전달해야 할 수 있습니다(Next.js 렌더링 페이지 또는 Convex HTTP 엔드포인트일 수 있음). 공개 플래그를 따르도록 해야 합니다. 연합의 경우(ActivityPub과 같은 것과 통합하여 공개 콘텐츠를 브로드캐스트하는 경우) 권한 모델은 "공개"가 세계 읽기 가능을 의미하도록 정렬해야 합니다. 이 경우 embargo는 즉시가 아닌 나중에 연합 브로드캐스트를 예약하는 것으로 변환될 수 있습니다. 흥미로운 확장이 될 것입니다 – ACL 플래그를 연합 제어에 연결합니다.
- **감사 로그:** 엔터프라이즈 컨텍스트에서 누가 언제 어떤 민감한 block에 액세스했는지 로그를 원할 수 있습니다. 나중에 쿼리에 로깅을 추가할 수 있습니다(무거울 수 있음) 또는 더 나은 방법으로 액세스의 전용 시스템 로그. 최소한 권한 변경을 로깅하는 것이 중요합니다(누가 무엇을 누구와 공유했는지). 감사 컬렉션에 ACL 변경을 기록할 수 있습니다. 이는 보안을 의식하는 배포를 위한 확장입니다.
- **임시 액세스 링크:** 시스템에 없는 사람과 공유하기 위해 시간 제한 링크를 생성하는 기능을 제공합니다("외부 협력자와 7일 동안 공유"와 같은). 이는 block에 매핑되고 만료가 있는 일회용 토큰을 생성하고 ACL에 만료가 있는 토큰으로 항목을 저장하는 것을 포함합니다. 아키텍처는 ACL에서 토큰을 의사 사용자로 취급하고 요청에서 처리하여 이를 통합할 수 있습니다(요청이 토큰을 제공하는 경우 일치). Convex HTTP 엔드포인트를 사용하여 이러한 토큰을 소비할 수 있습니다. 이는 사소하지 않은 기능이지만 유용합니다. 사용자 신원을 넘어 베어러 토큰을 포함하도록 권한 모델을 확장합니다.
- **Mastra와의 향후 통합 (AI 에이전트):** block을 읽거나 쓸 수 있는 AI 에이전트(공동 과학자 어시스턴트)를 추가하는 경우 특수 권한을 부여해야 할 수 있습니다. 한 가지 접근 방식: 에이전트를 특수 사용자 신원으로 취급합니다(자체 ID와 적절한 ACL 항목 포함). 또는 에이전트가 사용자의 권한으로 작동하도록 허용합니다(사용자의 컨텍스트에서 실행되는 것처럼). 세밀한 보안을 위해 각 에이전트를 특정 데이터에 화이트리스트할 수 있습니다. ACL에 "agent" 플래그를 추가하거나 단순히 사용자로 포함하는 것을 고려할 것입니다. 현재 모델은 이미 허용 목록에 에이전트의 userId를 포함할 수 있습니다.
- **다중 테넌시 준비:** 향후 하나의 Convex 인스턴스에서 여러 개별 조직을 지원하는 경우 block 및 edge에 "workspace" 또는 "tenant" 필드를 추가하고 ACL이 주로 교차 테넌트 공유를 허용하지 않도록 보장합니다(또는 매우 명시적인 경우). MVP를 넘어설 수 있지만 고려됩니다: 권한 확인은 테넌트별로도 격리됩니다. 모든 쿼리에 테넌트 컨텍스트를 포함할 것입니다. 지금은 하나의 테넌트 또는 모든 사용자가 잠재적으로 서로를 알고 있다고 가정합니다.
- **세분화된 시간 제어:** embargo를 더 일반적인 시간 기반 규칙으로 확장할 수 있습니다(특정 시간 동안만 또는 특정 이벤트 후에만 액세스 가능). 예를 들어, block은 첫 번째 보기 후 24시간 동안 표시될 수 있습니다(만료 정보와 같은). 이는 전문화된 시나리오입니다(시간 제한 시험 콘텐츠와 같은). 필요한 경우 유사한 접근 방식으로 구현할 수 있습니다: 릴리스 및/또는 만료 타임스탬프를 저장합니다. 일반적으로 아키텍처는 embargoUntil과 유사한 expiresAt을 지원합니다(반대: 해당 시간 후 액세스 취소). 실제로 시간 X에 ACL에서 해당 사용자를 제거하도록 예약하여 만료를 구현할 수 있습니다. 또는 ACL 항목 자체에 만료를 저장하여. 지금은 하지 않지만 확장은 Files Control이 다운로드 권한에 대한 만료를 처리하는 방법에서 아이디어를 빌릴 수 있습니다[[60]](https://www.convex.dev/components/files-control#:~:text=storageId,%2520maxUses:%25201,%2520expiresAt:%2520Date,).
- **UI/UX 개선:** 결국 액세스 권한이 있는 모든 사용자를 표시하고, 보기 대 편집 권한을 설정하고, 소유권을 이전하는 등의 권한 관리 UI를 구현할 수 있습니다. 저장하는 데이터를 기반으로 한 제품 작업입니다.
- **정책 템플릿:** 일부 환경에서는 "프로젝트 X 아래에 생성된 모든 block은 기본적으로 그룹 Y와 공유되어야 함"과 같은 정책이 있을 수 있습니다. 더 높은 수준에서 템플릿 또는 규칙을 구현할 수 있습니다. 아키텍처는 생성 흐름에 연결하거나 함수가 읽는 구성을 가짐으로써 새 콘텐츠에 ACL을 자동 설정할 수 있습니다. 예를 들어, block이 "ProjectX" 부모 아래에 있는 경우 생성 시 ACL에 groupX를 자동 추가합니다.
