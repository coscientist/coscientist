---
title: "ADR 2: Versioning Strategy (Steps, Snapshots, and User-Facing Versions)"
---

# ADR 2: Versioning Strategy (Steps, Snapshots, and User-Facing Versions)

## Context

In a collaborative editing environment, tracking versions of content is critical. Users will be concurrently editing blocks, and we need to record those changes for real-time sync, history, and potential rollbacks. The challenge is to manage _fine-grained changes_ (so that realtime merging is smooth) while also providing _meaningful version history_ to users without overwhelming them with every tiny edit. Additionally, loading a document should be efficient – we cannot reapply an infinite log of operations from the beginning for each new collaborator. We need a strategy that balances **granularity, performance, and clarity** in versioning.

## Decision

**Adopt a three-tier versioning approach:** (1) **Steps** as atomic changes for real-time collaboration, (2) **Snapshots** as periodic full-state checkpoints for efficiency, and (3) **User-Facing Versions** as labeled milestones in history.

- **Steps (Operational Changes):** We record every edit operation as a _Step_. In the context of ProseMirror, a Step is a small change like "insert text at position X" or "delete 5 characters at range Y". Each step is associated with the specific Block or document being edited and carries the base version it was applied to. Steps are stored in a Convex table (e.g. steps) with fields: {documentId, stepData, version, clientId, timestamp}. We assign a monotonic **version number** to each document which increments with each confirmed step, similar to ProseMirror's linear version counter[[3]](https://marijnhaverbeke.nl/blog/collaborative-editing.html#:~:text=changes%2520in%2520a%2520different%2520order,will%2520produce%2520the%2520same%2520document). This version is essentially the "source-of-truth" state index.
- **Snapshots (Periodic Checkpoints):** We regularly capture the entire content state as a Snapshot. A snapshot might be the full ProseMirror document JSON for a given block/document at a certain version. Snapshots are stored in a snapshots table: {documentId, version, contentState, timestamp}. We implement a **debounced snapshot** mechanism: after a flurry of edits, when a document has been idle for a short interval (say 1 second) and the last editor was the current user, the client will package up the full document state and send it to the server as a snapshot[[4]](https://github.com/get-convex/prosemirror-sync#:~:text=*%2520Server,side,%2520enabling%2520easy%2520AI%2520interoperation)[[5]](https://github.com/get-convex/prosemirror-sync#:~:text=const%2520prosemirrorSync%2520=%2520new%2520ProsemirrorSync\(components,//). This means we snapshot only stable states to avoid excessive overhead. New collaborators can then load the latest snapshot and skip applying a long chain of old steps[[6]](https://github.com/get-convex/prosemirror-sync#:~:text=Configuring%2520the%2520snapshot%2520debounce%2520interval).
- **User-Facing Versions:** To avoid exposing every low-level step to end users, we define higher-level version markers. These could be automatically generated (e.g. daily versions or after a significant pause in editing) or manually created ("Save Version" action). A user-facing version basically points to a particular snapshot or a checkpoint in the step log with a friendly name or number. We might maintain a list of these in a versions log with metadata (author, label, timestamp, snapshot reference). In MVP, we can treat snapshots themselves as the user-visible versions (since they represent document states at certain times). Eventually, we can allow users to tag certain snapshots (or create one on demand) to serve as notable versions.

Under this scheme, **the document's state is reconstructed by starting from the latest snapshot and applying subsequent steps**. A brand new client will fetch (via Convex) the latest snapshot and the list of steps after that snapshot. This prevents needing the entire history since inception. We will also implement **history truncation**: older steps that are no longer needed (because a snapshot exists after them) can be archived or deleted to save space[[4]](https://github.com/get-convex/prosemirror-sync#:~:text=*%2520Server,side,%2520enabling%2520easy%2520AI%2520interoperation). The Convex ProseMirror sync component even includes an API for deleting old snapshots/steps safely[[7]](https://github.com/get-convex/prosemirror-sync#:~:text=*%2520Server,for%2520old%2520snapshots%2520&%2520steps), which we will leverage or mimic.

## Rationale

This multi-tier approach is inspired by best practices in collaborative editing and source control:

- **Fine-grained OT for concurrency:** The Step log (with version numbers) is essential for real-time OT (Operational Transform) style merging. By assigning each change a version and rebasing out-of-order changes, we ensure a linear history as ProseMirror's algorithm expects[[8]](https://marijnhaverbeke.nl/blog/collaborative-editing.html#:~:text=Like%2520OT,%2520ProseMirror%2520uses%2520a,will%2520produce%2520the%2520same%2520document). If we only saved infrequent whole-document versions, we'd lose detail needed to merge concurrent edits correctly.
- **Snapshots for performance:** Over time, a document might accumulate thousands of steps. Replaying all from the beginning would be slow. Snapshots let a new user start from a recent state and avoid replaying an entire history[[4]](https://github.com/get-convex/prosemirror-sync#:~:text=*%2520Server,side,%2520enabling%2520easy%2520AI%2520interoperation). This is analogous to database checkpointing or the way Git uses full tree objects on commit – it bounds the work needed to reconstruct state.
- **User-friendly version history:** A raw list of every keystroke (step) is not useful to humans. Snapshots provide more meaningful states (e.g. after a paragraph was finished). By exposing selected snapshots (or combining steps into larger "commits"), we give users a comprehensible version history. This aligns with the idea of **commit-based collab** where multiple step updates are grouped into one commit on the backend[[9]](https://stepwisehq.com/blog/2023-07-25-prosemirror-collab-performance/#:~:text=The%2520gist%2520is%2520that%2520we,them%2520back%2520to%2520the%2520clients). We plan to **batch consecutive steps** from one user into logical commits when possible, so the history isn't flooded with trivial edits. For example, typing a word might produce several character insert steps, but we can treat the whole word insertion as one version when viewing history.
- **Compatibility with ProseMirror and Convex:** ProseMirror's collaboration schema already includes the concept of steps and versions, and the Convex _prosemirror-sync_ component implements snapshots and step handling with a debounce[[10]](https://github.com/get-convex/prosemirror-sync#:~:text=,side,%2520enabling%2520easy%2520AI%2520interoperation)[[11]](https://github.com/get-convex/prosemirror-sync#:~:text=Configuring%2520the%2520snapshot%2520debounce%2520interval). By following this model, we leverage known, tested patterns. The "version" integer is simple to work with (monotonic counter) and fits nicely in Convex data (just a number to compare).
- **Recovery and Auditing:** With this strategy, we can retrieve any past version of a document by applying steps to a snapshot, facilitating features like "view history" or "undo to an earlier version". It also provides an audit log of changes (who made what edit when, if we include user IDs in step records). Storing snapshots periodically also guards against cases where a long sequence of operations might otherwise be lost or too costly to recover.

## Alternatives Considered

- **No Fine-Grained History (Last-write wins):** Simply store the latest content state for each block, overwriting on edits. This was rejected because it cannot support collaborative editing or undo. It would also lose all history – unacceptable for our knowledge system where tracking changes is important.
- **Only Storing Full Snapshots (Document per Version):** We considered saving a full copy of the document for each significant change (like a version history without steps). While simple, this would be very storage-inefficient for large content and makes merging concurrent edits hard (you'd have to do content diff/merge, effectively re-implementing OT or CRDT from scratch).
- **CRDT-based Versioning (e.g. Yjs):** CRDTs natively allow merging and have an inherent version-less conflict-free history. We decided against this for MVP because it complicates integration with ProseMirror's schema and increases data size (CRDT tombstones, etc.). ProseMirror's own collab approach (OT with central authority) is sufficient and simpler given a centralized server[[12]](https://marijnhaverbeke.nl/blog/collaborative-editing.html#:~:text=The%2520design%2520decisions%2520that%2520make,be%2520interesting%2520to%2520work%2520on). We do note CRDT as a future option if offline editing or decentralized operation is needed (see Expansion Path).
- **Git-like Tree of Commits:** Another idea was to treat each saved version as a commit in a chain, possibly branching for concurrent edits and then merging. This is powerful (allows branching/forking documents) but adds a lot of complexity to the model and UI. We opted for a linear history for MVP, aligning with ProseMirror's linear version (which "can be denoted by an integer" and does not natively support divergent branches in real-time collab)[[13]](https://marijnhaverbeke.nl/blog/collaborative-editing.html#:~:text=changes%2520on%2520top%2520of%2520them,,before%2520retrying%2520the%2520push).

## Implications

- **Storage Growth:** Every edit generates a step record, and periodic snapshots duplicate the document content. We must manage storage by pruning old data. We will likely implement a **retention policy**, e.g., keep all steps for the last X days and snapshots for key versions, but purge older fine-detail if space becomes an issue. The Convex collaboration component provides an API to delete old snapshots/steps which we can use[[7]](https://github.com/get-convex/prosemirror-sync#:~:text=*%2520Server,for%2520old%2520snapshots%2520&%2520steps).
- **Conflict Resolution UX:** At the technical level, conflicts are handled by OT (rebasing). However, from a user perspective, simultaneous edits can produce confusing results in the content (e.g., interleaved text). Our versioning captures what happened but doesn't _prevent_ overlaps. Users might see content change rapidly if two people edit the same sentence. The version history will show both edits sequentially. We might need to highlight conflicts or at least ensure presence indicators (ADR 7) warn users when editing nearby.
- **Version Numbers and Client State:** Each block or document will have a current versionNumber. Clients must track their local version and on each sync with server, update it. If a client is offline and comes back, it will need to fetch all steps since its last known version. This is supported by our model (get steps > version X from Convex). However, if a client falls too far behind (e.g., their last version snapshot was vacuumed away), we'll send a snapshot instead (the server can detect if the number of missing steps is large and send a snapshot to re-sync).
- **User Interface for History:** Initially, we might not expose a full history UI to end users, but internally we have the data. Down the line, showing a timeline of changes or allowing "undo to here" will be possible by leveraging snapshots and steps. We will have to reconcile how to display batched steps (we may group steps by time or by author when showing history).
- **Audit and Attribution:** Each step can carry the user ID of its author and a timestamp. This allows us to build an audit log for each block. It's important for knowledge systems to know who contributed what. Storing this at step granularity means a very detailed audit. We might summarize it at snapshot/version level for ease (e.g., "Alice edited this paragraph at 10:45, Bob edited at 10:47").

## Expansion Path

- **CRDT or Offline Support:** In the future, if we need offline editing or a decentralized server network, we might shift from pure OT to a CRDT-based approach (e.g., Yjs). CRDTs don't require a central source-of-truth and can merge changes without explicit snapshots. We would then store CRDT states or updates instead of ProseMirror steps. The current architecture can accommodate this by swapping out the collaboration engine (see ADR 3 expansion) – possibly using a Yjs-specific Convex component if available[[14]](https://github.com/get-convex/prosemirror-sync#:~:text=,and%2520doesn't%2520have%2520local%2520changes). This would let multiple servers or offline clients converge state without a linear version.
- **Named Versioning and Branching:** We plan to introduce the concept of "named versions" (like git tags or branches) for major milestones. For example, a user could mark a block or document as "v1.0 Published". This could simply create a snapshot with a label. In the future, branching (forking a block into two divergent versions) could be supported for scenarios like proposing alternate edits or forking knowledge in different directions. Our step/snapshot model would then need to maintain multiple parallel logs, which is a non-trivial extension but conceptually possible by keying steps to branch IDs.
- **Global Version Clock or Federated Versioning:** If blocks become referenced across different domains or systems, we might need a more global version identification. For instance, if two different Convex deployments exchange a block, how to merge their edits? A potential expansion is using something like **Lamport timestamps or vector clocks** for versioning in a federated setting instead of a single integer. This would pair with CRDT approaches if federation is needed.
- **Optimized Batch Commits:** Building on the idea of step batching, we may implement a server-side commit aggregation. For example, instead of immediately broadcasting each individual step, the server could accumulate steps from multiple users that are based on the same prior version and apply them in one logical commit (transforming them as needed). This approach, as noted by research[[9]](https://stepwisehq.com/blog/2023-07-25-prosemirror-collab-performance/#:~:text=The%2520gist%2520is%2520that%2520we,them%2520back%2520to%2520the%2520clients), can reduce the problem of high-latency users being starved out by continuous conflicts. Implementing this would mean the server sometimes accepts out-of-order steps and internally transforms them to avoid rejecting them (which is a more advanced algorithm). If needed, we can iterate towards this to improve collab smoothness under heavy load.
- **Integration with Workflow/AI (Mastra):** Version history could be leveraged by AI agents (see ADR 8). For example, an agent could analyze the diffs between versions to summarize changes or to revert problematic edits automatically. Our structured history would enable such capabilities. We might add **difference storage** (precomputed diffs) for quick comparisons if that becomes a frequent operation for agents or UI.
