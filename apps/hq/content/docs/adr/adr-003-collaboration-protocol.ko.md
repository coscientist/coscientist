---
title: "ADR 3: 협업 프로토콜 (ProseMirror OT, Step 일괄 처리, 충돌 처리)"
---

# ADR 3: 협업 프로토콜 (ProseMirror OT, Step 일괄 처리, 충돌 처리)

## 컨텍스트

여러 사용자가 **동일한 block 또는 문서를 실시간으로 편집**하고 서로의 변경 사항을 즉시 볼 수 있어야 합니다. 동시 편집을 안정적으로 병합하는 협업 프로토콜이 필요합니다. ProseMirror는 리치 텍스트 편집 프레임워크로 선택되었으며, 중앙 집중식 방식의 Operational Transformation(OT)을 기반으로 하는 협업 모듈과 함께 제공됩니다. 이를 Convex 백엔드와 통합해야 합니다. 주요 과제는 변경 순서 지정(분기 상태 방지), 네트워크 지연 차이, 충돌 해결(동시에 발생하는 변경이 모든 사용자에게 일관되게 적용되도록 보장)입니다. 또한 **높은 지연 시간 사용자**가 반복적인 OT 리베이스로 고통받는 알려진 문제를 완화하고자 합니다(다른 사람의 편집이 먼저 들어오면 변경 사항이 거부되고 재시도해야 함)[[15]](https://stepwisehq.com/blog/2023-07-25-prosemirror-collab-performance/#:~:text=During%2520sessions%2520with%2520a%2520high,and%2520the%2520client%2520backlogs%2520clear). 프로토콜 설계는 실시간 응답성과 공정성 및 일관성의 균형을 맞춰야 합니다.

## 결정

**서버에서 일괄 처리된 step 커밋으로 향상된 협업 텍스트 편집을 위해 ProseMirror의 중앙 집중식 OT 기반 알고리즘을 사용합니다.** 실제로 이는 다음을 의미합니다:

- 각 문서의 상태에 대해 Convex 백엔드에서 **단일 진실의 원천**을 실행합니다(OT 용어로 "권한"). 클라이언트는 서로 직접 피어 투 피어로 동기화하지 않습니다. 모든 변경 사항은 Convex를 통해 전달됩니다.
- 클라이언트는 ProseMirror 협업 플러그인 또는 Convex-prosemirror 통합을 사용합니다. 각 클라이언트는 문서의 자체 로컬 버전 번호를 유지합니다. 사용자가 편집하면 하나 이상의 ProseMirror Step 객체가 생성됩니다. 클라이언트는 step을 로컬에서 **낙관적으로 적용**하고 기반으로 한 버전 번호와 함께 Convex 함수(예: submitSteps)로 보냅니다.
- Convex 서버 함수는 이러한 step을 수신하고 버전을 확인합니다.
- step의 기본 버전이 해당 문서에 대한 서버의 현재 버전과 일치하면 서버는 이를 수락합니다. 문서의 버전을 증가시키고 step을 steps 테이블(ADR 2)에 커밋된 것으로 기록합니다. 그런 다음 모든 구독된 클라이언트에 step을 브로드캐스트합니다(Convex의 실시간 푸시가 알림).
- 기본 버전이 오래된 경우(다른 사용자의 step이 먼저 도착) 서버는 지금 들어오는 step을 **거부**합니다. 클라이언트는 알림을 받거나(또는 최신 변경 사항을 가져올 때 자체 변경 사항이 적용되지 않은 것을 보고 추론) 리베이스해야 함을 알게 됩니다. 클라이언트는 놓친 새 step을 가져오고(Convex는 마지막으로 본 버전에서 getSteps 제공) ProseMirror를 사용하여 최신 문서 상태 위에 **확인되지 않은 step을 리베이스**합니다[[16]](https://marijnhaverbeke.nl/blog/collaborative-editing.html#:~:text=By%2520using%2520a%2520central%2520server,,them,%2520before%2520retrying%2520the%2520push). 로컬에서 리베이스한 후(위치 매핑을 사용하여 step을 새 콘텐츠에 조정[[17]](https://marijnhaverbeke.nl/blog/collaborative-editing.html#:~:text=Position%2520Mapping)) 클라이언트는 step을 다시 보냅니다. 이 루프는 step이 수락될 때까지 계속됩니다.
- 두 수준에서 **step 일괄 처리**를 구현할 계획입니다:
- **클라이언트 측 일괄 처리:** 클라이언트는 빠르게 연속해서 발생하는 경우 여러 로컬 step을 하나의 제출로 묶습니다. 예를 들어, ProseMirror의 협업 플러그인은 이미 "확인되지 않은" step을 수집하고 주기적으로 서버에 일괄로 보낼 수 있습니다[[18]](https://stepwisehq.com/blog/2023-07-25-prosemirror-collab-performance/#:~:text=ProseMirror,at%2520which%2520point%2520they%2520must). 오버헤드를 줄이고 단일 문자 step으로 서버를 넘치지 않도록 조정합니다(예: 50-100ms마다 또는 텍스트 입력 일시 중지 시 전송).
- **서버 측 커밋 일괄 처리:** 기본 OT 모델에서는 주어진 문서 버전에 대해 한 클라이언트의 변경만 수락되고 다른 클라이언트는 리베이스하도록 거부되어 느린 연결을 굶길 수 있습니다[[15]](https://stepwisehq.com/blog/2023-07-25-prosemirror-collab-performance/#:~:text=During%2520sessions%2520with%2520a%2520high,and%2520the%2520client%2520backlogs%2520clear). 이를 개선하기 위해 Convex 함수는 완전히 거부하는 대신 **동시 제출을 병합**하려고 시도합니다. 구체적으로, 두 세트의 step이 서버에 거의 동시에 도착하는 경우(둘 다 버전 N 기반) 하나를 버전 N+1의 승자로 선택하되, 즉시 두 번째를 가져와 첫 번째에 대해 변환합니다(ProseMirror의 step 변환 로직 사용). 그런 다음 변환된 두 번째 세트를 클라이언트로의 왕복 없이 버전 N+2로 적용합니다. 실제로 서버는 클라이언트를 위해 리베이스를 수행하고 둘 다 순서대로 수락할 수 있습니다. 이 접근 방식은 _커밋 기반 협업_ 아이디어와 일치하며, 서버가 도착한 순서대로 커밋을 적용하고 다른 동시 커밋을 그에 따라 매핑합니다[[9]](https://stepwisehq.com/blog/2023-07-25-prosemirror-collab-performance/#:~:text=The%2520gist%2520is%2520that%2520we,them%2520back%2520to%2520the%2520clients). 클라이언트가 다시 보내야 하는 추가 지연을 피합니다. 간단한 경우(다른 위치에 두 편집 모두 삽입)부터 시작하여 연속으로 수락할 수 있습니다. 복잡한 충돌(예: 둘 다 정확히 같은 문자를 편집)에서는 서버가 여전히 하나가 이기고 하나가 클라이언트 측에서 리베이스하도록 할 수 있으며, 로직을 처음에는 더 간단하게 유지합니다.
- **충돌 처리 정책:** 기본적으로 두 사용자가 동일한 텍스트 영역을 편집하는 경우 서버에 먼저 도달하는 편집이 적용됩니다. 두 번째 편집은 변환됩니다. ProseMirror의 OT는 문서 손상이 없도록 보장하지만 결과 텍스트는 변경 사항을 혼합할 수 있습니다. 정책은 겹치는 텍스트 삽입/삭제 충돌에 대해 마지막 쓰기 우선입니다(두 번째 작성자의 변경은 첫 번째 작성자의 변경을 포함하는 문서에서 리베이스되므로 실제로 그 이후에 옵니다). OT가 제공하는 것 이상의 의미론적 충돌 해결을 구현하지 않습니다 – 예를 들어, 같은 지점에 입력된 두 개의 다른 단어를 병합하려고 시도하지 않습니다. OT 결과(보통 하나가 다른 하나를 따르는 두 단어)가 유지되며, 필요한 경우 사용자가 수동으로 정리합니다. 핵심은 모든 사용자가 동일한 결과를 본다는 것입니다.
- **ProseMirror의 위치 매핑**을 사용하여 동시 삽입/삭제 조정을 처리합니다. 예를 들어, 사용자 A가 위치 5에 문자를 삽입하고 동시에 사용자 B가 문자 10-12를 삭제하는 경우, B의 삭제가 A 이후에 적용되면 삭제 위치는 A의 삽입을 고려하여 다시 매핑됩니다(+1 오프셋)[[19]](https://marijnhaverbeke.nl/blog/collaborative-editing.html#:~:text=1,front%2520of%2520the%2520change's%2520offset)[[17]](https://marijnhaverbeke.nl/blog/collaborative-editing.html#:~:text=Position%2520Mapping). 이는 일관성을 보장합니다.
- **인식 및 잠금:** 문서 영역에 대한 하드 잠금을 구현하지 않습니다(비관적 잠금 없음). 그러나 presence(ADR 7)를 통해 다른 사람이 단락을 편집하고 있는지 표시하여 사용자가 정확히 같은 줄을 편집하지 않도록 권장합니다. 이는 순전히 UX 예의입니다. 시스템 자체는 어디서나 동시 편집을 허용합니다.
- Convex 백엔드는 **@convex-dev/prosemirror-sync** **컴포넌트**를 기반으로 사용합니다. 이 컴포넌트는 step 및 snapshot 제출을 위한 서버 함수를 제공하고 위의 로직 대부분을 처리합니다(버전 확인 및 리베이스 지침 포함)[[10]](https://github.com/get-convex/prosemirror-sync#:~:text=,side,%2520enabling%2520easy%2520AI%2520interoperation)[[5]](https://github.com/get-convex/prosemirror-sync#:~:text=const%2520prosemirrorSync%2520=%2520new%2520ProsemirrorSync\(components,//). 이를 사용하여 Convex에서 ProseMirror의 OT 알고리즘의 입증된 구현을 얻습니다. 설명된 서버 측 커밋 일괄 처리를 추가하기 위해 확장하거나 구성할 것입니다.

## 근거

ProseMirror의 OT 기반 협업을 선택한 이유는 중앙 집중식 백엔드 모델에 맞는 잘 확립된 솔루션이기 때문입니다. 주요 이유:

- **중앙 집중식 OT가 더 간단하고 일관적:** 완전히 분산된 OT와 달리 중앙 집중식 접근 방식은 "구현하고 추론하기 상대적으로 쉽습니다"[[20]](https://marijnhaverbeke.nl/blog/collaborative-editing.html#:~:text=But%2520you%2520can%2520save%2520oh,their%2520Google%2520Docs%E2%80%94a%2520centralized%2520system). 이벤트를 순서대로 정렬하는 단일 서버가 있어 다중 리더 합의의 복잡성을 피합니다. Marijn Haverbeke(ProseMirror의 저자)가 언급했듯이 중앙 권한은 버전 제어와 같은 선형 히스토리를 사용할 수 있게 하며, 클라이언트는 필요할 때 자체 변경 사항을 리베이스합니다[[8]](https://marijnhaverbeke.nl/blog/collaborative-editing.html#:~:text=Like%2520OT,%2520ProseMirror%2520uses%2520a,will%2520produce%2520the%2520same%2520document). 이는 버전 관리(ADR 2)가 저장하는 하나의 확정적인 편집 시퀀스를 생성합니다.
- **ProseMirror의 알고리즘 활용:** 바퀴를 재발명하지 않습니다. ProseMirror는 변환 로직과 확인되지 않은 step 대 확인된 step을 관리하는 협업 플러그인을 제공합니다. 이와 일치함으로써 시스템이 수년간의 변환 테스트로부터 이익을 얻도록 보장합니다. 예를 들어, ProseMirror는 변경을 통해 커서를 제자리에 유지하는 강력한 매핑을 가지고 있으며[[17]](https://marijnhaverbeke.nl/blog/collaborative-editing.html#:~:text=Position%2520Mapping), 충돌 해결 및 presence에서 활용할 것입니다(다른 텍스트가 위에 삽입될 때 사용자의 커서가 적절하게 이동하도록).
- **실시간 성능:** 변경 사항의 즉각적인 로컬 적용이 있는 OT는 사용자가 지연 없이 자신의 타이핑을 보고 네트워크가 허용하는 즉시 다른 사람의 편집을 볼 수 있음을 의미합니다. 오버헤드는 최소 JSON diff(step)이며 데이터 모델은 이를 위해 최적화되어 있습니다(작은 step 객체). Convex의 WebSocket 푸시는 모든 구독자에게 업데이트를 즉시 전달합니다.
- **공정성을 위한 Step 일괄 처리:** 높은 경합 편집 세션에서 지연 시간이 높은 사용자가 변경 사항이 지속적으로 거부되는 "굶주리는 예술가"가 될 수 있는 문제를 해결합니다[[15]](https://stepwisehq.com/blog/2023-07-25-prosemirror-collab-performance/#:~:text=During%2520sessions%2520with%2520a%2520high,and%2520the%2520client%2520backlogs%2520clear). 일괄 처리를 통해 _버전 불일치 빈도를 줄입니다_. 5명의 사용자가 한 번에 입력하는 경우 충돌을 일으키는 5개의 별도 빠른 버전 증가 대신 클라이언트 또는 서버에서 변경 사항을 효과적으로 통합합니다. 커밋 기반 향상(거부하는 대신 동시 커밋 변환)은 많은 클라이언트 재시도를 피하고 처리량을 향상시킬 수 있음을 보여준 연구에서 도출되었습니다[[21]](https://stepwisehq.com/blog/2023-07-25-prosemirror-collab-performance/#:~:text=There%2520are%2520a%2520number%2520of,a%2520lot%2520of%2520extra%2520complexity)[[22]](https://stepwisehq.com/blog/2023-07-25-prosemirror-collab-performance/#:~:text=Can%2520we%2520eliminate%2520the%2520need,work%2520closer%2520to%2520the%2520database). 이 근거는 부하 상태에서 _사용자 경험을 개선_하기 위한 것입니다: "변경 사항이 덮어써졌습니다, 재시도 중…" 결함이 적습니다.
- **MVP에 대해 더 위험한 것으로 보이는 대안:** CRDT(Yjs와 같은)를 고려했지만 클라이언트-서버 아키텍처를 고려할 때 OT가 충분하고 더 간단하다고 판단했습니다. 또한 ProseMirror의 내장 OT는 새 라이브러리를 통합하거나 데이터 구조를 대폭 변경할 필요가 없음을 의미합니다.
- **Convex 통합:** Convex ProseMirror 동기화 컴포넌트의 존재[[10]](https://github.com/get-convex/prosemirror-sync#:~:text=,side,%2520enabling%2520easy%2520AI%2520interoperation)는 이 접근 방식의 위험을 크게 줄입니다. step 제출, step 가져오기, snapshot 처리를 위한 함수를 포함하는 서버 측 OT의 즉시 사용 가능한 구현을 제공합니다. 이를 사용한 다음 필요에 맞게 조정할 수 있습니다. 이 정렬은 개발 속도를 높이고 처음부터 자체 협업 엔진을 작성하는 것과 달리 정확성을 보장합니다.

## 고려된 대안

- **CRDT (Conflict-free Replicated Data Types):** Yjs와 함께 TipTap과 같은 CRDT 기반 편집기를 사용하는 것이 강력한 대안이었습니다. CRDT는 진정한 피어 투 피어 협업과 중앙 서버 순서 없이 병합되는 오프라인 편집을 허용합니다. 그러나 ProseMirror에 CRDT를 통합하는 것(ProseMirror용 Y.js 플러그인이 있음)은 저장소에 많은 데이터 오버헤드(각 문자 삽입에 식별자가 있음 등)와 복잡성을 도입할 것입니다. 또한 실시간 OT는 이미 사용 사례에 대해 ProseMirror로 해결되었습니다. 지금은 OT를 고수하고 나중에 오프라인 기능이 필요한 경우 CRDT로 전환하기로 결정했습니다. 특히 Convex 팀은 Yjs 전용 컴포넌트가 별도일 수 있다고 제안합니다[[14]](https://github.com/get-convex/prosemirror-sync#:~:text=,and%2520doesn't%2520have%2520local%2520changes), OT와 CRDT를 혼합하는 것이 사소하지 않음을 암시합니다.
- **비관적 잠금:** 사용자가 편집하는 동안 block 또는 섹션을 잠글 수 있습니다. 이는 충돌을 완전히 피하기 위해서입니다. 협업을 심각하게 방해하기 때문에 거부되었습니다 – 사용자는 차례를 기다리거나 문서를 작은 잠긴 섹션으로 나눠야 합니다. 원하는 자유 형식 동시 편집 경험과 일치하지 않습니다.
- **타사 협업 서비스:** Firebase OT, ShareDB 또는 중앙 릴레이와 함께 Automerge와 같은 것을 사용하는 서비스가 있습니다. 이를 채택하면 ProseMirror의 편집 동작을 교체하거나 연결해야 합니다. ProseMirror가 이미 생태계 내에서 이를 해결했기 때문에 다른 레이어를 추가하는 것은 불필요하다고 느꼈습니다.
- **특별한 작업 없음 (마지막 쓰기 우선):** 이론적으로 OT 없이 마지막 쓰기 우선으로 Convex가 동시 쓰기를 처리하도록 할 수 있습니다(필드에 대한 마지막 업데이트가 우선). 이는 텍스트 병합에 재앙적일 것입니다(업데이트 손실, 뒤섞인 텍스트) 동시 편집을 위한 실제 솔루션이 아니므로 진지하게 고려되지 않았습니다.

## 영향

- **서버 부하:** 모든 키 입력은 잠재적으로 Convex 함수 호출 및 데이터베이스 쓰기(step)를 초래합니다. 대규모 협업 세션의 경우 이는 무거울 수 있습니다. 클라이언트 측 일괄 처리(더 적고 더 큰 step 제출)와 step을 작게 유지하여 이를 완화합니다. Convex의 확장성이 테스트될 것입니다. 그러나 Convex는 실시간 업데이트를 위해 설계되었으며 **WebSocket 반응성 및 캐싱**으로 많은 작은 쓰기를 처리할 수 있습니다[[23]](https://stack.convex.dev/presence-with-convex#:~:text=Convex%2520helped%2520make%2520this%2520much,WebSocket%2520reactivity%2520and%2520caching%2520scalability)[[24]](https://stack.convex.dev/presence-with-convex#:~:text=Caching). 성능을 모니터링하고 일괄 처리 크기를 조정하거나 범람이 발생하는 경우 중간 상태 업데이트를 삭제하기 위해 Convex의 단일 비행 메커니즘을 사용해야 할 수 있습니다(presence와 유사, ADR 7 참조).
- **엣지 케이스의 복잡성:** ProseMirror OT는 대부분의 편집 시나리오를 다루지만 _동시 step 제출 및 snapshot 제출_과 같은 특정 엣지 케이스가 발생할 수 있습니다. convex 컴포넌트에는 snapshot 제출 동시성을 처리하는 로직이 있습니다(마지막 편집자만 snapshot 트리거)[[11]](https://github.com/get-convex/prosemirror-sync#:~:text=Configuring%2520the%2520snapshot%2520debounce%2520interval)[[25]](https://github.com/get-convex/prosemirror-sync#:~:text=There%2520can%2520be%2520races,%2520but,and%2520are%2520safe%2520to%2520apply). 경쟁 조건을 피하기 위해 사용이 올바른지 확인해야 합니다(예: 두 사용자 모두 마지막으로 편집했다고 생각하고 snapshot을 보냄 – 하나가 이기고 다른 하나는 안전하게 폐기되어야 함).
- **데이터 일관성:** 문서를 수정하는 Convex 함수(step 적용)는 문서당 **원자적**이어야 합니다. Convex 함수는 격리되어 실행되므로 동일한 문서에서 두 호출이 동시에 발생하면 하나가 자연스럽게 다른 하나 이후에 직렬화됩니다(Convex는 트랜잭션 모델에서 일관성을 보장). 그러나 서버에서 step을 병합하기 위한 사용자 지정 로직을 도입하는 경우 원자성을 유지하기 위해 단일 함수 호출에서 구현해야 합니다. 서버 함수를 약간 복잡하게 만듭니다(step 세트 배열을 처리해야 할 수 있음).
- **클라이언트 복잡성:** 클라이언트는 두 세트의 상태를 유지해야 합니다: 낙관적 로컬 상태와 확인된 서버 상태. 이는 ProseMirror 협업 플러그인에서 처리되지만 개발자는 올바른 시작 문서(최신 snapshot + step에서)로 편집기를 초기화하도록 주의해야 합니다. 오류 처리에도 복잡성이 있습니다 – 클라이언트가 너무 뒤처진 경우(많은 업데이트를 놓쳤을 수 있음) 처음부터 문서 상태를 다시 로드해야 합니다. 클라이언트의 버전이 너무 오래된 경우(서버에 더 이상 오래된 step이 없음) 다시 동기화하기 위해 새 snapshot을 보내는 안전 장치를 구현할 것입니다.
- **잠재적 병합 아티팩트:** OT 알고리즘은 콘텐츠를 의미론적으로 병합하려고 시도하지 않습니다. 따라서 문서는 이상한 아티팩트로 끝날 수 있습니다. 예를 들어 두 사용자가 같은 단어를 입력 -> 병합 후 단어가 두 번 나타납니다. 또는 둘 다 줄을 삭제 -> 병합 후 하나의 삭제가 이미 사라진 텍스트를 대상으로 할 수 있으며, 두 번째는 no-op이 됩니다(따라서 하나의 삭제가 "이기지만" 실제로 둘 다 삭제하고 싶었으며 괜찮음). 이러한 아티팩트는 일반적으로 사소하며 사용자가 편집할 수 있습니다. 시스템이 일관성을 보장하지만 지능적인 병합은 아니라는 알려진 동작을 내부 노트에 문서화할 것입니다. 이는 Google Docs가 작동하는 방식과 유사합니다 – 동시 편집은 결합된 결과를 생성하며, 필요한 경우 사용자가 조정할 수 있습니다.
- **비텍스트 Block과의 통합:** 지금까지 설명된 협업 프로토콜은 리치 텍스트 콘텐츠(ProseMirror 문서)용입니다. 다른 block 타입(이미지, 첨부 파일)의 경우 "편집"은 다른 것을 의미할 수 있습니다(예: 이미지의 캡션 변경 또는 이동). 이러한 작업은 ProseMirror를 전혀 사용하지 않을 수 있습니다. 더 간단한 전략으로 처리할 것입니다: 예를 들어, 두 사용자가 이미지 block의 메타데이터를 동시에 편집하려고 하면 마지막 쓰기가 단순히 이길 수 있습니다. 이러한 편집은 드물고 일반적으로 동시에 발생하지 않기 때문입니다. ADR 3 프로토콜은 주로 텍스트 편집의 무거운 경우를 다룹니다. 비텍스트 협업 작업(두 사용자가 동시에 block을 재정렬하는 것과 같은)에는 생각이 필요하다는 점을 언급할 것입니다 – 아마도 이를 작업으로 취급합니다(예: block X를 block Y 뒤로 이동하는 작업, 유사하게 시퀀스할 수 있음).

## 확장 경로

- **진정한 오프라인 협업:** 오프라인 작업을 지원하기 위해 Yjs와 같은 CRDT 기반 접근 방식을 통합할 수 있습니다. 이 시나리오에서 각 클라이언트는 서버 없이 변경할 수 있으며 나중에 병합할 수 있습니다. 현재 OT 로그와 조정해야 합니다. 아마도 Convex에 동기화되는 병렬로 Yjs 문서를 실행할 수 있습니다. 또는 완전히 Yjs로 전환: Convex 백엔드는 Yjs 업데이트(델타)를 저장하고 브로드캐스트할 수 있습니다. 이는 중앙 OT의 필요성을 제거하고 연합 편집을 허용하지만 데이터 구조를 마이그레이션해야 합니다(ProseMirror 콘텐츠를 Yjs 형식으로). 이는 사소하지 않은 변경이지만 제품이 오프라인 사용 또는 다중 마스터(연합) 편집을 요구하는 경우 필요할 수 있습니다.
- **연합 서버 및 합의:** 향후 지식 베이스가 서버 간에 분산되는 경우(단일 권한 서버 없음) 사이트 간에 일관된 작업 순서를 유지하기 위해 합의 알고리즘(Raft 또는 CRDT와 같은)을 사용하는 것을 탐색할 수 있습니다[[26]](https://marijnhaverbeke.nl/blog/collaborative-editing.html#:~:text=And%2520I%2520don't%2520actually%2520believe,have%2520not%2520actually%2520tried%2520this). 예를 들어, 클러스터 중에서 기본 Convex 노드를 선출하여 step을 정렬하거나 하나의 "중재자" 사이트를 가짐으로써 연합 설정에서 operational transform을 사용할 수 있습니다. 이는 복잡하며 단기 요구 사항을 넘어설 가능성이 높지만 ADR은 완전성을 위해 언급합니다. 현재 설계는 문서당 하나의 권한(이를 소유한 Convex 배포)을 유지합니다.
- **지능형 병합 지원:** 충돌 해결을 돕기 위해 AI 어시스턴트를 도입할 수 있습니다. 예를 들어, 두 사용자가 같은 문장을 다르게 편집하는 경우 AI가 이를 감지하고 병합된 버전을 제안하거나 사용자에게 경고할 수 있습니다. 이는 기존 프로토콜 위에 계층화됩니다(두 개의 분기 편집을 볼 수 있는 데이터가 있음). 이는 Mastra 에이전트를 통해 구현된 "AI 공동 편집자" 기능의 일부일 수 있습니다(ADR 8).
- **높은 사용자 수로 확장:** 현재 ProseMirror는 단일 문서를 편집하는 수십 명의 동시 사용자에 최적화되어 있습니다. 수백 명이 협업하는 시나리오(대규모 공유 메모장과 같은)가 있는 경우 조정해야 할 수 있습니다. Step 일괄 처리가 중요해지며 업데이트 빈도를 제한할 수 있습니다. 너무 혼란스러워지면 애플리케이션 수준에서 **요청 시 영역 잠금**을 구현할 수 있습니다 – 필수는 아니지만 문서가 매우 바쁜 경우 시스템이 자동으로 파티션할 수 있습니다(예: 너무 많은 사람이 동시에 편집하려고 하면 단락을 잠그고 편집을 대기열에 넣도록 요청). 이는 추측이며 규모 문제가 발생하는 경우에만 해당됩니다.
- **다중 커서 / 다중 영역 편집:** ProseMirror는 기본적으로 하나의 문서에서 작동합니다. 복잡한 시나리오에서 많은 block이 있는 아웃라이너와 같은 경우 여러 block을 동시에 독립적으로 편집할 수 있습니다(각 block이 별도의 콘텐츠이므로). 각 최상위 문서 block을 별도의 협업 세션으로 취급할 계획입니다. 확장에서 여러 동시 OT 세션(활발하게 편집되는 block당 하나)을 가질 수 있습니다. 프로토콜은 문서/block당 step을 격리하여 이를 처리할 수 있습니다. block에 걸친 작업이 일관성을 보장하기만 하면 됩니다(현재 MVP에서는 발생하지 않음 – 각 작업은 하나의 block의 콘텐츠 내에 있음).
- **댓글 또는 제안 통합:** 협업은 직접 편집만이 아닙니다. 나중에 제안(변경 사항 추적) 또는 인라인 댓글에 대한 기능을 추가할 수 있습니다. 이는 협업에 또 다른 차원을 추가합니다. 텍스트의 범위에 첨부된 데이터로 댓글을 취급하여 모델을 확장할 것입니다. 그런 다음 텍스트가 변경됨에 따라 댓글이 그에 따라 이동하도록 해야 합니다 – ProseMirror의 매핑이 도움이 될 수 있으며, 커서 위치를 안정적으로 유지하는 방법과 유사합니다[[17]](https://marijnhaverbeke.nl/blog/collaborative-editing.html#:~:text=Position%2520Mapping). 이는 각 편집에서 step 맵을 통해 업데이트되는 문서 위치를 참조하는 구조에 댓글을 저장하는 것을 의미할 것입니다. 고급 확장이지만 기본 협업 엔진은 변경을 통해 위치를 안정적으로 매핑할 수 있으므로 지원할 것입니다.
