---
title: "ADR 3: 협업 프로토콜 (ProseMirror OT, Step 일괄 처리, 충돌 해결)"
---

## 배경

여러 사용자가 **같은 Block이나 문서를 실시간으로 편집**하면서 서로의 변경 사항을 즉시 봐야 한다. 동시 편집을 안정적으로 병합하는 협업 프로토콜이 필요하다. 리치 텍스트 편집 프레임워크로 ProseMirror를 선택했고 중앙 집중식 Operational Transformation(OT) 기반 협업 모듈이 함께 온다.

<Callout type="info" title="핵심 과제">
  - 분기 상태를 방지하기 위한 **변경 순서 정렬** - 사용자 간 **네트워크 지연
  차이** - 모든 사용자에게 일관되게 변경을 적용하는 **충돌 해결** - 다른 사람
  편집이 먼저 들어가면 변경이 거부되고 재시도해야 하는 **고지연 사용자** 문제
</Callout>

프로토콜 설계는 실시간 응답성과 공정성, 일관성 사이에서 균형을 맞춰야 한다.

## 결정 사항

<Callout type="info" title="핵심 접근법">
  **협업 텍스트 편집에 ProseMirror의 중앙 집중식 OT 알고리즘을 사용하고 서버에서
  일괄 Step 커밋으로 충돌을 줄인다.**
</Callout>

### 아키텍처 개요

- Convex 백엔드에서 각 문서 상태의 **단일 진실의 원천**을 운영한다 (OT 용어로 "authority"). 클라이언트끼리 직접 P2P 동기화하지 않고 모든 변경이 Convex를 통한다.

- 클라이언트는 ProseMirror 협업 플러그인이나 Convex-prosemirror 통합을 사용한다. 각 클라이언트는 문서의 로컬 버전 번호를 자체 유지한다.

### 협업 흐름

1. **사용자가 편집** → ProseMirror Step 객체 하나 이상 생성
2. **클라이언트가 낙관적으로 적용** → Step을 로컬에 적용하고 기준 버전 번호와 함께 Convex 함수(`submitSteps`)에 전송
3. **서버가 버전 확인:**
   - Step의 기준 버전 = 서버 현재 버전 → **수락**, 버전 증가, Step 기록, 다른 클라이언트에 브로드캐스트
   - 기준 버전이 오래됨 → 들어오는 Step을 **거부**
4. **거부된 클라이언트**는 놓친 새 Step을 가져오고 ProseMirror로 최신 문서 상태 위에 **확인 안 된 Step을 rebase** 후 재전송

### Step 일괄 처리

**Step 일괄 처리**를 두 단계로 구현한다:

<Tabs items={["클라이언트 측 일괄 처리", "서버 측 커밋 일괄 처리"]}>
  <Tab value="클라이언트 측 일괄 처리">
    클라이언트가 빠르게 연속으로 발생하는 여러 로컬 Step을 하나의 제출로 묶는다.
    ProseMirror의 협업 플러그인이 이미 "확인 안 된" Step을 모아서 주기적으로
    일괄 전송할 수 있다. 이걸 튜닝해서(예: 50-100ms마다 또는 텍스트 입력 중단 시
    전송) 오버헤드를 줄이고 단일 문자 Step으로 서버를 넘치지 않게 한다.
  </Tab>
  <Tab value="서버 측 커밋 일괄 처리">
    기본 OT 모델에서는 주어진 문서 버전에 한 클라이언트 변경만 수락되고 나머지는
    rebase하라고 거부된다 – 느린 연결을 굶길 수 있다. **개선:** 두 세트의 Step이
    거의 동시에 서버에 도착하면(둘 다 버전 N 기준): 1. 하나를 버전 N+1 승자로
    선택 2. 즉시 두 번째를 가져와서 첫 번째에 대해 변환 (ProseMirror의 Step 변환
    로직 사용) 3. 변환된 두 번째 세트를 클라이언트 왕복 없이 버전 N+2로 적용
    실제로 서버가 클라이언트 대신 rebase를 수행하고 둘 다 순서대로 수락한다.
  </Tab>
</Tabs>

### 충돌 해결 정책

기본적으로 두 사용자가 같은 텍스트 영역을 편집하면 서버에 먼저 도달한 편집이 적용되고 두 번째 편집은 변환된다. ProseMirror의 OT가 문서 손상이 없도록 보장하지만 결과 텍스트는 변경 사항이 섞일 수 있다.

<Callout type="warn" title="Last-Write-Wins">
  겹치는 텍스트 삽입/삭제 충돌에 대해 **last-write-wins** 정책이다. OT가
  제공하는 것 이상의 의미론적 충돌 해결은 구현하지 않는다 – 같은 지점에 입력된
  두 단어는 둘 다 나타나고(하나가 다른 하나 뒤에) 필요하면 사용자가 수동으로
  정리한다. 핵심은 **모든 사용자가 같은 결과를 본다**는 것이다.
</Callout>

### 위치 매핑

**ProseMirror의 위치 매핑**을 사용해서 동시 삽입/삭제 조정을 처리한다. 예:

- 사용자 A가 위치 5에 문자 삽입
- 동시에 사용자 B가 문자 10-12 삭제
- B의 삭제가 A 이후에 적용되면 삭제 위치가 A의 삽입을 고려해 재매핑(+1 오프셋)

모든 클라이언트에서 일관성을 보장한다.

### 백엔드 통합

Convex 백엔드는 **@convex-dev/prosemirror-sync** 컴포넌트를 기반으로 사용한다. 이 컴포넌트가 제공하는 것:

- Step과 Snapshot 제출용 서버 함수
- 버전 확인과 rebase 지침
- Convex에서 ProseMirror OT 알고리즘의 검증된 구현

위에서 설명한 서버 측 커밋 일괄 처리를 추가하려고 확장한다.

## 왜 이렇게 결정했나

ProseMirror의 OT 기반 협업을 선택한 이유 – 중앙 집중식 백엔드 모델에 맞는 잘 확립된 솔루션이다:

- **중앙 집중식 OT가 더 단순하고 일관적:** 완전 분산 OT와 달리 중앙 집중식 접근법은 "구현하고 추론하기 상대적으로 쉽다". 중앙 authority가 있으면 버전 제어처럼 선형 히스토리를 쓸 수 있고 클라이언트는 필요할 때 자기 변경을 rebase한다.

- **ProseMirror 알고리즘 활용:** 바퀴를 재발명하지 않는다. ProseMirror가 변환 로직과 확인 안 된 vs 확인된 Step을 관리하는 협업 플러그인을 제공한다.

- **실시간 성능:** 변경의 즉각적 로컬 적용이 있는 OT 덕분에 사용자가 자기 타이핑을 지연 없이 보고 다른 사람 편집도 네트워크가 허용하는 즉시 본다.

- **공정성을 위한 Step 일괄 처리:** 고경합 편집 세션에서 지연이 높은 사용자가 변경이 계속 거부되는 "굶주리는 예술가"가 되는 문제를 해결한다.

- **Convex 통합:** Convex ProseMirror 동기화 컴포넌트가 존재해서 즉시 사용 가능한 구현으로 이 접근법의 위험을 크게 줄인다.

## 검토한 대안들

<Tabs items={["CRDT", "비관적 잠금", "서드파티 서비스", "Last-Write-Wins"]}>
  <Tab value="CRDT">
    **CRDT (Conflict-free Replicated Data Types):** Y.js와 TipTap 같은 CRDT 기반
    에디터 사용이 강력한 대안이었다. CRDT는 중앙 서버 순서 없이 진정한 P2P
    협업과 오프라인 편집 병합을 허용한다. 하지만 ProseMirror에 CRDT를 통합하면
    무거운 데이터 오버헤드와 저장소 복잡성이 도입된다. 지금은 OT를 유지하고
    나중에 오프라인 기능이 필요하면 CRDT로 전환하기로 했다.
  </Tab>
  <Tab value="비관적 잠금">
    **비관적 잠금:** 사용자가 편집하는 동안 Block이나 섹션을 잠가서 충돌을
    완전히 방지. **기각** – 협업을 심각하게 방해한다. 사용자가 차례를 기다리거나
    문서를 작은 잠긴 섹션으로 나눠야 한다. 우리가 원하는 자유로운 동시 편집
    경험과 맞지 않는다.
  </Tab>
  <Tab value="서드파티 서비스">
    **서드파티 협업 서비스:** Firebase OT, ShareDB, 또는 중앙 릴레이와
    Automerge. 채택하면 ProseMirror의 편집 동작을 교체하거나 브릿지해야 한다.
    ProseMirror가 이미 생태계 내에서 이걸 해결했으니 다른 레이어를 추가하는 건
    불필요했다.
  </Tab>
  <Tab value="Last-Write-Wins">
    **특별한 처리 없이 (last write wins):** OT 없이 Convex가 last-write-wins로
    동시 쓰기를 처리하게 한다. 텍스트 병합에 **재앙적**이다 (업데이트 손실,
    뒤죽박죽 텍스트) 동시 편집의 실제 솔루션이 아니다.
  </Tab>
</Tabs>

## 영향

- **서버 부하:** 키 입력마다 잠재적으로 Convex 함수 호출과 DB 쓰기가 발생한다. 클라이언트 측 일괄 처리(더 적고 큰 Step 제출)로 완화한다. Convex의 WebSocket 반응성과 캐싱이 많은 작은 쓰기를 처리할 수 있다.

- **데이터 일관성:** 문서를 수정하는 Convex 함수는 문서당 **원자적**이어야 한다. Convex가 트랜잭션 모델에서 일관성을 보장한다.

- **클라이언트 복잡성:** 클라이언트가 두 세트의 상태를 유지해야 한다: 낙관적 로컬 상태와 확인된 서버 상태. ProseMirror 협업 플러그인이 처리한다.

- **잠재적 병합 아티팩트:** OT 알고리즘은 콘텐츠를 의미론적으로 병합하려 하지 않는다. 문서에 이상한 아티팩트가 생길 수 있다 (두 사용자가 같은 단어를 타이핑 → 두 번 나타남). 대체로 사소하고 사용자가 편집해서 없앨 수 있다.

- **비텍스트 Block과의 통합:** 다른 Block 타입(이미지, 첨부 파일)의 "편집"은 다른 의미일 수 있다. 더 단순한 전략을 쓸 수 있다 (예: 이미지 메타데이터는 드문 편집이니 last write wins).

## 확장 경로

<Cards>
  <Card
    title="진정한 오프라인 협업"
    href="/docs/adr/adr-002-versioning-strategy"
  >
    오프라인 작업 지원을 위해 Yjs 같은 CRDT 기반 접근법 통합. 각 클라이언트가
    서버 없이 변경 후 나중에 병합할 수 있다.
  </Card>
  <Card
    title="연합 서버 & 합의"
    href="/docs/adr/adr-008-platform-boundaries-expansion"
  >
    분산 서버 간 일관된 순서 유지를 위해 합의 알고리즘(Raft나 CRDT 등) 사용
    탐색.
  </Card>
  <Card
    title="지능형 병합 지원"
    href="/docs/adr/adr-008-platform-boundaries-expansion"
  >
    충돌 해결을 돕는 AI 어시스턴트 도입 – 두 사용자가 같은 문장을 다르게 편집할
    때 감지하고 병합 버전을 제안.
  </Card>
  <Card title="댓글 & 제안" href="/docs/adr/adr-007-presence-cursors">
    변경 추적이나 인라인 댓글 추가. 댓글을 텍스트의 범위에 붙이고 ProseMirror
    매핑을 써서 텍스트 변경에 따라 이동.
  </Card>
</Cards>

<Callout type="idea" title="향후 스케일링">
  단일 문서에 수백 명의 동시 사용자가 있게 되면 **요청 시 영역 잠금**을 구현해야
  할 수 있다 – 필수는 아니지만 문서가 매우 바쁘면 시스템이 자동으로 파티션할 수
  있다 (예: 너무 많은 사람이 동시에 편집하려 하면 문단을 잠금).
</Callout>
