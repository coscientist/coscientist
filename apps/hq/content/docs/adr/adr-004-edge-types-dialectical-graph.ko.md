---
title: "ADR 4: Edge 타입과 Dialectical Graph (Block 위의 타입이 지정된 Edge)"
---

# ADR 4: Edge 타입과 Dialectical Graph (Block 위의 타입이 지정된 Edge)

## 컨텍스트

선형 문서를 넘어 지식 시스템은 **지식 그래프** – 아이디어와 정보의 네트워크를 나타내는 것을 목표로 합니다. Block(ADR 1에서)은 이 그래프의 노드입니다. 이러한 노드를 다양한 관계로 연결하는 방법이 필요합니다. 일부 연결은 순전히 구조적입니다(예: 문서 block이 단락 block을 _포함_), 다른 연결은 의미론적입니다(예: Block A가 Block B를 _지원_, 또는 Block C가 Block D에 의해 인용된 _참조_). "Dialectical Graph"라는 용어는 논증적 또는 대화적 관계를 모델링하고자 함을 시사합니다: 예를 들어, 가설과 증거, 주장과 반론. 본질적으로 block 간의 **타입이 지정된 edge**가 풍부한 관계를 캡처하고 단순한 부모-자식 계층 구조가 아닌 그래프와 같은 방식으로 지식을 탐색할 수 있도록 해야 합니다.

## 결정

**Convex 데이터베이스에서 관계를 특성화하는 타입 필드가 있는 일반 Edge 모델을 구현하여 block의 방향 그래프를 형성합니다.** 각 edge는 인덱싱을 위해 필요한 경우 카테고리별로 여러 테이블에 있는 edges 테이블(또는 여러 테이블)의 레코드가 되며 대략 다음과 같은 스키마를 갖습니다:

- id: Id<"edges"> – edge의 기본 키.
- from: Id<"blocks"> – 소스 block(시작 노드).
- to: Id<"blocks"> – 대상 block(끝 노드).
- type: string – 관계 타입(예: "contains", "references", "supports", "opposes", "answers" 등).
- 메타데이터: 예: createdBy, createdAt, 선택적 주석 또는 가중치.

Edge는 방향성입니다: A에서 B로의 edge는 "A [type] B"를 의미합니다. 타입을 사용하여 **dialectical 관계**를 명시적으로 표현할 수 있습니다. 예를 들어:
- Block X가 주장이고 Block Y가 이를 지원하는 증거인 경우 edge Y --supports--> X를 생성합니다.
- Block M이 Block N과 모순되는 경우 edge M --refutes--> N(또는 opposes)이 사용됩니다.
- 구조적 포함의 경우 contains를 사용합니다: 예: Document D가 Block P를 포함(edge D --contains--> P). 이는 시퀀스 또는 부모/자식 관계도 다룰 수 있습니다. (동일한 부모의 여러 "contains" 타입 edge에는 순서가 있어야 하므로 edge의 position 속성이나 부모 block의 content 배열을 통해 순서를 관리할 수 있습니다.)
- Q&A 링크를 나타낼 수 있습니다: Question block Q는 Answer block A를 통해 A --answers--> Q로 답변됩니다.
- Dialectical 또는 토론 매핑: 예: 필요한 경우 thesis --counters--> antithesis.

이 설계는 edge를 자체 타입과 잠재적 속성을 가진 일급 객체로 취급합니다. 이는 **속성 그래프 모델**과 일치하며, 관계에 타입이 있고 속성을 가질 수 있습니다[[1]](https://shilpathota.medium.com/understanding-knowledge-graphs-for-agentic-ai-7162d018387b#:~:text=,interrelate). MVP를 위한 핵심 허용 edge 타입 세트를 정의할 것입니다:
- **구조적 타입:** "contains"(또는 "parent-of"/"child-of" 관계). 선형 순서가 목록으로 인코딩되지 않은 경우 순서 지정을 위한 "next"도 가능합니다.
- **참조 타입:** "references"(Block A가 Block B를 참조, 예: 소스 block에 연결되는 텍스트의 인용).
- **지원/반대 타입:** dialectical 지원 또는 모순을 캡처하기 위한 "supports", "refutes".
- **연관 타입:** 느슨한 링크를 위한 "related", 도메인 요구에 따라 "example-of", "definition-of" 등.

임의의 문자열을 피하기 위해 코드에서 이를 열거할 것입니다(상수 또는 enum으로). 그러나 모델은 스키마 변경 없이 나중에 새 타입을 추가할 수 있을 만큼 유연합니다.

Edge는 Convex 변경을 통해 조작됩니다: 예: 링크를 생성하기 위한 addEdge(from, to, type), 삭제하기 위한 removeEdge(id). 또한 그래프를 탐색하기 위한 getEdgesFrom(blockId, typeFilter?) 또는 getEdgesTo(blockId, typeFilter?)와 같은 쿼리도 있을 것입니다. 효율적인 조회를 위해 from 및 to 필드에 Convex 인덱스를 생성할 계획입니다(일반적인 쿼리는 "from = X인 모든 edge 찾기" 또는 "to = Y"이므로).

## 근거

타입이 지정된 edge 모델은 지식 베이스의 관계에 **의미론적 풍부함**과 쿼리 가능성을 제공하기 위해 선택되었습니다:

- **콘텐츠와 관계의 분리:** edge를 block과 별도로 저장함으로써 block은 콘텐츠에 집중하고 edge를 사용하여 링크를 처리합니다. 이를 통해 block 데이터를 수정하지 않고 관계를 쉽게 추가하거나 제거할 수 있습니다. 또한 하나의 block이 많은 관계에 자유롭게 참여할 수 있음을 의미합니다(일대다).
- **타입이 지정된 edge는 컨텍스트별 로직을 허용합니다:** 예를 들어, 문서를 렌더링할 때 "contains" edge를 따라 순서대로 콘텐츠 block을 수집합니다. 논증 그래프를 시각화할 때 찬성/반대 논증을 표시하기 위해 특별히 "supports" 또는 "refutes" edge를 찾습니다. 모든 링크가 타입이 지정되지 않았다면 다른 연결을 적절하게 처리하는 이 능력을 잃게 됩니다[[27]](https://shilpathota.medium.com/understanding-knowledge-graphs-for-agentic-ai-7162d018387b#:~:text=,specific%2520information). 지식 그래프는 일반 링크가 아닌 **풍부한 의미론적 관계**로부터 이익을 얻습니다.
- **진화 가능성:** 시스템이 성장함에 따라 관계 타입을 확장할 것으로 예상합니다(특히 AI 또는 외부 시스템을 통합할 때). 선택한 설계는 새 타입 값을 추가하여 쉽게 확장할 수 있으며, 속성 그래프에 새 관계 타입을 추가하는 것과 유사합니다 – 기존 데이터를 손상시키지 않습니다.
- **쿼리 및 분석:** 테이블에 edge가 있으면 Convex 내에서 그래프와 같은 쿼리를 수행할 수 있습니다. 예를 들어, 주장을 지원하는 모든 증거를 찾으려면 to = claimId AND type = "supports"인 edge를 쿼리합니다. 이는 Convex 쿼리 함수에서 수행할 수 있으며, 필요한 경우 반응형일 수도 있습니다. edge가 암시적이었다면(block 콘텐츠 내에 참조를 포함하여) 쿼리하거나 일관성을 강제하기가 훨씬 어려웠을 것입니다.
- **지식 그래프 관행과의 정렬:** 전용 그래프 데이터베이스를 사용하지 않는 경우 테이블에 노드와 edge를 저장하는 것이 일반적인 접근 방식입니다[[2]](https://shilpathota.medium.com/understanding-knowledge-graphs-for-agentic-ai-7162d018387b#:~:text=,offs). 단순성을 유지합니다(두 개의 테이블만: blocks와 edges). 또한 향후 데이터를 RDF 또는 다른 형식으로 내보내는 방법과 공명합니다 – 각 edge는 본질적으로 트리플(주어, 술어, 목적어)입니다.
- **Dialectical 추론:** 특히 dialectical 또는 논증 맵의 경우 타입이 지정된 edge는 "증거 block E가 주장 C를 지원하고 주장 C가 이론 T를 지원하면 E는 간접적으로 T를 지원한다"와 같은 로직을 구현할 수 있습니다 – 이러한 추론이나 UI 프레젠테이션은 edge 타입을 이해하는 데 의존합니다. 나중에 주어진 block에 대한 지원/모순을 자동으로 요약하는 기능이 있을 수 있습니다. "supports"/"refutes"로 명확하게 레이블이 지정된 edge를 갖는 것은 알고리즘이나 에이전트가 논증을 탐색하고 집계할 수 있게 합니다.

## 고려된 대안

- **타입이 지정되지 않은(또는 암시적) 링크:** block이 타입을 지정하지 않고 다른 block에 대한 참조를 저장하는(연결된 ID 배열과 같은) 더 간단한 모델을 가질 수 있었거나, 타입이 컨텍스트에 의해 암시적인 경우(예: "참조"는 다른 block의 ID를 가리키는 텍스트의 하이퍼링크일 수 있음). 명확성이 부족하기 때문에 선택되지 않았습니다 – 시스템이 링크가 무엇을 의미하는지 _알기_를 원합니다. 타입이 지정된 edge는 지식을 기계 해석 가능하게 만듭니다(예를 들어, 에이전트가 모든 반론을 쉽게 찾을 수 있음).
- **Block에 포함된 Edge 속성:** 또 다른 접근 방식은 각 block이 관계에 대한 필드를 포함하는 것입니다. 예를 들어: block에 참조를 위한 citations: [blockId] 또는 지원하는 주장을 위한 supports: [blockId]가 있을 수 있습니다. 각 새 관계 타입이 필드를 추가하고 다대다 관계가 정규화하기 어렵기 때문에 다루기 어려워집니다(주장이 모든 지원 block을 나열해야 하는가 아니면 각 지원이 지원하는 주장을 나열해야 하는가? 그 중복은 불일치를 초래함). 별도의 edge 엔티티는 정규화를 통해 이러한 문제를 피합니다.
- **Graph Database 또는 외부 저장소:** 관계를 위해 전용 그래프 엔진 또는 외부 서비스를 사용하는 것을 고려했습니다. MVP의 경우 과도합니다. Convex는 이를 행으로 처리할 수 있으며, MVP의 데이터 볼륨을 고려할 때 성능이 괜찮습니다. 쿼리가 매우 복잡해지고(다중 홉 순회와 같은) Convex 쿼리가 너무 느린 것으로 판명되면 Neo4j 또는 유사한 것을 사용하는 것을 고려할 수 있습니다. 그러나 추가 인프라를 피하는 것을 선호합니다.
- **고정 온톨로지 대 유연한 타입:** _사용자 정의_ edge 타입(folksonomy 스타일)을 허용할지 아니면 고정 세트를 고수할지 논의했습니다. MVP는 일관성을 위해 고정된 열거 세트를 사용하고 알려진 의미론을 강제합니다. 사용자 정의 관계 타입은 강력할 수 있지만 혼란이나 오용으로 이어질 수 있습니다(UI를 복잡하게 만듦). 필요한 경우 고급 사용자가 다시 방문할 수 있지만 처음에는 로직을 구현하는 타입으로 유지합니다.

## 영향

- **무결성 제약:** edge 끝점(from/to block ID)이 실제로 존재하는지 확인해야 합니다(매달린 edge 없음). 이는 block이 삭제될 때 관련된 모든 edge도 삭제되거나 업데이트되어야 함을 의미합니다. block 삭제 변경에서 이를 구현할 것입니다: 일관성을 유지하기 위해 관련 edge를 쿼리하고 제거합니다. Convex는 자동으로 삭제를 캐스케이드하지 않으므로 코드에서 처리합니다.
- **중복 및 순환 방지:** 시스템은 동일한 중복 edge(동일한 from, to, type을 가진 두 edge)를 방지해야 합니다. 근거가 있지 않는 한(여러 사용자가 지원을 표시하고 싶을 수 있지만 별도의 투표 수를 통해 단일 edge로 처리할 수 있음). 코드 또는 복합 키 로직으로 (from, to, type)의 고유성을 강제할 것입니다. 그래프의 순환은 가능합니다(특히 의미론적 링크의 경우). 순환이 본질적으로 "잘못된" 것은 아니지만(예: 서로 참조하는 두 문서) 순진한 그래프 순회에서 무한 루프를 일으킬 수 있습니다. 무한 재귀를 피하기 위해 쿼리/순회에서 주의해야 합니다. 예를 들어, "contains" 계층 구조는 이상적으로 비순환이어야 합니다(문서는 자신을 포함할 수 없음). 타입 제약이나 확인으로 인해 block에서 부모 중 하나로 다시 edge를 만들 수 없도록 설계로 강제할 것입니다.
- **Graph 쿼리 복잡성:** Convex 쿼리는 테이블을 쿼리할 수 있는 JavaScript 함수입니다. 단일 쿼리는 직접 edge를 쉽게 가져올 수 있지만 다중 홉 순회(예: X를 반박하는 것을 지원하는 모든 block 찾기)는 여러 쿼리 또는 클라이언트 측 로직이 필요할 수 있습니다. 필요할 때 코드(서버 또는 클라이언트)에서 재귀 순회를 구현할 수 있습니다. 이는 나중에 최적화하거나 알고리즘을 사용할 영역일 수 있습니다. MVP의 경우 기능에 대해 직접 1홉 또는 2홉 쿼리로 충분할 것입니다(직접 참조 나열 또는 한 수준의 supports/opposes 표시와 같은).
- **권한 모델 상호 작용:** Edge 자체도 권한 제어가 필요할 수 있습니다. block이 비공개인 경우(ADR 6 참조) 이를 가리키는 edge가 표시되어야 하는가? edge를 block에서 가시성 규칙을 상속하는 메타데이터로 취급할 것입니다: 즉, Block B를 볼 수 없으면 B의 콘텐츠를 유출하는 방식으로 edge "A supports B"를 볼 수 없어야 합니다. 쿼리에서 강제할 것입니다: edge를 나열할 때 to 또는 from이 사용자가 액세스할 수 없는 block인 edge를 필터링합니다. 또한 edge를 생성하려면 두 block을 볼 수 있는 권한이 필요할 것입니다(그리고 나가는 링크를 추가하는 것을 해당 block의 컨텍스트를 편집하는 것으로 취급하는 경우 "from" block에 대한 쓰기 권한). edge 생성 변경에서 이러한 규칙을 명확히 하고 확인을 구현할 것입니다.
- **UI 복잡성:** 사용자에게 그래프를 나타내는 것은 UI 어포던스가 필요함을 의미합니다. MVP의 경우 간단하게 유지할 수 있습니다: 예: 주장 block 아래에 지원 증거 block을 나열합니다(edge를 통해 가져옴). 또는 참조에서 역링크를 표시합니다(이 block을 참조하는 block). 이는 edge를 쿼리하여 수행할 수 있습니다. 전체 그래프 시각화 또는 순회 인터페이스는 나중에 올 수 있습니다. 데이터 모델이 이를 제한하지 않도록 해야 합니다 – 제한하지 않습니다. 일반 그래프이므로.
- **일괄 작업:** 일부 사용자 작업은 한 번에 여러 edge를 생성할 수 있습니다. 예를 들어, 사용자가 각주가 있는 markdown을 가져오는 경우 참조를 위한 block과 이를 연결하는 edge를 자동으로 생성할 수 있습니다. 설계는 대량 삽입을 처리할 수 있습니다(여러 변경만). 그러나 일부가 실패하는 경우 일관성을 염두에 두어야 합니다 – 필요한 모든 block과 edge를 생성하거나 오류 시 중단하는 Convex 함수로 래핑할 것입니다.
- **고급 사용을 위한 Edge 속성:** edge에 속성을 위한 공간을 남겼습니다. MVP에서는 "contains"의 순서를 제외하고는 많이 사용하지 않을 수 있습니다. 그러나 필요한 경우 edge는 설명이나 가중치와 같은 속성을 보유할 수 있습니다(예: 지원이 얼마나 강한지를 나타내는 점수). 모델은 변경 없이 이를 지원하여 유연성을 보여줍니다.

## 확장 경로

- **추가 Edge 타입 / 온톨로지:** 지식 베이스가 성장함에 따라 더 미묘한 관계 타입 또는 도메인별 온톨로지를 도입할 수 있습니다. 예를 들어, 과학적 컨텍스트에서 "extends"(이전 작업을 확장하는 연구용), "confirms", "disputes" 등을 추가할 수 있습니다. ADR의 모델은 새 타입을 쉽게 허용합니다. UI도 업데이트하고 사용자 명확성을 위해 다른 edge 타입을 색상 코딩하거나 아이콘화할 수 있습니다.
- **가중치 또는 주석이 달린 Edge:** 논증 매핑에서 때때로 supports/opposes는 가중치가 있습니다(강하게 지원, 약하게 지원 등). edge에 가중치 또는 점수 필드를 추가하거나 별도의 타입으로 나타낼 수 있습니다(예: "strongly_supports"). 더 구조화된 접근 방식은 edge가 작은 콘텐츠 페이로드를 전달하도록 허용하는 것입니다 – 예를 들어, edge에 Block A가 Block B를 지원하는 _이유_를 설명하는 정당화 텍스트가 있을 수 있습니다. 스키마는 이를 위한 주석 필드를 수용할 수 있습니다. 향후 edge 자체를 풍부한 주석을 허용하기 위해 전체 "block" 상태로 승격할 수도 있습니다. 그러나 이는 모델을 복잡하게 만듭니다(메타 그래프의 노드로서의 edge). 지금은 간단한 속성으로 충분합니다.
- **Graph 시각화 및 쿼리:** 지식의 시각적 그래프 뷰를 구현할 수 있습니다. 이를 효율적으로 수행하려면 하위 그래프(주어진 block의 N 홉 내의 모든 노드와 edge)를 검색해야 할 수 있습니다. 이러한 하위 그래프 데이터를 수집하기 위해 깊이 제한 DFS/BFS를 수행하는 전용 Convex 함수를 만들 수 있습니다. 이것이 집약적이 되면 일부 그래프 구조를 캐싱하거나 관계를 위한 외부 검색 인덱스를 사용하는 것을 고려할 수 있습니다. 확장은 분석 기능을 구축하는 경우 그래프 알고리즘(최단 경로, 중심성)과 통합할 수도 있습니다. 그래프가 구축되면 중심성과 같은 메트릭을 계산하는 것에 대한 연구가 언급되어 있으며[[28]](https://shilpathota.medium.com/understanding-knowledge-graphs-for-agentic-ai-7162d018387b#:~:text=We%2520have%2520directed%2520graphs%2520where,the%2520shortest%2520routes%2520between%2520nodes), 이는 지식 베이스에서 주요 block을 식별하는 데 흥미로울 수 있습니다.
- **연합 및 인스턴스 간 Edge:** 향후 시스템의 여러 인스턴스가 지식을 공유하는 경우 다른 인스턴스의 block을 연결하는 edge를 허용할 수 있습니다. 이는 질문을 제기합니다: block을 전역적으로 고유하게 식별하는 방법(전역 ID 체계 또는 URI가 필요할 수 있음)? 원격 콘텐츠를 참조하기 위해 Atproto/ActivityPub과 같은 것을 사용할 수 있습니다. 외부 참조를 보유하기 위해 필드로 edge를 확장할 수 있습니다(예: toExternal: {instance: URL, id: externalId}). 처음에는 범위를 벗어나지만 모델은 로컬 Convex 데이터베이스 외부를 가리키는 "외부 edge"를 지원하도록 확장될 수 있습니다. 이는 한 서버의 주장이 다른 서버의 증거에 의해 지원되는 연합 지식 네트워크에서 핵심이 될 것입니다.
- **자동화된 Edge 생성 (AI 주도):** AI 에이전트(Mastra 등)의 도입으로 edge를 자동으로 제안하거나 생성하는 도구를 예상합니다. 예를 들어, block을 읽는 AI는 "이 block은 Block Z와 모순됩니다"를 제안하고 refutes edge를 제안할 수 있습니다. 또는 자동 인용: 에이전트가 관련 소스를 찾고 references edge를 생성합니다. 시스템은 edge가 단지 데이터이기 때문에 이를 수용할 수 있습니다 – 적절한 권한이 있는 에이전트는 addEdge를 호출할 수 있습니다. 사용자가 신뢰하거나 확인할 수 있도록 이러한 edge를 AI 제안으로 표시해야 할 수 있습니다(속성 또는 특정 하위 타입을 통해). 이는 핵심 아키텍처를 사용하여 지식 그래프를 지능적으로 심화하는 확장입니다.
- **계층적 또는 복합 Edge 타입:** 결국 관계에 계층 구조를 도입할 수 있습니다(일부 타입이 다른 타입의 하위 타입일 수 있음). 예를 들어, "supports" edge는 "empirical_support" 대 "theoretical_support"로 나눌 수 있습니다. 이러한 분류법을 관리하려면 타입 명명의 규칙 또는 명시적 스키마가 필요할 수 있습니다. 필요한 경우 온톨로지 테이블을 추가하거나 타입에 접두사를 사용할 수 있습니다(support:empirical과 같은). 이를 통해 더 복잡한 추론이 가능합니다. 이는 추측이며 명확한 사용 사례가 있을 때 접근할 것입니다.
- **Edge 수명 주기 및 버전 관리:** 현재 edge는 상대적으로 정적 링크입니다. 향후 edge 자체가 변경되거나 논쟁될 수 있습니다(한 사용자가 지원 링크를 주장하고 다른 사용자가 동의하지 않을 수 있음). block처럼 edge를 버전 관리할 수 있습니다 – 그러나 이는 복잡성의 계층을 추가합니다(edge 존재가 추가/제거된 히스토리를 가질 수 있음). 지금은 edge가 존재하거나 존재하지 않는다고 가정하지만 확장은 edge가 도입되거나 제거된 시기를 추적하는 것을 고려할 수 있습니다. 이는 훨씬 더 풍부한 지식 관리 관행과 일치할 것입니다(아이디어가 어떻게 연결되었는지의 히스토리와 같은).
